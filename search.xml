<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VCS-Ucli命令汇总</title>
      <link href="/2024/11/16/VCS-ucli%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2024/11/16/VCS-ucli%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下是一些常用的 VCS 调试命令，帮助更高效地进行仿真调试。<a><span id="more"></span></a></p></blockquote><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><strong>scope</strong></td><td>显示当前的顶层模块</td><td></td></tr><tr><td><strong>scope xxx</strong></td><td>进入 <code>xxx</code> 模块</td><td></td></tr><tr><td><strong>scope -up</strong></td><td>回到上一层模块</td><td></td></tr><tr><td><strong>show</strong></td><td>显示当前模块的信号及子模块</td><td></td></tr><tr><td><strong>show xxx -value -radix hex&#x2F;bin&#x2F;dec</strong></td><td>以特定进制（十六进制、二进制或十进制）显示信号值</td><td><code>xxx</code> 为信号名称</td></tr><tr><td><strong>run</strong></td><td>运行仿真，直到遇到 <code>$stop</code> 或设置的断点</td><td></td></tr><tr><td><strong>run xx</strong></td><td>运行仿真，持续 <code>xx</code> 时间后停止（不推荐使用）</td><td></td></tr><tr><td><strong>run -posedge xx</strong></td><td>运行仿真，直到信号 <code>xx</code> 的上升沿</td><td></td></tr><tr><td><strong>run -negedge xx</strong></td><td>运行仿真，直到信号 <code>xx</code> 的下降沿</td><td></td></tr><tr><td><strong>run -change xx</strong></td><td>运行仿真，直到信号 <code>xx</code> 变化时停止</td><td></td></tr><tr><td><strong>stop</strong></td><td>显示当前已经设置的断点</td><td></td></tr><tr><td><strong>stop -posedge xx</strong></td><td>在信号 <code>xx</code> 的上升沿设置断点</td><td></td></tr><tr><td><strong>stop -negedge xx</strong></td><td>在信号 <code>xx</code> 的下降沿设置断点</td><td></td></tr><tr><td><strong>stop -condition {信号表达式}</strong></td><td>在信号表达式为真时设置断点</td><td>例如：<code>stop -condition &#123;a == 1&#125;</code></td></tr><tr><td><strong>stop -delete xx</strong></td><td>删除编号为 <code>xx</code> 的断点</td><td><code>xx</code> 为断点编号</td></tr><tr><td><strong>restart</strong></td><td>重新启动 UCLI 调试</td><td></td></tr><tr><td><strong>&lt;cmd&gt; -h</strong></td><td>查询某个命令的帮助信息</td><td><code>&lt;cmd&gt;</code> 为具体的命令，例如 <code>run -h</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> VCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DV </tag>
            
            <tag> VCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VCS动态加载DPI共享库(.so)</title>
      <link href="/2024/11/16/VCS%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDDPI%E5%85%B1%E4%BA%AB%E5%BA%93(.so)/"/>
      <url>/2024/11/16/VCS%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDDPI%E5%85%B1%E4%BA%AB%E5%BA%93(.so)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用Verilog&#x2F;SystemVerilog进行硬件验证时，动态加载DPI（Direct Programming Interface）共享库是一个常见且强大的功能。通过这种方式，我们可以将C或C++代码与Verilog代码结合起来，以实现更复杂的验证任务。本文将介绍如何在VCS仿真环境中动态加载DPI共享库，以及如何高效地管理这些库文件。<a><span id="more"></span></a></p></blockquote><h2 id="VCS编译与DPI共享库"><a href="#VCS编译与DPI共享库" class="headerlink" title="VCS编译与DPI共享库"></a><a>VCS编译与DPI共享库</a></h2><p>在VCS中，我们通常先进行VCS的编译（<code>vcs compile</code>），然后通过调用GCC编译器生成C语言的<code>.so</code>文件（共享库）。这些<code>.so</code>文件包含了C&#x2F;C++代码，可以在仿真时与SystemVerilog代码进行交互。</p><h3 id="动态加载DPI共享库"><a href="#动态加载DPI共享库" class="headerlink" title="动态加载DPI共享库"></a>动态加载DPI共享库</h3><p>在仿真运行时（<code>vcs run</code>），需要手动加载这些<code>.so</code>文件。VCS提供了两种命令行选项来加载DPI共享库，具体方式如下：</p><ul><li><strong>使用<code>-sv_liblist</code>指定.so的列表文件（Bootstrap file）</strong><br>这种方式需要提供一个列表文件，其中列出了所有需要加载的<code>.so</code>文件（不需要加文件后缀名）。这个文件将包含所有依赖的共享库路径，VCS会根据这些信息动态加载相关的库。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-sv_liblist Bootstrap.file</span><br></pre></td></tr></table></figure><ul><li><strong>使用<code>-sv_lib</code>逐个指定共享库</strong><br>你也可以通过<code>-sv_lib</code>选项手动指定每个<code>.so</code>库。注意，库名不需要加<code>.so</code>后缀。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-sv_lib libname</span><br></pre></td></tr></table></figure><h3 id="配置DPI共享库根目录"><a href="#配置DPI共享库根目录" class="headerlink" title="配置DPI共享库根目录"></a>配置DPI共享库根目录</h3><p><code>-sv_root</code>选项用于指定DPI共享库的根目录。这个目录是共享库查找的起始路径。通过设置这个选项，我们可以确保仿真器在正确的位置查找和加载共享库。特别是，这个路径还支持环境变量<code>$ENV</code>，使得路径设置更加灵活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-sv_root /home/user</span><br></pre></td></tr></table></figure><h2 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a><a>示例配置</a></h2><p>假设我们有一组共享库文件，分别位于不同的目录。可以通过以下两种方式进行配置：</p><h4 id="使用-sv-liblist"><a href="#使用-sv-liblist" class="headerlink" title="使用-sv_liblist"></a>使用<code>-sv_liblist</code></h4><p>首先，设置DPI共享库根目录，然后指定包含共享库路径的列表文件（<code>Bootstrap.file</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-sv_root /home/user</span><br><span class="line">-sv_liblist Bootstrap.file</span><br></pre></td></tr></table></figure><h4 id="使用-sv-lib"><a href="#使用-sv-lib" class="headerlink" title="使用-sv_lib"></a>使用<code>-sv_lib</code></h4><p>另外一种方式是直接指定每个共享库的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-sv_root /home/user</span><br><span class="line">-sv_lib myclibs/lib1</span><br><span class="line">-sv_lib myclibs/lib3</span><br><span class="line">-sv_lib proj1/clibs/lib4</span><br></pre></td></tr></table></figure><p>这会加载以下路径的共享库：</p><ul><li><code>/home/user/myclibs/lib1.so</code></li><li><code>/home/user/myclibs/lib3.so</code></li><li><code>/home/user/proj1/clibs/lib4.so</code></li></ul><h3 id="sv-liblist示例"><a href="#sv-liblist示例" class="headerlink" title="sv_liblist示例"></a>sv_liblist示例</h3><p>在<code>Bootstrap.file</code>文件中，你可以列出所有需要加载的共享库。文件内容可能类似如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myclibs/lib1</span><br><span class="line">myclibs/lib3</span><br><span class="line">proj1/clibs/lib4</span><br></pre></td></tr></table></figure><p>这些库的完整路径将在仿真过程中被解析为：</p><ul><li><code>/home/user/myclibs/lib1.so</code></li><li><code>/home/user/myclibs/lib3.so</code></li><li><code>/home/user/proj1/clibs/lib4.so</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h2><p>动态加载DPI共享库是一种强大的技术，能够帮助我们在VCS仿真过程中将C&#x2F;C++代码与Verilog代码无缝集成。通过使用<code>-sv_liblist</code>或<code>-sv_lib</code>选项，我们可以灵活地加载多个共享库，而<code>-sv_root</code>选项则允许我们指定共享库的根目录。这些功能不仅提高了仿真效率，还增加了配置的灵活性。</p><p>如果你正在进行复杂的硬件验证，尤其是需要与C&#x2F;C++代码交互时，掌握这些DPI共享库加载技巧将大大提高你的工作效率。</p>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> VCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DV </tag>
            
            <tag> VCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高VCS仿真效率-UVM Runtime Cmdline和VCS分块编译</title>
      <link href="/2024/11/16/%E6%8F%90%E9%AB%98VCS%E4%BB%BF%E7%9C%9F%E6%95%88%E7%8E%87-UVM%20Runtime%20Cmdline%E5%92%8CVCS%E5%88%86%E5%9D%97%E7%BC%96%E8%AF%91/"/>
      <url>/2024/11/16/%E6%8F%90%E9%AB%98VCS%E4%BB%BF%E7%9C%9F%E6%95%88%E7%8E%87-UVM%20Runtime%20Cmdline%E5%92%8CVCS%E5%88%86%E5%9D%97%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在实际验证过程中，仿真效率是我们常常面临的挑战之一。尤其是在修改代码时，明明只改动了一个文件（例如，在testcase中增加了一行打印），但编译却需要重新编译整个工程中的所有文件。这种情况不仅浪费了大量时间，还显著降低了仿真效率。为了应对这种问题，常用的解决方法有两种：充分利用UVM的runtime cmdline传递参数机制和增量编译。然而，即使采用了增量编译，仿真效率仍然受到一定影响，因为仿真器无法准确识别哪些文件已经被修改。那么，是否有其他方法可以进一步提高仿真效率呢？答案是：分块编译（Partition Compile）。本文将详细介绍这两种方法及其优缺点，特别是分块编译如何作为增量编译的一种有效补充。<a><span id="more"></span></a></p></blockquote><h2 id="1-充分利用UVM的runtime-cmdline传递参数机制"><a href="#1-充分利用UVM的runtime-cmdline传递参数机制" class="headerlink" title="1. 充分利用UVM的runtime cmdline传递参数机制"></a><a>1. 充分利用UVM的runtime cmdline传递参数机制</a></h2><p>在UVM中，我们可以通过命令行动态地传递参数，而不必重新编译代码。这对于提高仿真效率非常重要，因为每次修改UVM相关参数时，都可以避免重新编译整个项目。</p><p>比如，在测试过程中，我们可以使用命令行来动态修改UVM的相关参数，如<code>UVM_TESTNAME</code>、<code>UVM_VERBOSITY</code>等，这样就能在运行时直接影响UVM环境的行为，而不需要重新编译源代码。具体来说，只需在仿真启动时通过命令行传递这些参数，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs +UVM_TESTNAME=test1 +UVM_VERBOSITY=UVM_LOW</span><br></pre></td></tr></table></figure><p>这种方式不仅避免了不必要的重新编译，还能更灵活地调整仿真设置，提高工作效率。</p><h2 id="2-增量编译"><a href="#2-增量编译" class="headerlink" title="2. 增量编译"></a><a>2. 增量编译</a></h2><p>增量编译是提升仿真效率的另一种常用方法。它的理想情况是：只有修改过的文件需要重新编译，而未修改的文件则跳过编译。通过这种方式，我们可以显著减少编译时间。</p><p>在VCS中，增量编译可以通过添加<code>-Mupdate</code>参数来启用。该参数允许仿真器检测文件是否发生了修改，只有修改过的文件才会被重新编译。然而，实际使用中，我们发现即使启用了增量编译，仿真器依然会重新编译一些未修改的文件。这是因为仿真器的优化能力还不够，无法准确识别哪些文件被修改了。</p><h2 id="3-VCS分块编译（Partition-Compile）"><a href="#3-VCS分块编译（Partition-Compile）" class="headerlink" title="3. VCS分块编译（Partition Compile）"></a><a>3. VCS分块编译（Partition Compile）</a></h2><p>为了进一步提高仿真效率，VCS提供了一种名为<strong>分块编译（Partition Compile）</strong>的方法。分块编译的核心思想是将整个工程中的文件划分为多个独立的“块”，只有当某个块中的文件被修改时，才会重新编译该块中的文件。通过这种方式，我们可以减少每次编译所需处理的文件数量，从而提高仿真效率。</p><h3 id="分块编译的基本原理"><a href="#分块编译的基本原理" class="headerlink" title="分块编译的基本原理"></a>分块编译的基本原理</h3><p>分块编译的本质是将代码拆分成若干个独立的块，每个块都包含一组相关的文件。只有当某个块中的文件发生变化时，仿真器才会重新编译该块。而在其他块中没有修改的文件则不会被重新编译。因此，通过合理划分这些块，我们可以减少编译的范围，从而提高效率。</p><p>然而，分块编译的精细程度需要在“精细”和“高效”之间找到一个平衡。如果将文件拆分得过细，仿真器需要处理的块会增多，从而消耗更多的系统时间；如果块划分过粗，又可能导致重新编译的文件过多。因此，在块分割的粒度上，需要根据实际情况进行调节。</p><h3 id="VCS分块编译的实现"><a href="#VCS分块编译的实现" class="headerlink" title="VCS分块编译的实现"></a>VCS分块编译的实现</h3><p>在VCS中，我们可以通过添加<code>-partcomp</code>参数来启用分块编译功能。具体的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs -partcomp</span><br></pre></td></tr></table></figure><p>此外，VCS还支持自动划分Partition的大小和数量，可以通过以下选项来指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs -partcomp=autopart_[low|medium|high]</span><br></pre></td></tr></table></figure><p>这三个选项分别对应不同的分块粒度（低、中、高），一般情况下可以使用<a>默认设置</a>，不必手动调整。</p><ul><li>添加<code>-pcmakeprof</code>把编译过程中的每一步所花费的时间做分析打印，并在编译日志的结尾进行输出，这样方便比较不同编译参数所花费的编译时间的区别。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs -pcmakeprof</span><br></pre></td></tr></table></figure></li></ul><h4 id="纵向分析：VCS仿真流程"><a href="#纵向分析：VCS仿真流程" class="headerlink" title="纵向分析：VCS仿真流程"></a>纵向分析：VCS仿真流程</h4><table><thead><tr><th>阶段</th><th>描述</th><th>作用&#x2F;功能</th></tr></thead><tbody><tr><td><strong>Parsing</strong></td><td>解析过程，读取文件并进行语法分析。</td><td>将Verilog&#x2F;SystemVerilog源代码转换为仿真器可以理解的格式，检查语法和结构的正确性。</td></tr><tr><td><strong>_Elabcom</strong></td><td>编译文件生成过程，生成提供给Verdi解析的编译文件（需要<code>-kdb</code>选项）。</td><td>生成仿真器调试信息，供Verdi等工具解析和调试。</td></tr><tr><td><strong>Compiling</strong></td><td>编译过程，检查语法错误并生成中间二进制文件。</td><td>检查Verilog&#x2F;SystemVerilog代码中的语法错误，并生成Elaboration阶段可以识别的二进制文件。</td></tr><tr><td><strong>Elaboration</strong></td><td>精化过程，计算模块的参数值，处理模块的绑定关系，生成最终可执行文件<code>simv</code>。</td><td>根据设计层次结构计算参数，处理模块绑定关系，生成最终的可执行仿真文件<code>simv</code>。</td></tr></tbody></table><h4 id="横向分析：VCS仿真性能指标"><a href="#横向分析：VCS仿真性能指标" class="headerlink" title="横向分析：VCS仿真性能指标"></a>横向分析：VCS仿真性能指标</h4><table><thead><tr><th>性能指标</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td><strong>Real time</strong></td><td>程序从开始到结束的总时间。</td><td>仿真程序执行的真实时间，包括所有计算、I&#x2F;O操作等。</td></tr><tr><td><strong>User time</strong></td><td>程序在用户模式下的CPU耗时。</td><td>仿真程序在执行用户代码时消耗的CPU时间。通常与程序逻辑的复杂度相关。</td></tr><tr><td><strong>Sys time</strong></td><td>程序在内核模式下的CPU耗时。</td><td>仿真程序在执行系统调用、I&#x2F;O操作等内核级任务时消耗的CPU时间。</td></tr><tr><td><strong>Virt</strong></td><td>程序的虚拟内存空间大小。</td><td>仿真程序的虚拟内存空间大小，包括所有可访问的内存地址空间。</td></tr><tr><td><strong>Res</strong></td><td>程序已映射到物理内存的部分。</td><td>程序在物理内存中占用的实际空间。</td></tr><tr><td><strong>Shr</strong></td><td>程序占用的共享内存大小。</td><td>仿真程序占用的共享内存区域，多个进程可能会访问这些内存。</td></tr></tbody></table><h3 id="手动指定Partition"><a href="#手动指定Partition" class="headerlink" title="手动指定Partition"></a>手动指定Partition</h3><p>如果需要更精细的控制，我们还可以手动指定Partition。通过在VCS编译命令中指定<code>-topcfg</code>选项，可以指定特定的配置文件，并在该配置文件中定义Partition。示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs -partcomp -top topcfg topcfg.v</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/16/cUY6sTmnyQdZoXR.png" alt="image-20241116134607941"></p><ul><li><code>-top</code>后面跟的topcfg根据我的实测是topcfg中的<code>config_name</code></li></ul><p>在<code>topcfg.v</code>文件中，我们可以定义具体的Partition，示例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">config</span> topcfg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">design</span>    apb_tb;</span><br><span class="line">  partition <span class="keyword">package</span> uvm_pkg;</span><br><span class="line">  partition <span class="keyword">package</span> svt_amba_uvm_pkg;</span><br><span class="line">  partition <span class="keyword">package</span> svt_uvm_pkg;</span><br><span class="line">  partition <span class="keyword">package</span> apb_pkg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endconfig</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们将<code>apb_tb</code>、<code>uvm_pkg</code>、<code>svt_amba_uvm_pkg</code>、<code>svt_uvm_pkg</code>和<code>apb_pkg</code>分别定义为独立的Partition，当其中的文件发生变化时，仿真器只会重新编译相应的Partition。(其中apb_tb是我顶层的tb)</p><h3 id="Partition并行参数"><a href="#Partition并行参数" class="headerlink" title="Partition并行参数"></a>Partition并行参数</h3><ul><li><code>-fastpartcomp=j4 </code>中的 <code>j4</code> 表示使用 4 个并行作业来执行编译任务。并行处理的优势在于，它可以同时处理多个部分，大大提高编译效率（j和4之间没有空白字符）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-fastpartcomp=j4</span><br></pre></td></tr></table></figure><h2 id="避免在-unit空间导入package：增量编译效率的陷阱"><a href="#避免在-unit空间导入package：增量编译效率的陷阱" class="headerlink" title="避免在$unit空间导入package：增量编译效率的陷阱"></a><a>避免在$unit空间导入package：增量编译效率的陷阱</a></h2><p>在进行Verilog&#x2F;SystemVerilog的设计和验证时，增量编译是一项至关重要的技术，它能够有效减少编译时间，提高仿真效率。然而，在实际使用过程中，我们需要注意一些常见的陷阱，特别是在项目的$unit空间中导入package（包）这一做法。</p><h3 id="什么是-unit空间？"><a href="#什么是-unit空间？" class="headerlink" title="什么是$unit空间？"></a>什么是$unit空间？</h3><p>在Verilog&#x2F;SystemVerilog中，<code>$unit</code>空间指的是<strong>顶层全局空间</strong>，通常是<code>package...endpackage</code>、<code>module...endmodule</code>、<code>interface...endinterface</code>之外的部分。简单来说，$unit层次是指那些不属于具体模块、接口或包的地方。它包括了定义文件级别的各种设置或行为的区域。</p><h3 id="为什么避免在-unit空间导入package？"><a href="#为什么避免在-unit空间导入package？" class="headerlink" title="为什么避免在$unit空间导入package？"></a>为什么避免在$unit空间导入package？</h3><p>导入<code>package</code>的本意是为了共享其中的定义、类型、函数等，避免重复编写相同的代码。但如果我们在$unit空间导入<code>package</code>，会带来以下几个问题：</p><ol><li><strong>增量编译失效</strong>： 当我们在$unit空间导入一个<code>package</code>时，这个<code>package</code>的变动将直接影响到所有使用它的模块和文件。假设这个<code>package</code>被多次导入，那么在后续修改<code>package</code>中的内容时，仿真器无法精确识别哪些文件发生了变化，进而会导致整个项目的重新编译。这使得增量编译失效，浪费大量编译时间。</li><li><strong>影响编译效率</strong>： 增量编译的核心优势是<strong>仅编译修改过的部分文件</strong>，但如果我们在$unit空间导入<code>package</code>，会使得修改<code>package</code>文件后，所有依赖它的模块都会被重新编译。对于大型项目来说，这种情况会显著降低编译效率，特别是当<code>package</code>较为庞大或被多个模块依赖时，编译时间会显著增加。</li><li><strong>影响项目的可维护性</strong>： 在$unit空间中随意导入<code>package</code>，可能导致代码结构混乱，依赖关系复杂，难以追溯具体依赖了哪些文件，增加了调试和维护的难度。</li></ol><h3 id="如何避免这个问题？"><a href="#如何避免这个问题？" class="headerlink" title="如何避免这个问题？"></a>如何避免这个问题？</h3><p>为了避免在$unit空间导入<code>package</code>带来的问题，我们可以采取以下策略：</p><ol><li><strong>局部导入<code>package</code></strong><br> 最好将<code>package</code>的导入限制在具体的模块、接口或包内部。这样只有在需要的地方才会导入，而不会影响到整个项目的编译。</li><li><strong>合理划分文件结构</strong><br> 尽量将公共包和模块隔离开来，在独立的文件夹中进行管理，避免包的导入影响到顶层全局空间。</li><li><strong>避免频繁修改核心<code>package</code></strong><br> 如果<code>package</code>中包含了多个常用的定义或函数，尽量减少对其结构的修改。若确实需要修改，尽量使这些修改局部化，避免频繁改动全局影响。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h2><p>提高仿真效率是每个验证工程师都希望解决的问题，尤其是在大型项目中，避免不必要的全量编译可以显著节省时间。通过UVM的runtime cmdline参数机制，我们可以避免重新编译整个项目，只通过命令行传递参数来修改UVM环境；通过增量编译，我们可以减少不必要的文件编译，但仍会遇到仿真器无法精确识别文件修改的情况；而VCS的分块编译则是一种有效的补充方法，它通过将文件划分为多个独立的块，减少每次需要重新编译的文件数量，从而提高仿真效率。</p><p>在实际工作中，我们可以根据项目的需求和仿真器的表现来选择合适的优化方式。分块编译作为增量编译的补充，将会在提高效率和缩短仿真时间方面发挥重要作用。</p>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> VCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DV </tag>
            
            <tag> VCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的基本命令</title>
      <link href="/2024/11/10/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/11/10/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Git 是一种分布式版本控制系统，广泛用于管理代码和文件的版本控制。它允许多个开发者在同一项目中并行工作，同时跟踪每个文件的修改历史，方便合并更改并解决冲突。<a><span id="more"></span></a></p></blockquote><h3 id="Git-基础操作"><a href="#Git-基础操作" class="headerlink" title="Git 基础操作"></a><a>Git 基础操作</a></h3><h4 id="1-初始化-Git-仓库"><a href="#1-初始化-Git-仓库" class="headerlink" title="1. 初始化 Git 仓库"></a>1. <strong>初始化 Git 仓库</strong></h4><p>在一个文件夹中初始化一个新的 Git 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这将创建一个 <code>.git</code> 文件夹，Git 用它来跟踪版本和历史。</p><h4 id="2-克隆现有仓库"><a href="#2-克隆现有仓库" class="headerlink" title="2. 克隆现有仓库"></a>2. <strong>克隆现有仓库</strong></h4><p>克隆一个现有的 Git 仓库到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repository_url&gt;</span><br></pre></td></tr></table></figure><p>例如，克隆 GitHub 上的一个仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/repository.git</span><br></pre></td></tr></table></figure><h4 id="3-检查-Git-状态"><a href="#3-检查-Git-状态" class="headerlink" title="3. 检查 Git 状态"></a>3. <strong>检查 Git 状态</strong></h4><p>查看当前工作目录和暂存区的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>它会显示哪些文件已更改、哪些文件未被跟踪、哪些文件已暂存等信息。</p><h4 id="4-添加文件到暂存区"><a href="#4-添加文件到暂存区" class="headerlink" title="4. 添加文件到暂存区"></a>4. <strong>添加文件到暂存区</strong></h4><p>将文件添加到暂存区（准备提交）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>如果要添加所有更改的文件，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h4 id="5-提交更改"><a href="#5-提交更改" class="headerlink" title="5. 提交更改"></a>5. <strong>提交更改</strong></h4><p>提交暂存区的更改到本地仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Commit message&quot;</span></span><br></pre></td></tr></table></figure><p><code>-m</code> 后面是提交信息，简要描述这次提交的内容。</p><h4 id="6-查看提交历史"><a href="#6-查看提交历史" class="headerlink" title="6. 查看提交历史"></a>6. <strong>查看提交历史</strong></h4><p>查看提交的历史记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>这将列出所有提交，包括提交ID、作者、提交时间和提交信息。</p><h4 id="7-创建和切换分支"><a href="#7-创建和切换分支" class="headerlink" title="7. 创建和切换分支"></a>7. <strong>创建和切换分支</strong></h4><p>创建并切换到一个新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>切换到已有分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><h4 id="8-合并分支"><a href="#8-合并分支" class="headerlink" title="8. 合并分支"></a>8. <strong>合并分支</strong></h4><p>将另一个分支的更改合并到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>如果存在冲突，Git 会提示你手动解决冲突。</p><h4 id="9-推送更改到远程仓库"><a href="#9-推送更改到远程仓库" class="headerlink" title="9. 推送更改到远程仓库"></a>9. <strong>推送更改到远程仓库</strong></h4><p>将本地提交推送到远程仓库（如 GitHub）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>如果是第一次推送一个新分支，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><h4 id="10-拉取远程仓库的更改"><a href="#10-拉取远程仓库的更改" class="headerlink" title="10. 拉取远程仓库的更改"></a>10. <strong>拉取远程仓库的更改</strong></h4><p>获取远程仓库的更新并合并到本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>这相当于 <code>git fetch</code> 和 <code>git merge</code> 的组合。</p><h4 id="11-删除分支"><a href="#11-删除分支" class="headerlink" title="11. 删除分支"></a>11. <strong>删除分支</strong></h4><p>删除本地分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">git branch -d &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>删除远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><h4 id="12-查看差异"><a href="#12-查看差异" class="headerlink" title="12. 查看差异"></a>12. <strong>查看差异</strong></h4><p>查看文件修改的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>查看已暂存的更改与最后提交的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><h4 id="13-撤销更改"><a href="#13-撤销更改" class="headerlink" title="13. 撤销更改"></a>13. <strong>撤销更改</strong></h4><p>如果想撤销对某个文件的修改，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>如果想撤销暂存区的更改（还没有提交的更改）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>要完全撤销最后一次提交的更改（保留文件，但撤销提交）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><h4 id="14-解决冲突"><a href="#14-解决冲突" class="headerlink" title="14. 解决冲突"></a>14. <strong>解决冲突</strong></h4><p>如果在合并过程中出现冲突，Git 会标记出冲突部分。你需要手动解决冲突，然后使用以下命令标记冲突已解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;conflicted_file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><h4 id="15-标签"><a href="#15-标签" class="headerlink" title="15. 标签"></a>15. <strong>标签</strong></h4><p>标签用于标记重要的提交，例如版本发布：</p><p>创建一个标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><p>查看所有标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>推送标签到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><h3 id="Git-常用配置"><a href="#Git-常用配置" class="headerlink" title="Git 常用配置"></a><a>Git 常用配置</a></h3><h4 id="1-配置用户名和邮箱-设置-Git-用户名和邮箱是必要的，它们将用于提交记录"><a href="#1-配置用户名和邮箱-设置-Git-用户名和邮箱是必要的，它们将用于提交记录" class="headerlink" title="1. 配置用户名和邮箱 设置 Git 用户名和邮箱是必要的，它们将用于提交记录"></a>1. <strong>配置用户名和邮箱</strong> 设置 Git 用户名和邮箱是必要的，它们将用于提交记录</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-查看配置-查看-Git-配置信息"><a href="#2-查看配置-查看-Git-配置信息" class="headerlink" title="2. 查看配置 查看 Git 配置信息"></a>2. <strong>查看配置</strong> 查看 Git 配置信息</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h4 id="3-全局忽略文件-创建一个-gitignore-文件，列出不需要版本控制的文件或文件夹。例"><a href="#3-全局忽略文件-创建一个-gitignore-文件，列出不需要版本控制的文件或文件夹。例" class="headerlink" title="3. 全局忽略文件 创建一个 .gitignore 文件，列出不需要版本控制的文件或文件夹。例"></a>3. <strong>全局忽略文件</strong> 创建一个 <code>.gitignore</code> 文件，列出不需要版本控制的文件或文件夹。例</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.log</span><br><span class="line">*.tmp</span><br><span class="line">/node_modules</span><br></pre></td></tr></table></figure><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a><a>其他常用命令</a></h3><ul><li><p><strong>查看本地仓库信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p><strong>添加远程仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;repository_url&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>查看分支信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p><strong>查看文件历史</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;filename&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-rm-的常用用法"><a href="#git-rm-的常用用法" class="headerlink" title="git rm 的常用用法"></a><a><code>git rm</code> 的常用用法</a></h3><h4 id="1-删除一个文件-删除一个文件，并将删除操作加入暂存区，准备提交"><a href="#1-删除一个文件-删除一个文件，并将删除操作加入暂存区，准备提交" class="headerlink" title="1. 删除一个文件 删除一个文件，并将删除操作加入暂存区，准备提交"></a>1. <strong>删除一个文件</strong> 删除一个文件，并将删除操作加入暂存区，准备提交</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>   例如，删除文件 <code>example.txt</code>：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> example.txt</span><br></pre></td></tr></table></figure><p>   删除后，Git 会把这个删除操作添加到暂存区，在下一次提交时会从 Git 仓库中移除该文件。</p><h4 id="2-删除一个文件并保留本地文件-如果你希望删除-Git-仓库中的文件，但保留工作目录中的文件（即本地文件不被删除），可以使用-cached-选项"><a href="#2-删除一个文件并保留本地文件-如果你希望删除-Git-仓库中的文件，但保留工作目录中的文件（即本地文件不被删除），可以使用-cached-选项" class="headerlink" title="2. 删除一个文件并保留本地文件 如果你希望删除 Git 仓库中的文件，但保留工作目录中的文件（即本地文件不被删除），可以使用 --cached 选项"></a>2. <strong>删除一个文件并保留本地文件</strong> 如果你希望删除 Git 仓库中的文件，但保留工作目录中的文件（即本地文件不被删除），可以使用 <code>--cached</code> 选项</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>   例如，删除文件 <code>example.txt</code> 但保留本地副本：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached example.txt</span><br></pre></td></tr></table></figure><p>   这样做会将文件从 Git 仓库中删除，但文件仍然会保留在你的工作目录中。此操作常用于从 Git 仓库中移除敏感文件（如 <code>.env</code> 文件），但不希望本地文件被删除。</p><h4 id="3-删除多个文件-你可以使用通配符或多个文件路径来一次性删除多个文件"><a href="#3-删除多个文件-你可以使用通配符或多个文件路径来一次性删除多个文件" class="headerlink" title="3. 删除多个文件 你可以使用通配符或多个文件路径来一次性删除多个文件"></a>3. <strong>删除多个文件</strong> 你可以使用通配符或多个文件路径来一次性删除多个文件</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;</span><br></pre></td></tr></table></figure><p>   或者使用通配符删除所有 <code>.log</code> 文件：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> *.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><h4 id="4-删除目录-如果你想删除整个目录及其内容，可以使用-r-选项"><a href="#4-删除目录-如果你想删除整个目录及其内容，可以使用-r-选项" class="headerlink" title="4. 删除目录 如果你想删除整个目录及其内容，可以使用 -r 选项"></a>4. <strong>删除目录</strong> 如果你想删除整个目录及其内容，可以使用 <code>-r</code> 选项</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r &lt;directory_name&gt;</span><br></pre></td></tr></table></figure><p>   这将递归删除目录及其所有文件和子目录。</p><h3 id="删除文件后的操作"><a href="#删除文件后的操作" class="headerlink" title="删除文件后的操作"></a>删除文件后的操作</h3><p>在删除文件后，你需要提交更改以将删除操作记录到 Git 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Removed unnecessary files&quot;</span></span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="1-删除一个文件并提交：-假设你要删除文件-test-txt"><a href="#1-删除一个文件并提交：-假设你要删除文件-test-txt" class="headerlink" title="1. 删除一个文件并提交： 假设你要删除文件 test.txt"></a>1. <strong>删除一个文件并提交：</strong> 假设你要删除文件 <code>test.txt</code></h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> test.txt</span><br><span class="line">git commit -m <span class="string">&quot;Remove test.txt&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-仅从-Git-仓库中删除文件，保留本地文件：-假设你想从-Git-中删除文件-secrets-txt，但保留本地文件"><a href="#2-仅从-Git-仓库中删除文件，保留本地文件：-假设你想从-Git-中删除文件-secrets-txt，但保留本地文件" class="headerlink" title="2. 仅从 Git 仓库中删除文件，保留本地文件： 假设你想从 Git 中删除文件 secrets.txt，但保留本地文件"></a>2. <strong>仅从 Git 仓库中删除文件，保留本地文件：</strong> 假设你想从 Git 中删除文件 <code>secrets.txt</code>，但保留本地文件</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached secrets.txt</span><br><span class="line">git commit -m <span class="string">&quot;Remove secrets.txt from the repository&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR时序参数</title>
      <link href="/2024/11/09/DDR%E6%97%B6%E5%BA%8F%E5%8F%82%E6%95%B0/"/>
      <url>/2024/11/09/DDR%E6%97%B6%E5%BA%8F%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>PHY手册中ddr的时序参数和uMCTL2的时序参数，以及时序图 <a><span id="more"></span></a></p></blockquote><p><img src="https://s2.loli.net/2024/11/09/QqsBcDPluRTxv18.png" alt="image-20241109195426624"></p><p><img src="https://s2.loli.net/2024/11/09/9WQcjHUTiREafx2.png" alt="image-20241109195501856"></p><p><img src="https://s2.loli.net/2024/11/09/D65cQ2H1bajEIen.png" alt="image-20241109215911953"></p><p><img src="https://s2.loli.net/2024/11/09/6Sg9TQrobNyWqC4.png" alt="image-20241109215933399"></p><p><img src="https://s2.loli.net/2024/11/09/hBkjFDf4qbVRWEd.png" alt="image-20241109201316288"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Refresh命令</title>
      <link href="/2024/11/09/Refresh%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/11/09/Refresh%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自刷新（Self-Refresh） 和 自动刷新（Auto-Refresh） 是两种用来维持内存中数据的有效性、避免丢失数据的刷新模式。这两种模式的主要区别在于刷新操作的控制方式和适用场景。<a><span id="more"></span></a></p></blockquote><h3 id="1-自动刷新（Auto-Refresh）"><a href="#1-自动刷新（Auto-Refresh）" class="headerlink" title="1. 自动刷新（Auto-Refresh）"></a>1. <strong>自动刷新（Auto-Refresh）</strong></h3><p><strong>自动刷新</strong>模式是由<strong>内存控制器</strong>负责周期性地发出<strong>刷新命令</strong>，以确保内存的每个行在特定的时间间隔内都被刷新一次。这个刷新是全局的，控制器会自动在适当的时候发出刷新命令来刷新内存中所有的行。</p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><ul><li>在<strong>Auto-Refresh</strong>模式下，内存控制器会周期性地向DDR内存发出刷新命令（<code>REF</code>命令）。</li><li>刷新命令的频率是固定的，通常由内存的工作频率决定（例如每64ms刷新一次）。</li><li>控制器在这个过程中会根据设定的<strong>刷新周期</strong>，遍历内存的所有bank，并逐行刷新每个bank中的数据。</li><li>自动刷新的过程是由内存控制器统一调度和管理的，用户不需要手动干预。</li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>自动刷新</strong>的过程由内存控制器完全控制，通常在内存空闲时进行，不影响其他内存操作。</li><li>需要消耗内存带宽，因为刷新操作会占用内存的访问周期。</li><li>适合对实时性要求较高的系统，能够确保内存的数据保持有效，且不需要额外的控制。</li></ul><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li><strong>自动刷新</strong>通常用于普通的内存工作模式，在大多数DDR系统中，自动刷新是默认的刷新模式。</li><li>它是由内存控制器在后台管理的，因此适用于无需额外干预的应用。</li></ul><h3 id="2-自刷新（Self-Refresh）"><a href="#2-自刷新（Self-Refresh）" class="headerlink" title="2. 自刷新（Self-Refresh）"></a>2. <strong>自刷新（Self-Refresh）</strong></h3><p><strong>自刷新</strong>模式是一种低功耗模式，在这种模式下，<strong>内存本身</strong>会自动刷新其数据，而不需要依赖内存控制器。自刷新模式通常是在系统进入低功耗状态时使用的模式。</p><h4 id="工作原理：-1"><a href="#工作原理：-1" class="headerlink" title="工作原理："></a>工作原理：</h4><ul><li>在<strong>Self-Refresh</strong>模式下，内存会自主执行刷新操作，不依赖外部控制器发出刷新命令。</li><li>在进入自刷新模式之前，内存控制器会通过发出一个特定的命令将内存置于自刷新状态。</li><li>进入自刷新模式后，DDR内存会定期刷新自身的行（通常按照特定的时间间隔，如64ms），确保数据不丢失。</li><li>内存控制器在自刷新模式下会进入低功耗状态，基本不参与内存的读写操作，直到退出自刷新模式。</li></ul><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>自刷新</strong>模式是一种<strong>低功耗模式</strong>，它使得DDR内存在不需要外部控制的情况下自动进行数据刷新。</li><li>当内存处于<strong>自刷新</strong>模式时，内存控制器不进行数据读写操作，仅仅等待系统恢复或外部控制器的重新启动。</li><li>内存在此模式下自动刷新，而无需占用主系统的带宽，适合系统在待机或低功耗模式下运行时使用。</li></ul><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li><strong>自刷新</strong>模式常用于设备进入低功耗状态时，例如移动设备（智能手机、平板等）在待机时，或服务器系统在闲置时。</li><li>适用于不需要高频繁内存访问的场合，例如系统休眠期间。</li></ul><h3 id="3-两者的区别总结"><a href="#3-两者的区别总结" class="headerlink" title="3. 两者的区别总结"></a>3. <strong>两者的区别总结</strong></h3><table><thead><tr><th>特性</th><th><strong>Auto-Refresh</strong></th><th><strong>Self-Refresh</strong></th></tr></thead><tbody><tr><td><strong>控制方式</strong></td><td>内存控制器发出刷新命令</td><td>内存自主管理刷新</td></tr><tr><td><strong>功耗</strong></td><td>较高（因为控制器持续运行）</td><td>低功耗（内存自主刷新）</td></tr><tr><td><strong>适用场景</strong></td><td>系统正常运行时，需要保证数据有效性时</td><td>系统低功耗模式下，保持数据有效性</td></tr><tr><td><strong>刷新频率</strong></td><td>固定频率（通常是每64ms刷新一次）</td><td>自动刷新，内存自主控制刷新周期</td></tr><tr><td><strong>内存带宽占用</strong></td><td>会占用内存带宽进行刷新操作</td><td>无需占用带宽，因为刷新由内存自己进行</td></tr><tr><td><strong>是否需要控制器干预</strong></td><td>需要控制器发出刷新命令</td><td>不需要控制器，内存自动完成刷新</td></tr></tbody></table><h3 id="4-自刷新与自动刷新结合使用"><a href="#4-自刷新与自动刷新结合使用" class="headerlink" title="4. 自刷新与自动刷新结合使用"></a>4. <strong>自刷新与自动刷新结合使用</strong></h3><p>在某些复杂的DDR系统中，<strong>自刷新</strong>和<strong>自动刷新</strong>可能会结合使用。例如，当系统处于待机状态时，内存可能会切换到<strong>自刷新模式</strong>以减少功耗，但当系统恢复到活跃状态时，内存控制器又会重新启用<strong>自动刷新模式</strong>，以保证内存数据始终有效。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>自动刷新</strong>是内存控制器定期发出刷新命令来刷新内存数据，确保数据保持有效。</li><li><strong>自刷新</strong>是内存本身独立进行刷新操作，适用于系统处于低功耗模式时。</li><li>自刷新通常用于降低功耗，而自动刷新是确保内存数据完整性和有效性的常规操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQS漂移检测与补偿</title>
      <link href="/2024/11/09/DQS%E6%BC%82%E7%A7%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A1%A5%E5%81%BF/"/>
      <url>/2024/11/09/DQS%E6%BC%82%E7%A7%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A1%A5%E5%81%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DQS（Data Strobe）是DDR内存系统中的关键时钟信号，其准确性对数据传输至关重要。在DDR内存系统中，DQS信号的漂移会导致数据读取的错误，因此需要监测并补偿漂移。<a><span id="more"></span></a></p></blockquote><h3 id="1-DQS漂移检测和补偿的概述"><a href="#1-DQS漂移检测和补偿的概述" class="headerlink" title="1. DQS漂移检测和补偿的概述"></a>1. <strong>DQS漂移检测和补偿的概述</strong></h3><p>除了标准的DQS门控LCDL VT补偿外，DDR IP提供了一种可选的功能，用于检测和补偿来自DDR IP内部以及外部（包括SDRAM）的漂移。其基本原理是通过采样进入的读取DQS#信号与门控信号，并持续追踪这些采样值是否发生变化。</p><h3 id="2-门控信号和DQS-信号采样"><a href="#2-门控信号和DQS-信号采样" class="headerlink" title="2. 门控信号和DQS#信号采样"></a>2. <strong>门控信号和DQS#信号采样</strong></h3><ul><li>设计中使用两个门控信号，之间有一个小的可编程延迟（通过<code>DTCR1.RDLVLGDIFF</code>设置）。这两个信号会在DQS#信号的上升沿两侧采样。</li><li>如果没有漂移，两个门控信号的采样值应该分别是0和1（即在DQS信号的上升沿一侧为0，另一侧为1）。</li><li>如果两个门控信号都采样到0或1，表明DQS信号相对于门控信号发生了漂移。采样值的变化指示了漂移的方向，PUB（PHY控制单元）可以根据此信息调整门控信号的位置。</li></ul><h3 id="3-漂移检测和补偿启用"><a href="#3-漂移检测和补偿启用" class="headerlink" title="3. 漂移检测和补偿启用"></a>3. <strong>漂移检测和补偿启用</strong></h3><ul><li>DQS漂移检测和补偿功能通过设置<code>DQSDR0.DFTDTEN</code>来启用。</li><li>需要注意的是，只有两种补偿机制中的一种可以启用：<code>DQSDR0.DFTDTEN</code> 和 <code>DXnGCR3.RGLVT</code> 是互斥的，即不能同时启用。</li></ul><h3 id="4-漂移补偿过程"><a href="#4-漂移补偿过程" class="headerlink" title="4. 漂移补偿过程"></a>4. <strong>漂移补偿过程</strong></h3><ul><li>当PUB检测到漂移时，它会通过标准的DFI PHY更新协议通知控制器，要求DFI总线空闲以便启动漂移补偿机制。</li><li>控制器确认PHY更新后，PUB会执行<code>DQSDR0.DFTUPDRD</code>虚拟读取，以获取最新的漂移状态。</li><li>由于漂移检测机制无法检测漂移的幅度（尤其是在任务模式下进行DFI事务时），PUB需要通过增量补偿例程来确定漂移的幅度。具体做法是，PUB会发出一系列的虚拟读取操作（dummy reads），每次检测到漂移时，PUB会通过<code>DQSDR1.DFTDLY</code>调整延迟来进行补偿。直到不再检测到漂移为止。</li><li>如果<code>DQSDR0.DFTUPDRD</code>设置为0，则PUB只会执行单步漂移补偿，调整数字延迟线的<code>DQSDR0.DTDLY</code>延迟，这时不会在漂移补偿阶段实际确定漂移幅度。</li></ul><h3 id="5-漂移检测的特殊情形"><a href="#5-漂移检测的特殊情形" class="headerlink" title="5. 漂移检测的特殊情形"></a>5. <strong>漂移检测的特殊情形</strong></h3><p>漂移检测可能无法在某些情况下进行，尤其是在没有读取事务或门控信号没有变化时。为此，PUB提供了以下机制：</p><ul><li><strong>无读取场景</strong>：如果控制器长时间没有对某个rank执行读取操作，PUB会在<code>DQSDR1.DFTRDIDLC × DQSDR1.DFTRDIDLF</code>时钟周期后请求PHY更新，执行<code>DQSDR0.DFTIDLRD</code>虚拟读取。</li><li><strong>连续读取场景</strong>：如果控制器发送了连续的读取操作，PUB会在<code>DQSDR1.DFTRDB2BC * DQSDR1.DFTRDB2BF</code>时钟周期后请求PHY更新，执行<code>DQSDR1.DFTB2BRD</code>虚拟读取。</li></ul><h3 id="6-DQS漂移逻辑"><a href="#6-DQS漂移逻辑" class="headerlink" title="6. DQS漂移逻辑"></a>6. <strong>DQS漂移逻辑</strong></h3><p>DQS漂移逻辑只使用<strong>bank 0</strong>进行虚拟读取操作，并根据银行0的状态来决定是否需要发出激活命令。</p><h3 id="7-防止不必要的漂移检测和补偿"><a href="#7-防止不必要的漂移检测和补偿" class="headerlink" title="7. 防止不必要的漂移检测和补偿"></a>7. <strong>防止不必要的漂移检测和补偿</strong></h3><p>为了防止DQS漂移检测和&#x2F;或补偿的过度触发，PUB提供了两个可编程功能来调节漂移检测的频率和补偿：</p><ul><li><strong>漂移监测周期</strong>（<code>DQSDR2.DFTMNTPRD</code>）：指定两次漂移监测事件之间的最小时钟周期数。它控制PUB采样PHY宏的漂移状态的频率。此功能可以用于避免频繁的漂移检测，特别是当系统的漂移更像是抖动（jitter）而非单向漂移时。</li><li><strong>漂移阈值</strong>（<code>DQSDR2.DFTTHRSH</code>）：指定在同一方向上连续检测到的最小漂移次数，只有当检测到该阈值的漂移时，PUB才会认为漂移是有效的。如果漂移方向发生反转，计数器会重置。此功能用于避免频繁检测和&#x2F;或补偿周期性的漂移。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h2><p>这段话描述了<strong>DQS漂移的检测与补偿机制</strong>，该机制用于确保DQS信号在面临电压温度变化和系统状态变化时仍然稳定可靠。关键的步骤包括通过门控信号采样DQS信号来检测漂移，以及根据漂移的方向来调整DQS门控位置。PUB通过增量补偿和虚拟读取操作来调整系统，以消除漂移的影响。为了避免频繁的补偿，系统提供了可编程功能来控制漂移监测的周期和阈值，从而确保系统的效率和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> VT compensation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQS门控信号的延迟补偿</title>
      <link href="/2024/11/09/DQS%E9%97%A8%E6%8E%A7%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF/"/>
      <url>/2024/11/09/DQS%E9%97%A8%E6%8E%A7%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在电压温度（VT）变化和SDRAM本身的漂移情况下如何确保DQS信号的稳定性和准确性。<a><span id="more"></span></a></p></blockquote><h3 id="1-DQS门控位置漂移的问题"><a href="#1-DQS门控位置漂移的问题" class="headerlink" title="1. DQS门控位置漂移的问题"></a>1. <strong>DQS门控位置漂移的问题</strong></h3><p>一旦DQS的门控位置被训练出来，DQS相对于门控信号的位置可能会发生漂移。这个漂移会减小最初训练的门控位置的裕量。漂移的原因可能是电压和温度的变化（VT变化），或者是来自SDRAM的未定义漂移。</p><h3 id="2-DQS门控信号路径匹配"><a href="#2-DQS门控信号路径匹配" class="headerlink" title="2. DQS门控信号路径匹配"></a>2. <strong>DQS门控信号路径匹配</strong></h3><p>在DDR IP模块内部，DQS门控信号的路径延迟是通过设计与读命令路径和读DQS路径的延迟总和匹配来完成的。为了确保DQS门控信号与读取数据路径的延迟相匹配，设计使用了与读取命令路径相同的时序和组件来驱动DQS门控信号。这是通过将门控信号返回到PHY并通过专用的I&#x2F;O接口（即PDQSG）传递来实现的，从而确保DQS门控信号的路径延迟与读DQS路径相匹配。</p><h3 id="3-匹配的关键组件"><a href="#3-匹配的关键组件" class="headerlink" title="3. 匹配的关键组件"></a>3. <strong>匹配的关键组件</strong></h3><p>在DDR IP中，门控I&#x2F;O（PDQSG）使用与读取命令I&#x2F;O驱动（PDDRIO）和读取DQS I&#x2F;O接收器（PDIFF）相同的驱动器和接收器组件。设计的目标是通过使用这些相同的组件，确保DQS门控信号路径的延迟与读命令和读DQS路径的延迟一致，从而自我补偿电压温度变化的影响。</p><h3 id="4-LCDL（延迟线）对VT变化的影响"><a href="#4-LCDL（延迟线）对VT变化的影响" class="headerlink" title="4. LCDL（延迟线）对VT变化的影响"></a>4. <strong>LCDL（延迟线）对VT变化的影响</strong></h3><p>DQS门控信号路径中唯一没有与读取命令&#x2F;数据路径匹配的主要组件是DQS门控LCDL（Delay Line）。这个延迟线负责确定门控信号的精细延迟。电压和温度变化会影响这个延迟线产生的延迟。因此，为了补偿这个效应，DDR IP使用延迟线VT补偿功能来补偿所有延迟线的VT变化。</p><h3 id="5-LCDL-VT补偿"><a href="#5-LCDL-VT补偿" class="headerlink" title="5. LCDL VT补偿"></a>5. <strong>LCDL VT补偿</strong></h3><p>对于DQS门控LCDL的延迟补偿，可以通过设置<code>DXnGCR3.RGLVT</code>来启用该功能。这意味着，当系统中的SDRAM没有显著的外部漂移时，标准的LCDL基于VT补偿机制就足够应对DQS信号与最初训练的门控信号之间的相对漂移。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>DQS信号的精确门控位置对DDR内存的性能至关重要。然而，DQS信号的延迟路径可能会受到电压和温度变化的影响，导致最初训练的门控位置出现漂移。为了避免这种漂移影响，DDR IP通过精确匹配DQS门控路径和读取数据路径的延迟来实现自我补偿。然而，DQS门控路径中的LCDL（延迟线）并不与其他路径完全匹配，因此必须通过一个专门的VT补偿机制来补偿由于VT变化带来的影响。这种补偿机制可以通过启用<code>DXnGCR3.RGLVT</code>功能来实现，从而保持DQS门控信号的稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> VT compensation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFI-update</title>
      <link href="/2024/11/09/DFI-update/"/>
      <url>/2024/11/09/DFI-update/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如何通过寄存器配置DQS漂移检测和补偿逻辑与其他如DDL和阻抗VT漂移的更新进行交互。<a><span id="more"></span></a></p></blockquote><h2 id="与其他PHY-控制器更新的交互"><a href="#与其他PHY-控制器更新的交互" class="headerlink" title="与其他PHY&#x2F;控制器更新的交互"></a><a><strong>与其他PHY&#x2F;控制器更新的交互</strong></a></h2><p>除了由<strong>DQS漂移检测和补偿逻辑</strong>生成的PHY更新请求外，<strong>DQS漂移</strong>还可以在以下情况下进行检测和补偿：</p><ol><li>由<strong>DDL</strong>（数字延迟线）或<strong>阻抗VT漂移</strong>生成的PHY更新。</li><li><strong>控制器更新</strong>期间。</li></ol><p>这类配置通过寄存器位<strong>DQSDR1.PUDFTUP</strong>和<strong>DQSDR1.CUDFTUP</strong>来完成。可以使用<strong>DQSDR0.PUDFTRD</strong>和<strong>DQSDR0.CUDFTRD</strong>寄存器位配置在这些外部更新期间的可选虚拟读操作的次数。</p><p>同样，<strong>DDL</strong>和<strong>阻抗VT漂移</strong>也可以配置为在最初由<strong>DQS漂移</strong>触发的PHY更新期间进行更新。此配置通过寄存器位<strong>DQSDR0.DFTDDLUP</strong>和<strong>DQSDR0.DFTZQUP</strong>来实现。</p><h3 id="关键点解释"><a href="#关键点解释" class="headerlink" title="关键点解释"></a>关键点解释</h3><ul><li><strong>DQS漂移</strong>：指的是数据时钟信号（DQS）由于温度、电压变化或其他因素引起的漂移，需要进行实时检测和补偿。</li><li><strong>DDL和阻抗VT漂移的交互</strong>：在<strong>DQS漂移</strong>的检测和补偿过程中，<strong>DDL</strong>和<strong>阻抗VT漂移</strong>的影响也可能同时被考虑，并在相关的PHY更新周期内进行补偿。</li><li><strong>第三方更新</strong>：指的是在非直接由<strong>DQS漂移</strong>引发的PHY更新中，进行的例如<strong>DDL</strong>或<strong>阻抗补偿</strong>更新，采用了虚拟读操作来确保更新的时序一致性。</li></ul><h3 id="配置寄存器位的功能："><a href="#配置寄存器位的功能：" class="headerlink" title="配置寄存器位的功能："></a>配置寄存器位的功能：</h3><ol><li><strong>DQSDR1.PUDFTUP</strong> 和 <strong>DQSDR1.CUDFTUP</strong>：这些寄存器位用于配置在<strong>DDL</strong>或<strong>阻抗VT漂移</strong>补偿期间的PHY更新。</li><li><strong>DQSDR0.PUDFTRD</strong> 和 <strong>DQSDR0.CUDFTRD</strong>：这些寄存器位用于配置在这些外部更新期间的虚拟读操作次数。</li><li><strong>DQSDR0.DFTDDLUP</strong> 和 <strong>DQSDR0.DFTZQUP</strong>：这些寄存器位用于配置<strong>DDL</strong>和<strong>阻抗VT漂移</strong>是否可以在由<strong>DQS漂移</strong>引发的PHY更新期间进行更新。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> DFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻抗校准的寄存器编程</title>
      <link href="/2024/11/09/%E9%98%BB%E6%8A%97%E6%A0%A1%E5%87%86%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/11/09/%E9%98%BB%E6%8A%97%E6%A0%A1%E5%87%86%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在DDR内存初始化和正常运行过程中，用户可以通过配置不同的寄存器来调整和控制阻抗校准的行为。<a><span id="more"></span></a></p></blockquote><h3 id="1-初始化期间的默认寄存器设置"><a href="#1-初始化期间的默认寄存器设置" class="headerlink" title="1. 初始化期间的默认寄存器设置"></a>1. <strong>初始化期间的默认寄存器设置</strong></h3><ul><li><strong>PIR.ZCALBYP</strong> 设置为‘0’，表示在初始化过程中不会绕过阻抗校准。</li><li><strong>ZQCR.PGWAIT</strong> 设置为 <code>0x5</code>，这个值适应控制时钟（ctl_clk）频率为 333 MHz 至 400 MHz。</li><li><strong>ZQCR.ZCALT</strong> 设置为 <code>0x1</code>，表示启用始终开启的背景校准。</li><li><strong>ZQCR.AVGEN</strong> 设置为 <code>0</code>，表示禁用代码平均，这样可以加快校准的完成时间。</li><li><strong>ZQCR.IODLMT</strong> 设置为 <code>0x2</code>，表示当电压温度漂移（VT drift）导致与之前校准的代码相差2个代码时，会触发VT相关的更新请求。</li><li><strong>ZQnPR.PU_ODT_ONLY</strong> 设置为 <code>0</code>，禁用LPDDR3&#x2F;DDR4的只上拉ODT（On Die Termination）校准。</li><li><strong>ZQnPR.ZPROG_ASYM_DRV_PU</strong> 和 <strong>ZQnPR.ZPROG_ASYM_DRV_PD</strong> 设置为 <code>0xb</code>，这两个寄存器用于设置典型工作条件下的上拉和下拉驱动强度校准代码。</li><li><strong>ZQnPR.ZPROG_PU_ODT_ONLY</strong> 设置为 <code>0x7</code>，设置上拉终端（ODT）仅进行校准的代码。</li><li><strong>ZQnPR.PU_DRV_ADJUST</strong> 和 <strong>ZQnPR.PD_DRV_ADJUST</strong> 设置为 <code>0x0</code>，表示禁用上拉和下拉驱动强度调整。</li><li><strong>ZQnPR.ODT_ZDEN</strong> 设置为 <code>0</code>，禁用终端代码覆盖功能。</li><li><strong>ZQnPR.DRV_ZDEN</strong> 设置为 <code>0</code>，禁用驱动强度代码覆盖功能。</li><li><strong>ZQnPR.ZSEGBYP</strong> 设置为 <code>0</code>，禁用校准段旁路。</li></ul><h3 id="2-初始化后的正常操作期间"><a href="#2-初始化后的正常操作期间" class="headerlink" title="2. 初始化后的正常操作期间"></a>2. <strong>初始化后的正常操作期间</strong></h3><ul><li>初始化后的默认设置保持不变，除了以下几点：<ul><li><strong>ZQCR.AVGEN</strong> 被设置为 <code>1</code>，表示始终启用代码平均（对校准过程进行多次平均，减少误差）。</li></ul></li></ul><h3 id="3-用户期望的编程模式"><a href="#3-用户期望的编程模式" class="headerlink" title="3. 用户期望的编程模式"></a>3. <strong>用户期望的编程模式</strong></h3><h4 id="a-非对称驱动强度校准（LPDDR3-DDR4）"><a href="#a-非对称驱动强度校准（LPDDR3-DDR4）" class="headerlink" title="a. 非对称驱动强度校准（LPDDR3&#x2F;DDR4）"></a>a. <strong>非对称驱动强度校准（LPDDR3&#x2F;DDR4）</strong></h4><ul><li>设置 <strong>ZQnPR.PU_ODT_ONLY</strong> 为 <code>1</code>，表示启用只上拉ODT校准。</li><li>设置 <strong>ZQnPR.ZPROG_ASYM_DRV_PU</strong> 为所需的上拉驱动强度分频比。</li><li>设置 <strong>ZQnPR.ZPROG_ASYM_DRV_PD</strong> 为所需的下拉驱动强度分频比。</li></ul><h4 id="b-仅上拉ODT校准（LPDDR3-DDR4）"><a href="#b-仅上拉ODT校准（LPDDR3-DDR4）" class="headerlink" title="b. 仅上拉ODT校准（LPDDR3&#x2F;DDR4）"></a>b. <strong>仅上拉ODT校准（LPDDR3&#x2F;DDR4）</strong></h4><ul><li>设置 <strong>ZQnPR.PU_ODT_ONLY</strong> 为 <code>1</code>，表示启用仅上拉ODT校准。</li><li>设置 <strong>ZQnPR.ZPROG_PU_ODT_ONLY</strong> 为所需的上拉终端分频比。</li></ul><h4 id="c-在非默认ctl-clk频率下进行校准（默认频率为400-MHz）"><a href="#c-在非默认ctl-clk频率下进行校准（默认频率为400-MHz）" class="headerlink" title="c. 在非默认ctl_clk频率下进行校准（默认频率为400 MHz）"></a>c. <strong>在非默认ctl_clk频率下进行校准（默认频率为400 MHz）</strong></h4><ul><li>根据操作频率设置 <strong>ZQCR.PGWAIT</strong> 寄存器的等待周期数。</li></ul><h4 id="d-控制校准重复（默认是背景模式，始终开启校准）"><a href="#d-控制校准重复（默认是背景模式，始终开启校准）" class="headerlink" title="d. 控制校准重复（默认是背景模式，始终开启校准）"></a>d. <strong>控制校准重复（默认是背景模式，始终开启校准）</strong></h4><ul><li><p>设置<code>ZQCR.ZCALT</code>为所需的校准粒度模式。</p><ul><li>注意：某些模式需要触发DFI控制&#x2F;PHY更新才能继续校准。</li></ul></li></ul><h4 id="e-代码平均控制"><a href="#e-代码平均控制" class="headerlink" title="e. 代码平均控制"></a>e. <strong>代码平均控制</strong></h4><ul><li><p>设置 <strong>ZQCR.AVGEN</strong> 为 <code>1</code> 启用代码平均，或设置为 <code>0</code> 禁用代码平均。</p></li><li><p>设置 <code>ZQCR.AVGMAX</code>来控制平均轮次数量。</p><ul><li>注：该值越大，校准时间越长。</li></ul></li></ul><h4 id="f-驱动强度调整"><a href="#f-驱动强度调整" class="headerlink" title="f. 驱动强度调整"></a>f. <strong>驱动强度调整</strong></h4><ul><li>设置 <strong>ZQnPR.PU_DRV_ADJUST</strong> 为所需的上拉驱动强度调整。</li><li>设置 <strong>ZQnPR.PD_DRV_ADJUST</strong> 为所需的下拉驱动强度调整。</li></ul><h4 id="g-代码覆盖"><a href="#g-代码覆盖" class="headerlink" title="g. 代码覆盖"></a>g. <strong>代码覆盖</strong></h4><ul><li><p>设置 <strong>ZQnPR.ODT_ZDEN</strong> 为 <code>1</code>，启用终端代码覆盖功能。</p></li><li><p>设置 <strong>ZQnPR.DRV_ZDEN</strong> 为 <code>1</code>，启用驱动强度代码覆盖功能。</p></li><li><p>设置 <strong>ZQnDR.ZDATA[15:0]</strong> 为所需的驱动强度ZCTRL代码，强制软件在该段上使用。</p></li><li><p>设置 <code>ZQnDR.ZDATA[31:16]</code>为所需的终端ZCTRL代码，强制软件在该段上使用。</p><ul><li>注：这些值需要由软件更新，并且不会进行VT补偿。</li></ul></li></ul><h4 id="h-校准旁路"><a href="#h-校准旁路" class="headerlink" title="h. 校准旁路"></a>h. <strong>校准旁路</strong></h4><ul><li>设置 <strong>PIR.ZCALBYP</strong> 为 <code>1</code>，这将禁用自动校准和VT补偿。</li></ul><h3 id="4-VREF使用设置"><a href="#4-VREF使用设置" class="headerlink" title="4. VREF使用设置"></a>4. <strong>VREF使用设置</strong></h3><ul><li><strong>IOVCR1.ZQREFIEN</strong> 设置为 ‘1’，表示使用内部生成的VREF为PZQ单元提供电压参考（VREF）。</li><li><strong>IOVCR1.ZQREFPEN</strong> 设置为 ‘0’，表示不使用外部VREF。</li><li>如果使用外部VREF，需将 <strong>IOVCR1.ZQREFIEN</strong> 设置为 ‘0’，并将 <strong>IOVCR1.ZQREFPEN</strong> 设置为 ‘1’。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段文档详细描述了<strong>阻抗校准</strong>过程中的寄存器编程，涵盖了从初始化到正常操作阶段，如何通过设置不同的寄存器来控制阻抗校准的细节，包括校准模式、驱动强度、代码覆盖、校准频率、平均控制等方面的内容。通过灵活的编程配置，用户可以根据实际需求调整DDR的性能和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Impedance Calibration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟线电压温度（VT）漂移检测与补偿的机制</title>
      <link href="/2024/11/09/%E5%BB%B6%E8%BF%9F%E7%BA%BF%E7%94%B5%E5%8E%8B%E6%B8%A9%E5%BA%A6%EF%BC%88VT%EF%BC%89%E6%BC%82%E7%A7%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A1%A5%E5%81%BF%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/11/09/%E5%BB%B6%E8%BF%9F%E7%BA%BF%E7%94%B5%E5%8E%8B%E6%B8%A9%E5%BA%A6%EF%BC%88VT%EF%BC%89%E6%BC%82%E7%A7%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A1%A5%E5%81%BF%E7%9A%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>确保在不同电压和温度变化下，DDR系统中的延迟线能够维持稳定的时延，从而保证系统的信号时序和可靠性。<a><span id="more"></span></a></p></blockquote><h3 id="1-VT漂移补偿逻辑"><a href="#1-VT漂移补偿逻辑" class="headerlink" title="1. VT漂移补偿逻辑"></a>1. <strong>VT漂移补偿逻辑</strong></h3><ul><li><strong>PUB（PHY控制单元）</strong>包含一个<strong>VT漂移补偿逻辑</strong>，该逻辑会根据电压和温度的变化自动调整每个延迟线的延迟选择输入，以保持稳定的时延。</li><li><strong>DATX8</strong>和<strong>AC</strong>模块中的所有<strong>DDL（Delay Line）</strong>都具有VT补偿功能。这些延迟线用于调整信号时序，使其符合正确的时间要求。</li></ul><h3 id="2-主延迟线（MDL）的作用"><a href="#2-主延迟线（MDL）的作用" class="headerlink" title="2. 主延迟线（MDL）的作用"></a>2. <strong>主延迟线（MDL）的作用</strong></h3><ul><li><strong>MDL（Master Delay Line，主延迟线）</strong>是一个重要的元件，负责测量DDR时钟周期的延迟，并根据电压和温度的变化进行动态调整。</li><li>在<strong>DATX8</strong>和<strong>AC</strong>组件中，MDL不断测量DDR时钟的周期，并根据电压和温度漂移的变化来更新延迟线的设置。</li><li>每个延迟线类型的更新都可以通过写入<strong>PGCR0寄存器</strong>来启用。</li></ul><h3 id="3-初始校准与周期测量"><a href="#3-初始校准与周期测量" class="headerlink" title="3. 初始校准与周期测量"></a>3. <strong>初始校准与周期测量</strong></h3><ul><li>在<strong>初始校准</strong>或<strong>数据训练</strong>触发后，MDL控制逻辑会存储<strong>初始MDL校准周期</strong>、<strong>前一个MDL校准周期</strong>和<strong>当前（新的）MDL校准周期</strong>。</li><li>校准后的MDL会定期进行周期测量，并记录每次新的MDL校准周期。</li><li>如果新的MDL校准周期与上一个周期不相等，且差异超过了由<strong>PGCR6.DLDLMT</strong>值指定的漂移阈值，则会触发VT漂移状态（通过<strong>vt_drift输出引脚</strong>来指示）。</li></ul><h3 id="4-延迟选择值的VT补偿"><a href="#4-延迟选择值的VT补偿" class="headerlink" title="4. 延迟选择值的VT补偿"></a>4. <strong>延迟选择值的VT补偿</strong></h3><ul><li><p>在检测到MDL周期变化时，VT补偿逻辑会根据以下公式计算VT补偿后的延迟线值：<br>$$<br>D L_{\text {new }}&#x3D;\frac{M D L_{\text {new }}}{M D L_{\text {init }}} \times D L_{\text {init }}<br>$$</p><ul><li><strong>MDLinit</strong>：初始MDL校准周期</li><li><strong>MDLnew</strong>：当前或新的MDL校准周期</li><li><strong>DLinit</strong>：在MDLinit时评估的初始延迟选择值</li><li><strong>DLnew</strong>：补偿后的延迟线值（即VT补偿值）</li></ul></li></ul><h3 id="5-VT更新"><a href="#5-VT更新" class="headerlink" title="5. VT更新"></a>5. <strong>VT更新</strong></h3><ul><li>当检测到MDL周期变化时，VT补偿逻辑会被触发，计算出一个VT补偿后的DDL值。</li><li>该计算后的值会存储在每个DDL的本地寄存器中，但不会立即应用到DDL上。只有当<strong>VT更新</strong>通过<strong>PUB</strong>服务时，补偿后的值才会被应用。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这段描述的核心内容是如何通过<strong>VT漂移补偿机制</strong>来保持DDR系统中延迟线（DDL）的时延稳定性。具体来说，当电压和温度变化时，主延迟线（MDL）会不断测量时钟周期，并根据这些变化调整各个延迟线的延迟选择值，确保信号时序稳定。每次检测到漂移并计算补偿后的延迟值时，VT补偿逻辑会自动进行调整，保证系统的可靠运行。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> VT compensation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR阻抗校准过程</title>
      <link href="/2024/11/09/DDR%E9%98%BB%E6%8A%97%E6%A0%A1%E5%87%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/11/09/DDR%E9%98%BB%E6%8A%97%E6%A0%A1%E5%87%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DDR接口中的阻抗校准过程，涉及如何通过控制逻辑、专用的单元和总线来实现对SSTL（Stub Series Terminated Logic）信号的阻抗调节。这个过程确保信号在传输过程中能维持正确的阻抗，以优化信号的质量和稳定性。<a><span id="more"></span></a></p></blockquote><p><img src="https://s2.loli.net/2024/11/09/eJG2RrbQ5IF1McU.png" alt="image-20241109184303118"></p><h3 id="关键组件和流程"><a href="#关键组件和流程" class="headerlink" title="关键组件和流程"></a>关键组件和流程</h3><h4 id="1-PZQ单元与PZCTRL单元的配合"><a href="#1-PZQ单元与PZCTRL单元的配合" class="headerlink" title="1. PZQ单元与PZCTRL单元的配合"></a>1. <strong>PZQ单元与PZCTRL单元的配合</strong></h4><ul><li>一个<strong>PZQ（Programmable Impedance）单元</strong>和一个<strong>PZCTRL单元</strong>可以用于一个或多个SSTL组，这些SSTL组需要独立的驱动阻抗和ODT（On-Die Termination，芯片内终端电阻）阻抗控制。</li><li>每个<strong>PZCTRL单元</strong>必须与一个<strong>PZQ单元</strong>配对使用，这两个单元的协作用于控制信号的阻抗。</li></ul><h4 id="2-PVSSQZB单元和ZIOH总线"><a href="#2-PVSSQZB单元和ZIOH总线" class="headerlink" title="2. PVSSQZB单元和ZIOH总线"></a>2. <strong>PVSSQZB单元和ZIOH总线</strong></h4><ul><li><strong>PVSSQZB单元</strong>用来创建一个独立的<strong>ZIOH总线段</strong>，专门用于阻抗校准。<strong>ZIOH总线</strong>是连接各个阻抗控制单元的总线，确保信号的正确传输。</li><li>在没有连接阻抗控制逻辑的接口段中，<strong>PVREF单元</strong>不能使用。这是为了避免信号干扰和不必要的电压参考误差。</li></ul><h4 id="3-阻抗校准触发与绕过"><a href="#3-阻抗校准触发与绕过" class="headerlink" title="3. 阻抗校准触发与绕过"></a>3. <strong>阻抗校准触发与绕过</strong></h4><ul><li>通过PIR寄存器的<strong>ZCALBYP位</strong>，可以随时绕过阻抗校准过程。</li><li>如果校准被绕过，那么阻抗需要在稍后的时间通过重新触发校准或直接编程控制寄存器<strong>ZQnDR</strong>来进行重新校准。</li></ul><h4 id="4-阻抗校准流程"><a href="#4-阻抗校准流程" class="headerlink" title="4. 阻抗校准流程"></a>4. <strong>阻抗校准流程</strong></h4><ul><li><p>一旦触发校准，阻抗校准逻辑会按照以下顺序依次校准四个阻抗元素：</p><ol><li><strong>输出阻抗拉低（pull-down）</strong></li><li><strong>输出阻抗拉高（pull-up）</strong></li><li><strong>ODT拉低（pull-down）</strong></li><li><strong>ODT拉高（pull-up）</strong></li></ol></li><li><p>对每个阻抗元素，阻抗控制逻辑会通过<strong>ZCTRL总线</strong>发送一个阻抗代码到<strong>PZCTRL单元</strong>，然后PZCTRL单元将这些数据进行编码并转换电平，传送到SSTL单元中的功能性I&#x2F;O单元和<strong>PZQ单元</strong>。</p></li></ul><h4 id="5-PZQ单元与外部电阻的匹配"><a href="#5-PZQ单元与外部电阻的匹配" class="headerlink" title="5. PZQ单元与外部电阻的匹配"></a>5. <strong>PZQ单元与外部电阻的匹配</strong></h4><ul><li><strong>PZQ单元</strong>接收到来自<strong>PZCTRL单元</strong>的控制代码，并与外部电阻进行比较，从而确定最佳的阻抗值。</li><li><strong>PZQ单元</strong>还接收到<strong>PUB</strong>（PHY控制器）的分频比（ZPROG），用于调整阻抗校准的精度。</li><li>当<strong>PZQ单元</strong>计算出阻抗匹配情况后，会将<strong>zcomp</strong>值反馈给阻抗控制逻辑，阻抗控制逻辑会根据反馈值更新控制代码，继续优化阻抗。</li></ul><h4 id="6-闭环控制"><a href="#6-闭环控制" class="headerlink" title="6. 闭环控制"></a>6. <strong>闭环控制</strong></h4><ul><li>阻抗控制过程是一个闭环控制系统。每次校准都会根据反馈信息调整阻抗代码，直到找到最匹配的阻抗值为止。</li><li>一旦一个阻抗元素的校准完成，逻辑会自动开始下一个阻抗元素的校准。</li></ul><h4 id="7-错误监控和完成状态"><a href="#7-错误监控和完成状态" class="headerlink" title="7. 错误监控和完成状态"></a>7. <strong>错误监控和完成状态</strong></h4><ul><li>在校准过程中，用户可以通过<strong>ZQnSR寄存器</strong>监控回路状态，检查是否有错误。</li><li>当所有四个阻抗元素的校准完成后，逻辑会在**PGSR[ZCDONE]**寄存器的**ZCDONE**位中标记“完成”状态，表示校准成功。</li></ul><h4 id="8-时钟控制"><a href="#8-时钟控制" class="headerlink" title="8. 时钟控制"></a>8. <strong>时钟控制</strong></h4><ul><li>校准逻辑使用<strong>PUB控制器时钟</strong>作为采样时钟来控制阻抗校准回路的操作。由于这个回路不需要高频操作，因此通常使用较低的时钟频率来保证稳定性。</li><li>该回路的频率比<strong>PUB时钟</strong>低得多，阻抗控制模块包含一个<strong>可编程时钟计数器</strong>，用于控制等待一定的时钟周期再进行采样。</li></ul><h4 id="9-背景运行与DFI更新"><a href="#9-背景运行与DFI更新" class="headerlink" title="9. 背景运行与DFI更新"></a>9. <strong>背景运行与DFI更新</strong></h4><ul><li>校准初始化完成后，阻抗校准会继续在后台运行，周期性地进行DFI控制和PHY更新，将更新后的VT（Voltage Threshold，电压阈值）代码传播到DDR接口上的I&#x2F;O单元。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这段描述的内容主要讲述了<strong>DDR接口阻抗校准的流程</strong>，以及如何通过一系列专用单元和总线实现对信号阻抗的精确调节。通过这个校准过程，信号的阻抗可以被精确地控制和优化，从而确保DDR接口能够稳定高效地工作。这个过程不仅考虑了不同工艺、电压和温度的变化，还确保了校准的反馈是闭环的，能够实时调整，最终达到最佳的阻抗匹配效果。</p><p><img src="https://s2.loli.net/2024/11/09/vdy18QaBkEmLHUY.png" alt="image-20241109184846343"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻抗控制模块（Impedance Controller Module）</title>
      <link href="/2024/11/09/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97%EF%BC%88Impedance%20Controller%20Module%EF%BC%89/"/>
      <url>/2024/11/09/%E9%98%BB%E6%8A%97%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97%EF%BC%88Impedance%20Controller%20Module%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>阻抗控制模块 提供了必要的阻抗控制功能，使得功能性的SSTL单元能够启用可编程且基于PVT（工艺、电压、温度）补偿的ODT和输出阻抗控制。<a><span id="more"></span></a></p></blockquote><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="1-Sample-based-tracking-of-RZQ："><a href="#1-Sample-based-tracking-of-RZQ：" class="headerlink" title="1. Sample-based tracking of RZQ："></a>1. <strong>Sample-based tracking of RZQ</strong>：</h4><ul><li><strong>RZQ</strong> 是指阻抗参考电阻值，通常与DDR总线的阻抗匹配有关。该功能表示通过采样来跟踪RZQ的变化，以保证SSTL接口的稳定信号传输，并使阻抗回路电路能够在较低功耗下稳定运行。</li></ul><h4 id="2-Impedance-code-override："><a href="#2-Impedance-code-override：" class="headerlink" title="2. Impedance code override："></a>2. <strong>Impedance code override</strong>：</h4><ul><li>该功能允许直接控制阻抗代码（Impedance Code）。这些阻抗代码是用来控制SSTL信号的驱动阻抗的，这项功能使得用户能够绕过自动控制，手动设置阻抗，从而有更多的灵活性和控制。</li></ul><h4 id="3-Impedance-code-output："><a href="#3-Impedance-code-output：" class="headerlink" title="3. Impedance code output："></a>3. <strong>Impedance code output</strong>：</h4><ul><li>通过输出阻抗代码，用户可以监控控制回路的操作情况。这意味着可以实时查看当前控制回路在调节阻抗时的状态，帮助调试和优化。</li></ul><h4 id="4-Programmable-divide-on-the-input-clock-signal："><a href="#4-Programmable-divide-on-the-input-clock-signal：" class="headerlink" title="4. Programmable divide on the input clock signal："></a>4. <strong>Programmable divide on the input clock signal</strong>：</h4><ul><li>这项功能提供了一个可编程的分频器，可以在输入时钟信号上进行分频。通过分频，可以实现稳定的操作，适应不同频率范围的输入时钟。这对于支持高频信号的稳定性非常重要。</li></ul><h4 id="5-Automatic-sequencing-for-independent-impedance-compensation："><a href="#5-Automatic-sequencing-for-independent-impedance-compensation：" class="headerlink" title="5. Automatic sequencing for independent impedance compensation："></a>5. <strong>Automatic sequencing for independent impedance compensation</strong>：</h4><ul><li>该功能会自动进行独立的阻抗补偿，针对四个不同的阻抗元素进行逐一补偿：<ul><li>ODT（On-Die Termination）拉高&#x2F;拉低电阻</li><li>输出阻抗拉高&#x2F;拉低</li></ul></li><li>这样可以确保每个阻抗元素在不同操作状态下都能得到最佳的匹配与补偿。</li></ul><h4 id="6-Programmable-asymmetric-drive-strength-and-pullup-only-termination-calibration："><a href="#6-Programmable-asymmetric-drive-strength-and-pullup-only-termination-calibration：" class="headerlink" title="6. Programmable asymmetric drive strength and pullup-only termination calibration："></a>6. <strong>Programmable asymmetric drive strength and pullup-only termination calibration</strong>：</h4><ul><li>支持可编程的不对称驱动强度调节和仅拉高终止校准。也就是说，用户可以对SSTL接口的驱动强度进行调节，以应对不同的负载需求。</li></ul><h4 id="7-VT-drift-detection-and-automatic-DFI-update-request："><a href="#7-VT-drift-detection-and-automatic-DFI-update-request：" class="headerlink" title="7. VT drift detection and automatic DFI update request："></a>7. <strong>VT drift detection and automatic DFI update request</strong>：</h4><ul><li><strong>VT drift</strong>（电压漂移）指的是随着温度、工艺变化，电压参考点可能发生的漂移。这项功能能够检测到电压漂移，并在发现漂移时，自动发出DFI（DDR接口）更新请求，以调整内存接口的配置，确保系统始终稳定运行。</li></ul><h4 id="8-Code-averaging-support-for-smoother-code-transitions："><a href="#8-Code-averaging-support-for-smoother-code-transitions：" class="headerlink" title="8. Code averaging support for smoother code transitions："></a>8. <strong>Code averaging support for smoother code transitions</strong>：</h4><ul><li>支持代码平均（Code Averaging），用来平滑阻抗代码的过渡。这意味着当阻抗代码变化时，变化的过程会更为平滑，从而避免因突变引起的信号不稳定。</li></ul><h4 id="9-Programmable-drive-strength-adjustment-for-pullup-drive-and-pulldown-drive-strengths："><a href="#9-Programmable-drive-strength-adjustment-for-pullup-drive-and-pulldown-drive-strengths：" class="headerlink" title="9. Programmable drive strength adjustment for pullup drive and pulldown drive strengths："></a>9. <strong>Programmable drive strength adjustment for pullup drive and pulldown drive strengths</strong>：</h4><ul><li>允许用户调节驱动强度，分别调整拉高和拉低的驱动强度。这使得在不同的工作条件下，SSTL接口能够适应各种负载，从而优化信号的完整性和稳定性。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这段描述的功能是为了确保DDR接口在不同的环境和工作条件下能够保持稳定和高效。阻抗校准的关键目标是减少信号反射、确保数据传输的可靠性，并在较低功耗下完成这一切。通过这些功能，SSTL接口能够应对各种复杂的工作条件，如不同的时钟频率、温度变化等，保证信号传输的质量。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Impedance Calibration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号反射</title>
      <link href="/2024/11/09/%E4%BF%A1%E5%8F%B7%E5%8F%8D%E5%B0%84/"/>
      <url>/2024/11/09/%E4%BF%A1%E5%8F%B7%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>信号反射是由于信号传输过程中遇到阻抗不匹配的情况，导致信号在传输线路上被部分或完全反射回源端的现象。信号反射可能导致信号质量下降，造成数据错误或通信中断。理解反射的原因，首先需要了解阻抗匹配的概念。<a><span id="more"></span></a></p></blockquote><h3 id="1-阻抗匹配的重要性"><a href="#1-阻抗匹配的重要性" class="headerlink" title="1. 阻抗匹配的重要性"></a>1. <strong>阻抗匹配的重要性</strong></h3><p>在信号传输过程中，信号需要沿着导线（比如电路板上的铜线或导线）传输。导线的特性阻抗（<strong>Zo</strong>）指的是信号沿导线传播时对电压和电流的响应。当信号从一个地方传播到另一个地方时，如果信号的源端、传输线和接收端的阻抗不匹配，就会发生反射。</p><h4 id="阻抗不匹配时的反射机制："><a href="#阻抗不匹配时的反射机制：" class="headerlink" title="阻抗不匹配时的反射机制："></a>阻抗不匹配时的反射机制：</h4><ul><li><strong>阻抗匹配</strong>：如果信号源的输出阻抗、传输线路的特性阻抗以及接收端的输入阻抗是相等的，那么信号会顺利地通过传输线路，几乎没有反射发生。</li><li><strong>阻抗不匹配</strong>：如果信号源的输出阻抗与传输线路的特性阻抗不同，或者传输线路的特性阻抗与接收端的输入阻抗不同，信号就会在接触到不匹配的阻抗时发生反射。</li></ul><h3 id="2-为什么会反射？"><a href="#2-为什么会反射？" class="headerlink" title="2. 为什么会反射？"></a>2. <strong>为什么会反射？</strong></h3><p>信号反射发生的原因是，信号遇到不同阻抗时会产生一种<strong>反射波</strong>，与原始信号方向相反。具体来说，信号遇到不匹配的阻抗时，会被部分地反射回去，同时另一部分会继续前进。</p><h4 id="反射的过程："><a href="#反射的过程：" class="headerlink" title="反射的过程："></a>反射的过程：</h4><ul><li>当信号通过传输线时，它的电流和电压会受到线路的特性阻抗影响。</li><li>如果传输线路的<strong>阻抗</strong>与信号源的<strong>输出阻抗</strong>或接收端的<strong>输入阻抗</strong>不同，信号的部分能量就会被反射回源端，产生反射信号。</li><li>反射波可能会干扰到原始信号，导致数据错误、时序问题或信号干扰。</li></ul><h3 id="3-反射会带来哪些问题？"><a href="#3-反射会带来哪些问题？" class="headerlink" title="3. 反射会带来哪些问题？"></a>3. <strong>反射会带来哪些问题？</strong></h3><ol><li><strong>信号失真</strong>：反射波与原始信号重叠，导致信号在接收端发生畸变，可能使信号变得模糊不清，从而产生错误的解码。</li><li><strong>时序问题</strong>：在高速信号传输中，反射可能导致信号的延迟，进而引发时序问题，特别是在同步电路中，导致数据丢失或错误。</li><li><strong>噪声增加</strong>：反射会在电路中引入不必要的噪声，影响电路的正常工作。</li></ol><h3 id="4-信号反射的常见原因"><a href="#4-信号反射的常见原因" class="headerlink" title="4. 信号反射的常见原因"></a>4. <strong>信号反射的常见原因</strong></h3><ul><li><strong>传输线的阻抗不匹配</strong>：如果电路板的走线设计不合理，传输线的阻抗与信号源或接收端的阻抗不匹配，就会发生反射。</li><li><strong>接头和连接器</strong>：在信号传输过程中，连接器或插座的接触不良、插头不正确或松动，都会导致阻抗不匹配，进而产生反射。</li><li><strong>不连续的线路</strong>：例如，信号线弯曲得太急或有不规则的变化，这些都可能导致局部的阻抗变化，进而产生反射。</li><li><strong>终端未连接或连接不当</strong>：如果传输线路没有正确的终端（即阻抗匹配），或者终端与线路的阻抗不匹配，也会导致反射。</li></ul><h3 id="5-如何避免信号反射？"><a href="#5-如何避免信号反射？" class="headerlink" title="5. 如何避免信号反射？"></a>5. <strong>如何避免信号反射？</strong></h3><ul><li><strong>阻抗匹配</strong>：最有效的方法是确保信号源、传输线路和接收端之间的阻抗是匹配的。这可以通过设计电路时选择合适的导线宽度、材料和布局来实现。</li><li><strong>使用终端电阻（ODT）</strong>：在信号传输线路的末端加入适当的电阻，确保终端阻抗与线路阻抗匹配。内存接口、SSTL标准和DDR接口常使用<strong>ODT</strong>（On-Die Termination）来实现阻抗匹配。</li><li><strong>避免信号线的急转弯</strong>：设计时避免信号线的急剧弯曲，保持较为平缓的线路走向，减少阻抗不连续的可能性。</li><li><strong>使用阻抗匹配的连接器</strong>：确保使用合适的连接器或插头，避免因连接不当而产生阻抗不匹配。</li></ul><h3 id="6-阻抗匹配的应用："><a href="#6-阻抗匹配的应用：" class="headerlink" title="6. 阻抗匹配的应用："></a>6. <strong>阻抗匹配的应用：</strong></h3><ul><li><strong>内存接口</strong>：如DDR内存中，阻抗匹配是确保信号稳定传输的关键，通常采用ODT（On-Die Termination）技术来实现。</li><li><strong>高速信号传输</strong>：例如，在PCIe、USB、HDMI等高速通信协议中，信号传输的阻抗匹配至关重要，反射会极大地影响数据传输速率和可靠性。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>信号反射的根本原因是阻抗不匹配，导致信号在传输过程中部分反射回源端。为了避免反射，必须确保信号源、传输线和接收端的阻抗匹配，设计时注意电路走线、使用合适的终端电阻等。通过这些方法，可以确保信号的完整性，提高系统的性能和可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ODT</title>
      <link href="/2024/11/09/ODT/"/>
      <url>/2024/11/09/ODT/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ODT（On-Die Termination） 是一种在半导体芯片（尤其是内存芯片，如DDR SDRAM）中用于信号完整性和减少反射的技术。它的作用是提供一种终端电阻，通常通过内置的电阻网络实现，用来匹配信号线路的阻抗，确保信号的稳定传输。<span id="more"></span></p></blockquote><h2 id="ODT的工作原理"><a href="#ODT的工作原理" class="headerlink" title="ODT的工作原理"></a><a>ODT的工作原理</a></h2><h4 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. <strong>目的</strong></h4><ul><li>在高速信号传输中，尤其是大规模集成电路（如内存）中，信号在传输过程中可能会发生反射，这种反射会导致信号质量下降。ODT技术通过在信号线路终端提供一个匹配的阻抗，消除或减少信号反射，从而提高信号的完整性和系统的稳定性。</li></ul><h4 id="2-如何工作"><a href="#2-如何工作" class="headerlink" title="2. 如何工作"></a>2. <strong>如何工作</strong></h4><ul><li>ODT通过将终端电阻放置在芯片的I&#x2F;O端口（如内存芯片的DQS、DQ等数据线）上，以减少信号的反射。</li><li>ODT电阻通常会根据内存控制器的需求动态调节。例如，在数据传输期间，内存控制器可以启用ODT以进行有效的信号匹配，而在没有数据传输时，ODT可以被禁用以节省功耗。</li></ul><h4 id="3-ODT的类型："><a href="#3-ODT的类型：" class="headerlink" title="3. ODT的类型："></a>3. <strong>ODT的类型</strong>：</h4><ul><li><p>拉高（Pull-up）和拉低（Pull-down）终端：ODT可以通过两种方式进行配置：</p><ul><li><strong>拉高（Pull-up）</strong>：将信号线连接到VDD（电源电压）以增强信号的上升沿。</li><li><strong>拉低（Pull-down）</strong>：将信号线连接到地（GND）以增强信号的下降沿。</li></ul></li><li><p><strong>动态可编程ODT</strong>：在一些现代内存系统中，ODT的电阻值是可以动态调整的（例如根据工作频率、温度或其他条件），这种灵活性帮助系统在不同工作条件下优化信号传输。</p></li></ul><h4 id="4-优势："><a href="#4-优势：" class="headerlink" title="4. 优势："></a>4. <strong>优势</strong>：</h4><ul><li><strong>信号完整性</strong>：ODT能够减少信号反射和串扰，从而确保数据传输的准确性。</li><li><strong>功耗优化</strong>：通过在不需要的时候关闭ODT，可以减少功耗。</li><li><strong>高速操作</strong>：在高速DDR内存和其他高速I&#x2F;O接口中，ODT帮助信号在较高的频率下保持稳定。</li></ul><h4 id="5-常见应用："><a href="#5-常见应用：" class="headerlink" title="5. 常见应用："></a>5. <strong>常见应用</strong>：</h4><ul><li><strong>内存控制器</strong>：在DDR、LPDDR等内存标准中，ODT广泛应用于内存的读写过程中。</li><li><strong>高速数据总线</strong>：如SSTL、HSTL等标准，在高速数据传输中也会使用ODT技术。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h2><p>ODT技术是现代电子系统中用于提高信号质量、减少反射和优化功耗的重要技术。它通过在芯片内部集成电阻来终止信号线，从而实现信号的阻抗匹配，广泛应用于内存接口和其他高速I&#x2F;O接口中。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRAM Command Unit(DCU)</title>
      <link href="/2024/11/06/DRAM%20Command%20Unit(DCU)/"/>
      <url>/2024/11/06/DRAM%20Command%20Unit(DCU)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DRAM Command Unit (DCU) 是一个执行内存命令的模块，主要用于通过配置端口发出和控制 DRAM（动态随机存取存储器）命令以及 RDIMM（注册式双列直插内存模块）缓冲芯片的命令。它在 DRAM 系统中的作用是确保内存的初始化、调试和控制能够独立于内存控制器进行操作，提供灵活性和可调试性。<span id="more"></span></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a>简介</a></h2><h3 id="1-允许通过配置端口执行-DRAM-初始化"><a href="#1-允许通过配置端口执行-DRAM-初始化" class="headerlink" title="1. 允许通过配置端口执行 DRAM 初始化"></a>1. <strong>允许通过配置端口执行 DRAM 初始化</strong></h3><ul><li><strong>DRAM 初始化</strong> 是指在内存模块首次启用或复位时，需要进行的一系列操作，以确保内存正常工作。通常包括设置内存时序、刷新模式、存取模式等参数。</li><li><strong>配置端口</strong> 提供了一种通过软件来控制 DRAM 初始化过程的方法，而不需要依赖复杂的硬件控制逻辑。这意味着，用户可以通过编程接口向 DRAM 发出命令，从而实现初始化操作。这种方法使得内存初始化过程可以更加灵活和可控。</li><li>举个例子，执行 DRAM 初始化时，可能需要向内存发送预充电、行激活、读取、写入等命令，通过配置端口，开发人员可以精确控制这些命令的发送顺序和时序，确保内存的可靠性。</li></ul><h3 id="2-提供独立于控制器的统一硅调试和表征功能"><a href="#2-提供独立于控制器的统一硅调试和表征功能" class="headerlink" title="2. 提供独立于控制器的统一硅调试和表征功能"></a>2. <strong>提供独立于控制器的统一硅调试和表征功能</strong></h3><ul><li><strong>硅调试</strong> 和 <strong>表征</strong> 是指在开发过程中通过硬件和软件的协同工作来验证和测试芯片（尤其是内存子系统）的性能、时序、功耗等特性。</li><li>DCU 允许开发人员通过软件接口直接向 DRAM 发送命令进行调试，而不依赖于内存控制器（如内存控制器的硬件实现）。这样，即使没有完整的内存控制器，调试人员仍然可以独立地对内存进行测试和验证。</li><li>例如，可以使用 DCU 单元发送特定的命令流来验证 DRAM 在各种工作负载下的性能，或者进行精确的时序分析，确保内存与控制器之间的信号传输没有问题。</li></ul><h3 id="3-提供-DRAM-命令的通用软件执行机制"><a href="#3-提供-DRAM-命令的通用软件执行机制" class="headerlink" title="3. 提供 DRAM 命令的通用软件执行机制"></a>3. <strong>提供 DRAM 命令的通用软件执行机制</strong></h3><ul><li>DCU 不仅仅是一个硬件单元，它还支持通过软件来执行一系列 DRAM 命令。这使得开发人员能够通过编程方式控制内存的各个方面。</li><li>例如，软件可以通过 DCU 向 DRAM 发出常见的命令，如 <strong>读取</strong>（READ）、<strong>写入</strong>（WRITE）、<strong>预充电</strong>（PRECHARGE）、<strong>行激活</strong>（ACTIVATE）等。这样，开发人员可以在不同的工作模式下测试内存，验证功能是否正常。</li><li>这种通用软件执行的机制使得软件开发人员能够灵活地模拟和控制内存行为，方便进行不同的测试和操作。</li></ul><p><img src="https://s2.loli.net/2024/11/06/Qmv5cFEN6lDIjGn.png" alt="image-20241106235450107"></p><p><img src="https://s2.loli.net/2024/11/06/KPkgvjCd9mGOTEH.png" alt="image-20241106235724242"></p><h3 id="1-读取状态块-Read-Status-Block"><a href="#1-读取状态块-Read-Status-Block" class="headerlink" title="1. 读取状态块 (Read Status Block)"></a>1. <strong>读取状态块 (Read Status Block)</strong></h3><p>读取状态块是一个用于管理和跟踪内存读取操作状态的模块。它通常存储与读取操作相关的信息，例如读取请求是否完成、是否发生了错误等。在这个上下文中，读取状态块内有两个重要的缓存（期望缓存和读取缓存），它们共同工作来验证读取的数据是否符合预期。</p><h3 id="2-期望缓存-Expected-Cache"><a href="#2-期望缓存-Expected-Cache" class="headerlink" title="2. 期望缓存 (Expected Cache)"></a>2. <strong>期望缓存 (Expected Cache)</strong></h3><p>期望缓存用于存储系统预期从内存中读取的数据。当系统发起读取操作时，通常会预设一个预期值，并将其存入期望缓存中。然后，读取的数据将与这个期望值进行比较，用以验证读取的正确性。如果读取的数据与预期数据不符，则可能表明出现了错误或数据不一致。</p><h3 id="3-读取缓存-Read-Cache"><a href="#3-读取缓存-Read-Cache" class="headerlink" title="3. 读取缓存 (Read Cache)"></a>3. <strong>读取缓存 (Read Cache)</strong></h3><p>读取缓存存储实际从内存中读取的数据。它充当了内存与其他系统组件之间的缓冲区，用于缓存刚刚从内存中读取的数据。读取缓存中的数据会与期望缓存中的数据进行比较，从而确认数据是否符合预期。</p><h3 id="4-读取比较逻辑-Read-Compare-Logic"><a href="#4-读取比较逻辑-Read-Compare-Logic" class="headerlink" title="4. 读取比较逻辑 (Read Compare Logic)"></a>4. <strong>读取比较逻辑 (Read Compare Logic)</strong></h3><p>读取比较逻辑的作用是将读取缓存中的数据与期望缓存中的数据进行比较。这一步是确保数据一致性和正确性的重要环节。如果读取到的数据和期望的数据不匹配，系统可以根据需要触发错误或执行某些修复措施。这对于数据完整性检测和故障诊断至关重要。</p><h3 id="5-PUB引擎-PUB-Engines"><a href="#5-PUB引擎-PUB-Engines" class="headerlink" title="5. PUB引擎 (PUB Engines)"></a>5. <strong>PUB引擎 (PUB Engines)</strong></h3><p>PUB 引擎是系统中负责处理特定任务的模块或单元。文中提到，这些引擎与读取状态块共享期望缓存和读取缓存。也就是说，多个不同的处理单元或模块都可以访问这些缓存和比较逻辑，这样可以实现对内存读取的集中管理和处理。</p><h3 id="6-DCU寄存器-DCU-Registers"><a href="#6-DCU寄存器-DCU-Registers" class="headerlink" title="6. DCU寄存器 (DCU Registers)"></a>6. <strong>DCU寄存器 (DCU Registers)</strong></h3><p><strong>DCU</strong>（DRAM命令单元）是与内存控制器进行交互的模块，它负责发出命令、控制内存操作等。DCU寄存器是访问期望缓存和读取缓存的接口。换句话说，期望缓存和读取缓存的内容是通过DCU寄存器来读写的。开发人员或硬件组件可以通过操作这些寄存器来控制缓存中的数据或获取所需的信息。</p><h3 id="7-写入或读取DCU缓存-Writing-or-Reading-DCU-Caches"><a href="#7-写入或读取DCU缓存-Writing-or-Reading-DCU-Caches" class="headerlink" title="7. 写入或读取DCU缓存 (Writing or Reading DCU Caches)"></a>7. <strong>写入或读取DCU缓存 (Writing or Reading DCU Caches)</strong></h3><p>这部分描述了如何通过DCU寄存器来访问期望缓存和读取缓存。系统可以通过向这些寄存器写入数据来加载期望的值，或通过读取寄存器来获取实际读取的数据。通过这种方式，DCU为内存操作提供了灵活的控制接口，开发人员可以通过它来执行各种内存读取验证操作。</p><hr><h2 id="DCU命令（DCU-Commands）"><a href="#DCU命令（DCU-Commands）" class="headerlink" title="DCU命令（DCU Commands）"></a><a><strong>DCU命令（DCU Commands）</strong></a></h2><p><strong>DCU</strong>（DRAM命令单元）允许用户通过配置端口、APB（外设总线）或JTAG接口发出SDRAM命令。这个部分描述了如何编程DCU来执行SDRAM命令以及相关的时序要求。</p><h4 id="1-通过DCU执行SDRAM命令"><a href="#1-通过DCU执行SDRAM命令" class="headerlink" title="1. 通过DCU执行SDRAM命令"></a>1. <strong>通过DCU执行SDRAM命令</strong></h4><ul><li>DCU能够支持执行各种SDRAM命令，具体命令可以在文档的“PUB Commands”部分（第471页）找到。SDRAM命令是内存控制器与SDRAM之间通信的基本单元，例如读写操作、激活（Activate）、预充电（Precharge）等。</li><li>用户通过编程DCU来设置这些命令，并将其发送到SDRAM。这意味着通过DCU，用户可以控制SDRAM的操作，而无需直接控制硬件级别的细节。</li></ul><h4 id="2-时序要求"><a href="#2-时序要求" class="headerlink" title="2. 时序要求"></a>2. <strong>时序要求</strong></h4><ul><li><strong>时序控制</strong>：当用户编程DCU并发出命令时，DCU并不会自动处理这些命令的时序。也就是说，DCU只是将命令发送到SDRAM，但不会自动根据命令的执行顺序和时序要求来调整操作。</li><li><strong>NOP命令</strong>：在SDRAM命令序列中，NOP（No Operation，无操作）命令常用于填充时序空隙或者确保系统的时序满足要求。如果DCU在执行命令时存在时间间隔，需要通过插入适当数量的NOP命令来填补这些空白。</li><li><strong>时序特性</strong>：为了确保命令按预期执行，用户可以使用DCU的一些<strong>时序功能</strong>来调整命令之间的间隔，确保满足设备的时序要求。设备的时序要求包括每个命令的最小间隔时间，以及不同命令之间的依赖关系（例如，读取命令与激活命令之间的时序关系）。</li></ul><h4 id="3-激活（Activate）和预充电（Precharge）命令"><a href="#3-激活（Activate）和预充电（Precharge）命令" class="headerlink" title="3. 激活（Activate）和预充电（Precharge）命令"></a>3. <strong>激活（Activate）和预充电（Precharge）命令</strong></h4><ul><li><strong>激活命令（Activate Command）</strong>：用于打开SDRAM的一个特定的行。只有在激活命令之后，SDRAM的特定行才能被访问。</li><li><strong>预充电命令（Precharge Command）</strong>：用于关闭SDRAM的一个行，为新的读取或写入操作腾出空间。预充电命令通常在进行写入操作之前发出，以确保行被正确关闭。</li><li><strong>手动控制</strong>：DCU不会自动生成激活命令或预充电命令。这意味着在执行读取或写入命令之前，用户需要手动发出激活命令来打开正确的行，并在操作结束后发出预充电命令以关闭该行。</li></ul><h4 id="4-操作顺序和依赖关系"><a href="#4-操作顺序和依赖关系" class="headerlink" title="4. 操作顺序和依赖关系"></a>4. <strong>操作顺序和依赖关系</strong></h4><ul><li>在执行SDRAM命令时，命令之间有严格的顺序和依赖关系。例如，在发出读写命令之前，必须确保相应的SDRAM银行（bank）已被激活（Activate），并且在结束写入操作后需要发出预充电（Precharge）命令。</li><li>用户必须根据SDRAM的时序规范来手动安排这些命令的顺序。如果命令顺序不正确，可能导致读取或写入错误，甚至是内存损坏。</li></ul><hr><h2 id="DCU缓存（DCU-Caches）-的详细解释："><a href="#DCU缓存（DCU-Caches）-的详细解释：" class="headerlink" title="DCU缓存（DCU Caches） 的详细解释："></a><a><strong>DCU缓存（DCU Caches）</strong> 的详细解释：</a></h2><p>DCU（DRAM命令单元）有三个主要缓存，用于提高操作效率和数据访问的灵活性。下面对这三个缓存进行详细解释：</p><h3 id="1-命令缓存（Command-Cache）"><a href="#1-命令缓存（Command-Cache）" class="headerlink" title="1. 命令缓存（Command Cache）"></a>1. <strong>命令缓存（Command Cache）</strong></h3><ul><li><strong>深度</strong>：16深度（16 entries）。</li><li><strong>功能</strong>：命令缓存用于存储待执行的DRAM命令。这些命令由调度器（scheduler）执行。命令缓存是一个队列，按顺序存储和调度将要发送到DRAM的命令。通过使用命令缓存，系统可以按顺序缓冲多个命令，提高执行效率。</li><li><strong>内容</strong>：缓存中的每个条目不仅包括DRAM命令，还包含调度器所需的所有字段。特别地，每个条目还包含一个3位的RPT字段（Repeat Field），用于指示命令是否需要重复执行。RPT字段允许命令被执行多次。</li></ul><h3 id="2-读取数据缓存（Read-Data-Cache）"><a href="#2-读取数据缓存（Read-Data-Cache）" class="headerlink" title="2. 读取数据缓存（Read Data Cache）"></a>2. <strong>读取数据缓存（Read Data Cache）</strong></h3><ul><li><strong>深度</strong>：4深度（4 entries）。</li><li><strong>别名</strong>：也叫做<strong>捕获缓存（Capture Cache）</strong>。</li><li><strong>功能</strong>：读取数据缓存用于捕获从DRAM读取的数据。它存储从DRAM读取的一个字节的数据。这是为了快速捕捉和暂存读取的数据，在后续的操作中可以直接从缓存中获取，而不必每次都去访问DRAM。</li><li><strong>应用</strong>：该缓存是一个非常小的缓存，它通过缓存最常用的数据，减少了访问DRAM的次数，从而提高了数据读取的效率。</li></ul><h3 id="3-期望数据缓存（Expected-Data-Cache）"><a href="#3-期望数据缓存（Expected-Data-Cache）" class="headerlink" title="3. 期望数据缓存（Expected Data Cache）"></a>3. <strong>期望数据缓存（Expected Data Cache）</strong></h3><ul><li><strong>深度</strong>：16深度（16 entries）。</li><li><strong>功能</strong>：期望数据缓存用于存储预期与读取数据进行比较的数据。通过将读取数据与期望数据进行比对，系统能够判断数据是否正确或是否存在错误。该缓存是数据验证的一部分。</li><li><strong>内容</strong>：缓存中的每个条目都包含一个5位的数据码，共80个寄存器。为了提高配置端口的访问速度，期望数据缓存是作为一个1深度、80位宽的缓存来定义的，这样只需要3次寄存器写入（而如果定义为16深度5位的缓存，则需要16次写入）。这个设计减少了配置数据写入的次数，从而提高了数据加载的效率。</li></ul><h3 id="4-缓存结构和访问"><a href="#4-缓存结构和访问" class="headerlink" title="4. 缓存结构和访问"></a>4. <strong>缓存结构和访问</strong></h3><ul><li>每个缓存行都有一个与之对应的地址，用于标识缓存中的具体条目。例如，命令缓存有16行，因此缓存行的地址范围是0到15。</li><li>每个缓存行会被划分为若干个<strong>32位片段（slice）</strong>，其中第0片段是缓存行中的最低有效字（least significant word）。每行的片段数量取决于设计中存在的字节通道数（byte lanes）和缓存类型。</li><li>例如，<strong>读取数据缓存</strong>和<strong>期望数据缓存</strong>仅存储数据，不包含命令信息，而<strong>命令缓存</strong>除了包含命令字段外，还包括调度器需要的其他字段。</li></ul><h3 id="5-命令缓存条目的结构"><a href="#5-命令缓存条目的结构" class="headerlink" title="5. 命令缓存条目的结构"></a>5. <strong>命令缓存条目的结构</strong></h3><ul><li><strong>命令缓存</strong>的每个条目包括多个字段，这些字段由调度器使用。命令字段的格式类似于系统中其他内部引擎所使用的格式。这些字段包括命令类型、地址、数据和控制信号。</li><li>需要注意的是，<strong>命令缓存行的宽度不一定需要是32位的倍数</strong>。如果不是，最重要的字段（即最高有效字）应该通过填充0来确保它成为一个完整的32位字，以便进行写入操作。</li></ul><h3 id="6-访问方式"><a href="#6-访问方式" class="headerlink" title="6. 访问方式"></a>6. <strong>访问方式</strong></h3><ul><li>用户可以通过<strong>DCU地址寄存器（DCUAR）</strong>和<strong>DCU数据寄存器（DCUDR）</strong>来读写这些缓存。DCU地址寄存器用于选择缓存的条目（例如，选择命令缓存的某一行），而数据寄存器则用于存取该条目的数据。</li><li>在配置端口上，数据的写入或读取操作是通过寄存器来完成的，每个条目的数据通过这些寄存器进行传输。</li></ul><h3 id="7-缓存行格式"><a href="#7-缓存行格式" class="headerlink" title="7. 缓存行格式"></a>7. <strong>缓存行格式</strong></h3><ul><li>每个缓存行的格式对于正确编程和使用DCU命令缓存至关重要。特别是，编程DCU命令缓存时，必须正确设置每个字段的宽度，以确保数据能够按预期方式存储和访问。</li></ul><h3 id="8-BIST和训练功能的使用"><a href="#8-BIST和训练功能的使用" class="headerlink" title="8. BIST和训练功能的使用"></a>8. <strong>BIST和训练功能的使用</strong></h3><ul><li>读取数据缓存和期望数据缓存不仅仅用于标准的DRAM命令执行，它们还被其他PUB内部引擎（如<strong>BIST</strong>或<strong>训练功能</strong>）所使用。BIST（内建自测试，Built-In Self Test）和训练功能通常用于自检或优化SDRAM的性能。</li></ul><p><img src="https://s2.loli.net/2024/11/07/dum25cyYqCeDQjl.png" alt="image-20241107000127665"></p><hr><h2 id="写入或读取DCU缓存（Writing-or-Reading-DCU-Caches）-的详细解释："><a href="#写入或读取DCU缓存（Writing-or-Reading-DCU-Caches）-的详细解释：" class="headerlink" title="写入或读取DCU缓存（Writing or Reading DCU Caches） 的详细解释："></a><a><strong>写入或读取DCU缓存（Writing or Reading DCU Caches）</strong> 的详细解释：</a></h2><p>写入和读取DCU缓存（命令缓存、读取数据缓存、期望数据缓存）有两种方法。下面详细解释了这两种方法。</p><h3 id="1-手动写入或读取"><a href="#1-手动写入或读取" class="headerlink" title="1. 手动写入或读取"></a>1. <strong>手动写入或读取</strong></h3><ul><li>步骤<ul><li><strong>写入</strong>：要写入数据，首先需要将<strong>行地址（row address）**和**切片地址（slice address）**写入到**DCU地址寄存器（DCUAR）<strong>。接着，将32位的数据写入</strong>DCU数据寄存器（DCUDR）</strong>。这个过程需要手动控制行地址和切片地址的变化，确保每次都写入正确的地址位置。</li><li><strong>读取</strong>：与写入类似，读取数据时也需要首先设置正确的行地址和切片地址，然后读取相应的数据。</li></ul></li></ul><p>这种方法虽然可以精确控制缓存的读写，但也可能比较繁琐，因为每次都需要手动更新地址寄存器，逐步填写每个缓存行的内容。</p><h3 id="2-自动地址递增机制"><a href="#2-自动地址递增机制" class="headerlink" title="2. 自动地址递增机制"></a>2. <strong>自动地址递增机制</strong></h3><p>为了简化写入和读取过程，PUB实现了一种<strong>自动地址递增机制</strong>，该机制通过设置<strong>DCUAR寄存器中的INCA字段</strong>来启用。这种方式简化了手动控制的步骤，减少了错误和混乱的可能性。</p><ul><li><p>如何工作</p><p>：</p><ul><li><strong>启用自动递增</strong>：通过在<strong>DCUAR寄存器</strong>中设置<strong>INCA字段</strong>，用户只需要指定<strong>起始行地址</strong>和<strong>起始切片地址</strong>，而不需要逐个更新地址。</li><li><strong>自动递增</strong>：每次将32位数据写入<strong>DCUDR寄存器</strong>时，切片地址（slice address）会自动递增，直到当前缓存行被填满。当当前缓存行被填满时，切片地址会重置为0，并且行地址会自动递增，跳转到下一个缓存行。</li><li><strong>简化操作</strong>：用户只需要进行一次起始地址和切片地址的设置，之后的所有操作会自动进行地址递增，极大简化了缓存操作，减少了手动控制的复杂性。</li></ul></li></ul><h3 id="3-自动地址递增的优点"><a href="#3-自动地址递增的优点" class="headerlink" title="3. 自动地址递增的优点"></a>3. <strong>自动地址递增的优点</strong></h3><ul><li><strong>减少复杂性</strong>：启用自动递增后，用户不需要每次都手动更新地址和切片地址，系统会自动处理这些步骤。这样可以减少配置错误和不必要的操作。</li><li><strong>提高效率</strong>：自动递增机制加快了数据写入的速度，因为它减少了对寄存器的频繁写入，并且在写入时，缓存行地址和切片地址的更新都是自动完成的。</li><li><strong>更少的错误</strong>：由于不需要手动跟踪和更新每个地址，减少了出错的可能性，尤其是在需要处理大批量数据时。</li></ul><hr><h2 id="DCU命令缓存写入示例（DCU-Command-Cache-Write-Example）-的详细解释："><a href="#DCU命令缓存写入示例（DCU-Command-Cache-Write-Example）-的详细解释：" class="headerlink" title="DCU命令缓存写入示例（DCU Command Cache Write Example） 的详细解释："></a><a><strong>DCU命令缓存写入示例（DCU Command Cache Write Example）</strong> 的详细解释：</a></h2><p>此部分展示了如何使用<strong>地址&#x2F;切片模式（address&#x2F;slice mode）</strong>来写入DCU命令缓存（command cache）。此模式用于将一个46位宽的命令字写入缓存。这是典型的用于支持LPDDRn系统的系统，其中使用了20位地址，并支持最多4个rank（内存通道）。</p><h4 id="1-背景说明"><a href="#1-背景说明" class="headerlink" title="1. 背景说明"></a>1. <strong>背景说明</strong></h4><ul><li><strong>命令字宽度</strong>：每个命令字为46位。为了在命令缓存中写入此类数据，每一行将被拆分成两个32位的字（也就是两个切片），因此一个缓存行会由两个32位的字组成，其中第二个32位的字只有前14位有效（因为总宽度是46位）。</li><li><strong>命令缓存行数</strong>：命令缓存的每一行有两个32位的切片，其中每个切片（32位）存储命令字的一个部分。第二个切片中的数据只有前14位有效，后18位将被忽略。</li></ul><h4 id="2-写入过程"><a href="#2-写入过程" class="headerlink" title="2. 写入过程"></a>2. <strong>写入过程</strong></h4><p>要在此模式下写入命令缓存，必须按如下步骤通过配置端口（或者APB或JTAG）向寄存器写入数据：</p><p><strong>步骤 1：写入DCU地址寄存器（<code>DCUAR</code>）</strong></p><ul><li>将以下字段写入<code>DCUAR</code>寄存器，设置用于命令缓存的地址和切片信息：<ul><li><strong>CSEL &#x3D; 2’b00</strong>：选择命令缓存（Command Cache）。</li><li><strong>INCA &#x3D; 0</strong>：禁用地址递增（即每次写入时，地址不会自动递增，需要手动递增切片地址）。</li><li><strong>ATYPE &#x3D; 0</strong>：写入访问（Write Access）。</li><li><strong>CWADDR &#x3D; 0</strong>：选择缓存行地址为0。</li><li><strong>CSADDR &#x3D; 0</strong>：选择缓存切片为0（即写入第一部分的32位数据）。</li></ul></li></ul><p><strong>步骤 2：写入32位数据到DCU数据寄存器（<code>DCUDR</code>）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表命令字的第0到31位（即命令字的低32位）。这是缓存行的第一部分数据。</li></ul><p><strong>步骤 3：更新DCU地址寄存器（<code>DCUAR</code>）以选择切片1</strong></p><ul><li>在<code>DCUAR</code>寄存器中再次写入（保持之前的设置，更新切片地址）：<ul><li><strong>CWADDR &#x3D; 0</strong>：行地址保持为0。</li><li><strong>CSADDR &#x3D; 1</strong>：选择缓存的第二个切片（即写入命令字的第32到45位）。</li></ul></li></ul><p><strong>步骤 4：写入32位数据到DCU数据寄存器（DCUDR）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表命令字的第32到45位（即命令字的高14位）。请注意，命令字的第14到31位会被忽略，只写入有效的高14位数据。</li></ul><p><strong>步骤 5：重复上述步骤</strong></p><ul><li>对于每个命令缓存行（从行地址0开始），重复步骤1到步骤4，直到所有命令缓存行都写入数据。每次操作时，更新<strong>CWADDR（行地址）</strong>，使其递增，直到所有缓存行完成写入。</li></ul><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. <strong>注意事项</strong></h4><ul><li><strong>起始和结束地址</strong>：命令缓存的写入不一定需要从行地址<strong>CWADDR &#x3D; 0</strong>开始。你可以通过<strong>DCU运行寄存器（DCURR）</strong>指定任何起始和结束地址。但是，结束地址必须大于起始地址，因为执行会在命令缓存的最后一行结束，而不会环绕到缓存的开头。</li><li><strong>命令缓存的执行顺序</strong>：即使你指定了不同的起始和结束行地址，命令缓存的执行仍会按顺序从起始行执行到结束行，不会回绕到缓存的开头。</li></ul><hr><h2 id="DCU期望数据缓存写入示例（DCU-Expected-Cache-Write-Example）-的详细解释："><a href="#DCU期望数据缓存写入示例（DCU-Expected-Cache-Write-Example）-的详细解释：" class="headerlink" title="DCU期望数据缓存写入示例（DCU Expected Cache Write Example） 的详细解释："></a><a><strong>DCU期望数据缓存写入示例（DCU Expected Cache Write Example）</strong> 的详细解释：</a></h2><p>该示例展示了如何使用<strong>自动地址递增模式（automatic address incrementing mode）</strong>来写入DCU的期望数据缓存（expected data cache）。为了加速从配置端口的访问，期望数据缓存被定义为1深度、80位宽的缓存，这使得只需要<strong>3次寄存器写入</strong>即可加载数据，而如果该缓存被定义为**16深度、5位宽，则需要16次写入。</p><h4 id="1-背景说明-1"><a href="#1-背景说明-1" class="headerlink" title="1. 背景说明"></a>1. <strong>背景说明</strong></h4><ul><li><strong>缓存行宽度</strong>：期望数据缓存的行宽为80位。为了适应这个宽度，每行会被分成三个32位切片（即3个切片）。其中，第三个32位切片中只有前16位有效，因为总行宽只有80位，剩余的16位会被忽略。</li><li><strong>缓存的格式</strong>：期望数据缓存的每一行包含3个32位数据字（切片），每个数据字的位宽分别为[31:0]、[63:32]和[79:64]。</li></ul><h4 id="2-写入过程-1"><a href="#2-写入过程-1" class="headerlink" title="2. 写入过程"></a>2. <strong>写入过程</strong></h4><p>要在期望数据缓存中写入数据，并启用自动地址递增模式，需要按照以下步骤通过配置端口（或APB或JTAG）向寄存器写入数据：</p><p><strong>步骤 1：写入DCU地址寄存器（<code>DCUAR</code>）</strong></p><ul><li>将以下字段写入<code>DCUAR</code>寄存器，设置用于期望数据缓存的地址和切片信息：<ul><li><strong>CSEL &#x3D; 2’b01</strong>：选择期望数据缓存（Expected Data Cache）。</li><li><strong>INCA &#x3D; 1</strong>：启用地址递增（即每次写入时，地址会自动递增）。</li><li><strong>ATYPE &#x3D; 0</strong>：写入访问（Write Access）。</li><li><strong>CWADDR &#x3D; 0</strong>：选择缓存行地址为0（行地址为0）。</li><li><strong>CSADDR &#x3D; 0</strong>：选择缓存切片为0（即写入第一部分的32位数据）。</li></ul></li></ul><p><strong>步骤 2：写入32位数据到DCU数据寄存器（<code>DCUDR</code>）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表期望数据缓存的第0到31位（即命令字的低32位）。这是缓存行的第一部分数据。</li></ul><p><strong>步骤 3：更新DCU地址寄存器（<code>DCUAR</code>）以选择切片1</strong></p><ul><li>在<code>DCUAR</code>寄存器中再次写入（保持之前的设置，更新切片地址）：<ul><li><strong>CWADDR &#x3D; 0</strong>：行地址保持为0。</li><li><strong>CSADDR &#x3D; 1</strong>：选择缓存的第二个切片（即写入命令字的第32到63位）。</li></ul></li></ul><p><strong>步骤 4：写入32位数据到DCU数据寄存器（<code>DCUDR</code>）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表期望数据缓存的第32到63位（即命令字的第32到63位）。写入的数据会填充缓存行的第二部分。</li></ul><p><strong>步骤 5：更新DCU地址寄存器（&#96;&#96;DCUAR&#96;）以选择切片2</strong></p><ul><li>在DCUAR寄存器中再次写入（保持之前的设置，更新切片地址）：<ul><li><strong>CWADDR &#x3D; 0</strong>：行地址保持为0。</li><li><strong>CSADDR &#x3D; 2</strong>：选择缓存的第三个切片（即写入命令字的第64到79位）。</li></ul></li></ul><p><strong>步骤 6：写入32位数据到DCU数据寄存器（<code>DCUDR</code>）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表期望数据缓存的第64到79位（即命令字的第64到79位）。请注意，此时数据的第16到31位将被忽略，只会写入有效的前16位。</li></ul><h4 id="3-注意事项-1"><a href="#3-注意事项-1" class="headerlink" title="3. 注意事项"></a>3. <strong>注意事项</strong></h4><ul><li><strong>地址递增</strong>：启用<strong>INCA &#x3D; 1</strong>后，每次写入时切片地址会自动递增，直到缓存行写满为止。这样可以省去手动更新地址的步骤，简化操作。</li><li><strong>无效数据位</strong>：期望数据缓存的每行宽度为80位，第三个32位切片中只有前16位有效，后16位的数据会被忽略，因此每次写入时，需要确保只写入有效数据。</li></ul><hr><h2 id="DCU读取数据缓存读取示例（DCU-Read-Data-Cache-Read-Example）的详细解释："><a href="#DCU读取数据缓存读取示例（DCU-Read-Data-Cache-Read-Example）的详细解释：" class="headerlink" title="DCU读取数据缓存读取示例（DCU Read Data Cache Read Example）的详细解释："></a><a><strong>DCU读取数据缓存读取示例（DCU Read Data Cache Read Example）</strong>的详细解释：</a></h2><p>此示例展示了如何使用<strong>自动地址递增模式（automatic address incrementing mode）</strong>读取DCU的读取数据缓存（read data cache）。读取数据缓存每行包含32位数据，并且总共有4行，每行包含1个32位数据字（或1个切片）。</p><h4 id="1-背景说明-2"><a href="#1-背景说明-2" class="headerlink" title="1. 背景说明"></a>1. <strong>背景说明</strong></h4><ul><li><strong>缓存行宽度</strong>：读取数据缓存的每一行宽度为32位，即每行只有1个切片。</li><li><strong>缓存的行数</strong>：共有4行数据，分别对应读取缓存的不同部分。</li></ul><h4 id="2-读取过程"><a href="#2-读取过程" class="headerlink" title="2. 读取过程"></a>2. <strong>读取过程</strong></h4><p>要从读取数据缓存中读取数据，并启用自动地址递增模式，需要按照以下步骤通过配置端口（或APB或JTAG）与寄存器进行交互：</p><p><strong>步骤 1：写入DCU地址寄存器（DCUAR）</strong></p><ul><li>向DCUAR寄存器写入以下字段，设置用于读取数据缓存的地址和切片信息：<ul><li><strong>CSEL &#x3D; 2’b10</strong>：选择读取数据缓存（Read Data Cache）。</li><li><strong>INCA &#x3D; 1</strong>：启用地址递增（即每次读取时，地址会自动递增）。</li><li><strong>ATYPE &#x3D; 1</strong>：读取访问（Read Access）。</li><li><strong>CWADDR &#x3D; 0</strong>：选择缓存行地址为0（行地址为0）。</li><li><strong>CSADDR &#x3D; 0</strong>：选择缓存切片为0（即从第一个切片开始读取）。</li></ul></li></ul><p><strong>步骤 2：从DCU数据寄存器（DCUDR）读取32位数据</strong></p><ul><li>读取<strong>32位数据字</strong>，该数据字代表缓存行的第0行数据（即缓存字的[31:0]位）。这是读取数据缓存的第一部分。</li></ul><p><strong>步骤 3：更新DCU地址寄存器（DCUAR）以选择下一行（行1）</strong></p><ul><li>在DCUAR寄存器中再次写入（保持之前的设置，更新行地址和切片地址）：<ul><li><strong>CWADDR &#x3D; 1</strong>：选择缓存行地址为1（读取缓存的第二行数据）。</li><li><strong>CSADDR &#x3D; 0</strong>：继续选择缓存切片为0。</li></ul></li></ul><p><strong>步骤 4：从DCU数据寄存器（DCUDR）读取32位数据</strong></p><ul><li>读取<strong>32位数据字</strong>，该数据字代表缓存行的第1行数据（即缓存字的[31:0]位）。这是读取数据缓存的第二部分。</li></ul><p><strong>步骤 5：更新DCU地址寄存器（DCUAR）以选择下一行（行2）</strong></p><ul><li>在DCUAR寄存器中再次写入：<ul><li><strong>CWADDR &#x3D; 2</strong>：选择缓存行地址为2（读取缓存的第三行数据）。</li><li><strong>CSADDR &#x3D; 0</strong>：继续选择缓存切片为0。</li></ul></li></ul><p><strong>步骤 6：从DCU数据寄存器（DCUDR）读取32位数据</strong></p><ul><li>读取<strong>32位数据字</strong>，该数据字代表缓存行的第2行数据（即缓存字的[31:0]位）。这是读取数据缓存的第三部分。</li></ul><p><strong>步骤 7：更新DCU地址寄存器（DCUAR）以选择下一行（行3）</strong></p><ul><li>在DCUAR寄存器中再次写入：<ul><li><strong>CWADDR &#x3D; 3</strong>：选择缓存行地址为3（读取缓存的第四行数据）。</li><li><strong>CSADDR &#x3D; 0</strong>：继续选择缓存切片为0。</li></ul></li></ul><p><strong>步骤 8：从DCU数据寄存器（DCUDR）读取32位数据</strong></p><ul><li>读取<strong>32位数据字</strong>，该数据字代表缓存行的第3行数据（即缓存字的[31:0]位）。这是读取数据缓存的最后部分。</li></ul><h4 id="3-注意事项-2"><a href="#3-注意事项-2" class="headerlink" title="3. 注意事项"></a>3. <strong>注意事项</strong></h4><ul><li><strong>地址递增</strong>：由于每行的宽度为32位，并且每行只有一个切片，因此每次从DCUDR读取32位数据时，地址会自动递增。这样每次读取的数据都会对应到下一行的内容。即每次读取时，<strong>行地址（CWADDR）会自动递增</strong>，不需要手动更新。</li><li><strong>缓存行宽度</strong>：读取数据缓存的每行宽度为32位，这意味着每次读取的数据都会填充整个缓存行，不会出现需要裁剪或忽略的部分。</li></ul><p><a>BDXSEL 由 DCU 读数据缓存使用，以选择字节通道来捕获读取数据。</a></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIST（内建自检模块简介）</title>
      <link href="/2024/11/05/BIST%E5%86%85%E5%BB%BA%E8%87%AA%E6%A3%80%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/11/05/BIST%E5%86%85%E5%BB%BA%E8%87%AA%E6%A3%80%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>BIST (Built-In Self-Test)</strong> 模块是一种可编程的自检引擎，它为应用程序提供了一种测试 DDR PHY 和 I&#x2F;O 的方法，主要用于高速生产测试。BIST 模块通过 <strong>回路回送</strong>（loopback）方式来验证 PHY 的发送路径和接收路径的功能。除此之外，还可以选择测试外部内存的功能。<a><span id="more"></span></a></p></blockquote><h3 id="BIST-模块的功能"><a href="#BIST-模块的功能" class="headerlink" title="BIST 模块的功能"></a>BIST 模块的功能</h3><ol><li><strong>PHY 测试</strong>：<br>BIST 通过将数据从 PHY 的发送路径通过回路回送到接收路径，来测试 PHY 的发送和接收功能。通过此方式，不需要外部存储器即可完成测试。</li><li><strong>I&#x2F;O 测试</strong>：<br>BIST 还可以测试 I&#x2F;O 的功能，确保数据能够正确地通过 I&#x2F;O 接口传输。</li><li><strong>外部内存测试</strong>（可选）：<br>如果需要，BIST 还提供了测试外部内存的功能。此时，BIST 会发送常规的写读事务到外部 DRAM，并比较从 DRAM 读取的数据和写入的数据是否一致。</li></ol><h3 id="BIST-模块的工作原理"><a href="#BIST-模块的工作原理" class="headerlink" title="BIST 模块的工作原理"></a>BIST 模块的工作原理</h3><ul><li><strong>回路回送模式</strong>（Loopback Mode）：<br>在回路回送模式下，BIST 将数据从 PHY 的发送路径通过 I&#x2F;O 返回到接收路径。这样，数据就可以在 PHY 内部进行循环回送，进行自检。这种模式不需要外部内存，因此适用于不需要依赖外部存储器的测试场景。</li><li><strong>DRAM 模式</strong>（DRAM Mode）：<br>在 DRAM 模式下，BIST 会向 DRAM 发送正常的写读事务，并将读取的数据与预期数据进行比较。该模式适用于测试外部 DRAM 存储器。</li></ul><h3 id="BIST-模块的结构（Block-Diagram）"><a href="#BIST-模块的结构（Block-Diagram）" class="headerlink" title="BIST 模块的结构（Block Diagram）"></a><strong>BIST 模块的结构（Block Diagram）</strong></h3><ul><li><p>BIST 模块的框图（提供详细图示）展示了各个功能模块之间的连接方式。它通常包括以下几个主要组件：</p><ul><li><strong>传输路径（Transmit Path）</strong>：用于将数据从 PHY 的发送端发送出去。</li><li><strong>接收路径（Receive Path）</strong>：用于接收回送的数据并进行比较。</li><li><strong>外部内存接口</strong>：如果使用 DRAM 测试模式，则通过外部内存接口与 DRAM 进行通信。</li><li><strong>测试模式选择器</strong>：允许选择回路回送模式或 DRAM 模式。</li><li><strong>控制寄存器</strong>：通过这些寄存器，可以控制 BIST 模块的启停，配置回送模式、DRAM 模式、错误检测等。</li></ul></li></ul><p>通过该图示，用户可以理解如何在不同测试模式下配置 BIST 模块，并进行 PHY 和 I&#x2F;O 的功能验证。</p><p><img src="https://s2.loli.net/2024/11/05/KVoF7RqgQZnbhmH.png" alt="image-20241105231703048"></p><hr><h3 id="1-环回模式（Loopback-Mode）"><a href="#1-环回模式（Loopback-Mode）" class="headerlink" title="1. 环回模式（Loopback Mode）"></a>1. <strong>环回模式（Loopback Mode）</strong></h3><p>环回模式是用来测试 PHY（物理层）和 I&#x2F;O 接口的。其原理是将写入的数据直接送回接收路径，这样就不需要外部存储器（例如 DRAM）来进行测试。具体来说：</p><ul><li><strong>DATXn 写路径和接收路径的环回：</strong> 在环回模式下，<strong>DATXn</strong>（数据线组）的写入数据将直接通过 I&#x2F;O 传输到接收路径上。也就是说，BIST 发送数据之后，数据直接回到发送端，而不经过外部存储器，这样可以用来验证 PHY 数据通道是否正常。</li><li><strong>AC 输出路径的环回：</strong> 另外，<strong>AC 输出路径</strong>也会在 I&#x2F;O 处被环回到专用的 AC 环回逻辑。AC 是指命令和地址通道（Address&#x2F;Command），它用于传输内存的读写地址和控制信号。这部分的环回确保地址和命令通道也能正确工作。</li></ul><p>这种模式的好处是无需连接外部 DRAM，测试过程可以在没有外部存储器的情况下进行，适合用于检查 PHY 层和 I&#x2F;O 接口的基本功能。</p><ul><li><strong>最小的 WL&#x2F;RL：</strong> 环回模式下支持的最小 WL（写延迟）和 RL（读延迟）为 6。WL&#x2F;RL 是内存操作的延时设置，通常与内存的时序参数有关。BIST 测试时，环回模式对延迟有最低要求。</li></ul><h3 id="2-DRAM模式（DRAM-Mode）"><a href="#2-DRAM模式（DRAM-Mode）" class="headerlink" title="2. DRAM模式（DRAM Mode）"></a>2. <strong>DRAM模式（DRAM Mode）</strong></h3><p>在 DRAM 模式下，BIST 会像正常的内存访问一样进行读写操作，写入数据到 DRAM 中，并从 DRAM 中读取数据来进行对比。这个模式实际上测试的是内存的数据完整性以及内存与 PHY 接口之间的配合。具体来说：</p><ul><li><strong>写读事务：</strong> 在 DRAM 模式下，BIST 会执行正常的<strong>写读事务</strong>（Write&#x2F;Read Transactions）。即，它将数据写入 DRAM 并从 DRAM 中读取数据来进行对比，确保内存和 PHY 层能够正常交互。</li><li><strong>地址和命令通道的环回：</strong> 即使是在 DRAM 模式下，<strong>地址&#x2F;命令通道</strong>（Address&#x2F;Command Channel）依然会在 I&#x2F;O 处进行环回。这意味着，BIST 不会向外部发送命令和地址信号，而是会将这些信号发送回自身，以确保地址&#x2F;命令通道的功能正确。</li><li><strong>外部存储器测试：</strong> 在 DRAM 模式下，可以将其用作测试外部内存（例如，外部的 DRAM 存储芯片），通过发送写读事务并进行数据比较，验证 DRAM 和 PHY 层的通信是否正确。</li></ul><hr><h3 id="PHY环回功能"><a href="#PHY环回功能" class="headerlink" title="PHY环回功能"></a><strong>PHY环回功能</strong></h3><p>PHY（物理层）环回是通过 <strong>I&#x2F;O</strong> 接口的环回功能实现的，目的是将从 I&#x2F;O 驱动出去的数据通过环回机制传回，以便进行测试和验证。环回的实现取决于 <strong>PGCR1[IOLB] 寄存器位的设置</strong>。</p><h3 id="环回机制的工作方式"><a href="#环回机制的工作方式" class="headerlink" title="环回机制的工作方式"></a><strong>环回机制的工作方式</strong></h3><ul><li><p>数据的环回：当数据从 I&#x2F;O 驱动出来时，它可以在两种不同的位置进行环回：</p><ul><li><strong>I&#x2F;O的pad侧：</strong> 这种方式是将数据在I&#x2F;O的pad（物理引脚）端进行环回，即数据通过I&#x2F;O引脚直接返回。</li><li><strong>I&#x2F;O的核心侧：</strong> 另一种方式是在I&#x2F;O的核心侧进行环回，即数据回到I&#x2F;O的内部逻辑。</li></ul></li></ul><p>具体选择哪种环回方式，取决于 <strong>PGCR1[IOLB]</strong> 寄存器位的设置。PGCR1 寄存器中的 <strong>[IOLB]</strong> 位用于配置环回的模式：</p><ul><li>如果 <strong>IOLB</strong> 位设置为某个特定值，它将决定数据是从 <strong>pad侧</strong> 还是 <strong>核心侧</strong> 进行环回。</li></ul><hr><h3 id="DATX8-Loopback"><a href="#DATX8-Loopback" class="headerlink" title="DATX8 Loopback"></a>DATX8 Loopback</h3><p><strong>DATX8 读路径与环回路径：</strong></p><ul><li><strong>DATX8</strong> 是 DDR 接口中的一部分，它在数据字节传输中负责读取数据。</li><li>在环回模式下，<strong>DATX8 的读路径</strong>会被用作环回路径。也就是说，数据（DQ、DM）和写入的 <strong>DQS</strong>（数据选通信号）会被环回到 <strong>DATX8</strong> 读路径中，并被当作 <strong>读 DQ&#x2F;DM</strong> 和 <strong>读 DQS</strong> 来处理。</li></ul><p><strong>DQS 信号的对齐问题：</strong></p><ul><li><strong>DQS</strong> 是在 DDR 写入操作中与数据一起传输的同步信号。在 <strong>写入路径</strong> 中，<strong>DQS</strong> 会相对于 <strong>DQ&#x2F;DM</strong> 信号提前 90 度发送，这样可以帮助在读取时对齐数据。</li><li>但是在 <strong>读路径</strong> 中，<strong>DATX8</strong> 期望 <strong>读 DQS</strong> 和 <strong>读 DQ&#x2F;DM</strong> 信号是 <strong>边缘对齐</strong>（edge-aligned）的，意味着它们应该在时序上保持同步。</li></ul><p><strong>问题：</strong></p><ul><li>在环回测试中，由于 <strong>写路径</strong> 会将 <strong>DQS</strong> 信号相对于 <strong>DQ&#x2F;DM</strong> 信号提前 90 度（这是为了帮助读取数据），<strong>DATX8</strong> 读路径会接收到已经提前 90 度的 <strong>DQS</strong> 信号。这个提前的 90 度是写路径的特性，而 <strong>DATX8</strong> 需要去掉这个提前，以确保 <strong>读 DQS</strong> 与 <strong>读 DQ&#x2F;DM</strong> 对齐。</li></ul><p><strong>解决方案：</strong></p><ul><li>为了消除这个 90 度的提前，应该通过 设置 LCDL（读取延迟控制）来调整 DQS信号的相位。具体来说：<ul><li>设置 <strong>DXnLCDLR4[RDQSD]</strong> 和 <strong>DXnLCDLR4[RDQSND]</strong> 为 0，这样可以去掉读取路径中 DQS 信号的 90 度偏移。</li><li>这确保了 <strong>环回模式</strong> 下，<strong>DQS</strong> 信号相对于 <strong>读数据</strong> 只会偏移 90 度，且 <strong>读取数据</strong> 和 <strong>读取 DQS</strong> 是同步对齐的。</li></ul></li></ul><p><strong>DDR3 写操作的预置（Write Preamble）：</strong></p><ul><li><strong>预置</strong> 是指在数据传输开始之前，信号在一定周期内的初始状态。在 DDR3 中，写操作通常有一个 <strong>全翻转预置</strong>（full toggle preamble），即信号在开始时进行翻转。</li><li>这个预置是为了保证数据的正确性，确保数据和控制信号能够准确地同步。</li></ul><p><strong>环回模式中的问题：</strong></p><ul><li>在 <strong>环回模式</strong> 下，数据通过 I&#x2F;O 路径被送回到接收器。通常在环回测试中，我们期望数据传输的信号在写入路径和读取路径之间能够同步。</li><li>由于 <strong>写预置</strong> 是一个全翻转预置，这意味着写入路径中的 <strong>DQS</strong>（数据选通信号）会进行翻转。</li><li>但是，如果环回时将这个信号直接送回读取路径，那么读取路径的 <strong>DQS 预置</strong> 也会跟着翻转，这就与预期的读取数据（通常来自 SDRAM 的数据）不一致。</li></ul><p><strong>问题的根源：</strong></p><ul><li><strong>预期的读取数据</strong> 应该是一个稳定的、没有翻转的信号。在标准的 <strong>SDRAM 写入操作</strong> 中，数据的读取路径中的 <strong>DQS</strong> 信号应该是一个稳定的 <strong>全时钟预置</strong>（non-toggling full-clock preamble），而不是像写路径中那样进行翻转。</li><li>如果将 <strong>写预置</strong> 在环回模式下直接传递到读取路径，那么读取路径的 <strong>DQS</strong> 信号也会经历翻转，导致数据和时序的错误。</li></ul><p><strong>解决方案：</strong></p><ul><li>为了保证环回模式下的正确性，需要 <strong>生成非翻转的全时钟预置</strong>（non-toggling full-clock preamble）信号，而不是全翻转的写预置。通过这种方式，可以确保在环回测试中，<strong>DQS</strong> 信号与读取数据的同步要求一致，避免了翻转问题。</li><li>具体来说，环回模式下会 <strong>生成与 SDRAM 预期相符的读取数据</strong>，即通过 <strong>不翻转的时钟预置</strong> 来确保 <strong>DQS</strong> 信号稳定，以匹配标准的 <strong>SDRAM</strong> 行为。</li></ul><hr><h3 id="AC-Loopback"><a href="#AC-Loopback" class="headerlink" title="AC Loopback"></a>AC Loopback</h3><h4 id="1-地址-命令通道-AC-Lane-："><a href="#1-地址-命令通道-AC-Lane-：" class="headerlink" title="1. 地址&#x2F;命令通道 (AC Lane)："></a>1. <strong>地址&#x2F;命令通道 (AC Lane)：</strong></h4><ul><li>地址&#x2F;命令通道负责与 <strong>SDRAM</strong>（同步动态随机存取存储器）进行通信，传输地址和控制信号。例如，<strong>地址信号</strong> 用于定位存储位置，<strong>命令信号</strong> 用于控制读写操作。</li></ul><h4 id="2-AC-PHY-环回逻辑："><a href="#2-AC-PHY-环回逻辑：" class="headerlink" title="2. AC PHY 环回逻辑："></a>2. <strong>AC PHY 环回逻辑</strong>：</h4><ul><li>在 DDR3 或 DDR4 系统中，AC PHY 负责处理地址和命令的物理层传输。为了在测试时不依赖外部内存，AC PHY 提供了内建的 <strong>环回逻辑</strong>，允许将地址和命令信号从 SDRAM 发送到 AC PHY，再从 AC PHY 环回到接收路径。环回后的信号被当作 <strong>读取数据</strong> 和 <strong>读取时钟</strong> 进行处理。</li></ul><h4 id="3-CK-CK-时钟信号的环回："><a href="#3-CK-CK-时钟信号的环回：" class="headerlink" title="3. CK&#x2F;CK# 时钟信号的环回："></a>3. <strong>CK&#x2F;CK# 时钟信号的环回</strong>：</h4><ul><li><strong>CK&#x2F;CK#</strong> 是用于同步数据传输的差分时钟信号。在 AC 环回模式下，<strong>CK&#x2F;CK#</strong> 信号被环回到 AC PHY，并被当作 <strong>读取时钟</strong> 来使用。</li><li>在环回过程中，时钟会被 <strong>反向</strong>（inverted），以确保 <strong>ck_do</strong>（环回后的时钟信号）能在 <strong>DDR 时钟</strong> 的一个周期之前传输，确保第一个环回数据能够被正确地采样。</li></ul><h4 id="4-BISTRR-BCKSEL-寄存器："><a href="#4-BISTRR-BCKSEL-寄存器：" class="headerlink" title="4. BISTRR[BCKSEL] 寄存器："></a>4. <strong>BISTRR[BCKSEL] 寄存器</strong>：</h4><ul><li>该寄存器字段用于选择哪个时钟信号（**CK[n]**）将用于捕捉地址和命令信号。在环回模式下，可以根据需要配置时钟源。</li></ul><h4 id="5-时钟反转（Inverted-Clock）："><a href="#5-时钟反转（Inverted-Clock）：" class="headerlink" title="5. 时钟反转（Inverted Clock）："></a>5. <strong>时钟反转（Inverted Clock）</strong>：</h4><ul><li>在 AC 环回模式中，时钟信号会被 <strong>反转</strong>，这样可以使环回数据在 DDR 时钟周期的 <strong>提前一个周期</strong>（一个 DDR 时钟周期提前）时被正确采样。</li><li><strong>反向时钟</strong> 的目的是确保 <strong>第一个环回的数据</strong> 能够在正确的时钟边沿上被采样，从而避免时序问题。</li></ul><h4 id="6-cke-和-cs-n-对齐："><a href="#6-cke-和-cs-n-对齐：" class="headerlink" title="6. cke 和 cs_n 对齐："></a>6. <strong>cke 和 cs_n 对齐</strong>：</h4><ul><li><strong>cke</strong>（时钟启用信号）和 <strong>cs_n</strong>（芯片选择信号）会与 <strong>ck_do</strong> 上升沿对齐。尽管时钟反转了，但因为 <strong>cke</strong> 和 <strong>cs_n</strong> 并没有被用于外部 DRAM 的操作，因此在环回测试中它们的对齐不会造成问题。</li><li>这意味着，即使时钟信号发生了反转，<strong>cke</strong> 和 <strong>cs_n</strong> 信号与时钟的对齐状态并不影响环回模式中的测试，因为它们并不直接影响 DRAM 的操作。</li></ul><h4 id="环回模式中的信号流程："><a href="#环回模式中的信号流程：" class="headerlink" title="环回模式中的信号流程："></a><strong>环回模式中的信号流程：</strong></h4><ol><li><strong>地址和命令信号</strong>：从 <strong>SDRAM</strong> 发出，通过 <strong>AC PHY</strong> 环回逻辑，进入 <strong>AC PHY</strong> 接收路径，并被视为 <strong>读取数据</strong>。</li><li><strong>时钟信号（CK&#x2F;CK#）</strong>：时钟信号同样被环回，反转后成为用于 <strong>读取数据</strong> 的时钟信号。</li><li><strong>cke 和 cs_n</strong>：这些信号与时钟信号对齐，但由于它们不影响 DRAM，时序对齐不影响测试。</li></ol><hr><h3 id="Loopback-Data-Capture"><a href="#Loopback-Data-Capture" class="headerlink" title="Loopback Data Capture"></a>Loopback Data Capture</h3><h4 id="时钟路径和数据路径的延迟差异"><a href="#时钟路径和数据路径的延迟差异" class="headerlink" title="时钟路径和数据路径的延迟差异"></a><strong>时钟路径和数据路径的延迟差异</strong></h4><p>在 <strong>环回数据捕获</strong>（loopback data capture）模式下，时钟路径和数据路径的延迟存在差异：</p><ul><li><strong>时钟路径</strong>：时钟信号的传播通常会有更大的延迟，因为时钟信号需要经过更多的逻辑单元（如时钟缓冲器、分配网络等）。</li><li><strong>数据路径</strong>：数据从发送端到接收端的路径可能涉及不同的逻辑单元，但相对于时钟路径的延迟，数据路径的延迟通常较小。</li></ul><p>这种延迟差异的产生是因为：</p><ul><li>时钟信号必须被精确同步并分配到所有相关的接收器。</li><li>数据路径通常依赖于更少的逻辑单元来传输实际的数据。</li></ul><h4 id="2-如何补偿时钟路径和数据路径之间的延迟差异"><a href="#2-如何补偿时钟路径和数据路径之间的延迟差异" class="headerlink" title="2. 如何补偿时钟路径和数据路径之间的延迟差异"></a>2. <strong>如何补偿时钟路径和数据路径之间的延迟差异</strong></h4><p>为了确保 <strong>环回数据</strong> 的正确捕获，需要补偿时钟路径和数据路径之间的延迟差异。这个补偿的方式是通过增加 <strong>数据路径的延迟</strong> 来实现，使其与时钟路径的延迟差异相匹配。</p><ul><li>为了补偿这种延迟差异，可以通过设置 <strong>AC BDLs</strong>（Address&#x2F;Command Bus Delay Line）为 <strong>0xA</strong> 来添加延迟。BDLs 控制 <strong>数据路径的延迟</strong>，通过设置这些寄存器的值为 0xA，可以在数据路径中引入适当的延迟，使其与时钟路径的延迟差异相匹配。<ul><li><strong>AC BDLs</strong>: 这是一个控制地址和命令通道中数据路径延迟的寄存器字段。</li><li><strong>值 0xA</strong>：这个值表示一个特定的延迟量，根据设计的要求，这个延迟可以通过该设置来调整。</li></ul></li></ul><h4 id="3-延迟的计算"><a href="#3-延迟的计算" class="headerlink" title="3. 延迟的计算"></a>3. <strong>延迟的计算</strong></h4><p>补偿的延迟必须满足以下条件：</p><ul><li><strong>数据路径的延迟</strong>必须大于时钟路径和数据路径延迟差异加上<strong>捕获触发器的保持时间（Capture FF hold）</strong>。</li><li>这种延迟补偿需要适应不同的 <strong>PVT（Process, Voltage, Temperature）角度</strong>，即考虑到工艺、工作电压和温度的变化。</li></ul><p>换句话说，设置的数据路径延迟应该足够大，以确保数据能够正确捕获，避免因为时钟和数据路径的不同步导致的错误。</p><h4 id="4-RTL仿真中的特别情况"><a href="#4-RTL仿真中的特别情况" class="headerlink" title="4. RTL仿真中的特别情况"></a>4. <strong>RTL仿真中的特别情况</strong></h4><ul><li><p>在 RTL仿真</p><p> 中，由于仿真模型通常不考虑时钟和数据路径之间的实际延迟差异，因此不需要显式地为数据路径添加额外的延迟。</p><ul><li><strong>RTL仿真</strong>：这是指在设计阶段使用 <strong>寄存器传输级（RTL）模型</strong> 进行的仿真。在这种仿真中，设计的时钟和数据路径延迟差异通常是通过仿真工具的建模来忽略的，因此无需手动增加额外的延迟。</li></ul></li></ul><hr><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><h3 id="1-AC-I-O-接收器默认关闭"><a href="#1-AC-I-O-接收器默认关闭" class="headerlink" title="1. AC I&#x2F;O 接收器默认关闭"></a>1. <strong>AC I&#x2F;O 接收器默认关闭</strong></h3><ul><li><strong>AC I&#x2F;O 接收器</strong>：在 AC（地址&#x2F;命令）通道中，接收器用于接收来自外部的地址和命令信号（例如，SDRAM 地址、命令信号）。这些接收器通常在系统初始化时处于关闭状态，以节省功耗。</li><li><strong>必须启用接收器</strong>：在进行 <strong>AC 环回测试</strong> 时，必须确保接收器已被启用，否则环回信号将无法被正确接收。因此，需要通过配置 <strong>ACIOCR0[*PDR] 寄存器</strong> 来启用 AC I&#x2F;O 接收器。<ul><li>**ACIOCR0[*PDR]**：这是一个配置寄存器，用于控制 <strong>AC I&#x2F;O 接收器的电源管理</strong>。通过设置该寄存器，可以启用这些接收器。</li></ul></li></ul><h3 id="2-DATX8-环回测试前的准备"><a href="#2-DATX8-环回测试前的准备" class="headerlink" title="2. DATX8 环回测试前的准备"></a>2. <strong>DATX8 环回测试前的准备</strong></h3><ul><li><p><strong>DATX8</strong>：指的是数据通道中的接收器和相关的时序控制信号（如 DQ、DQS 等）。在进行 <strong>DATX8 环回测试</strong> 时，必须确保与数据通道相关的所有 I&#x2F;O 接收器和终端电路已启用，且拉电阻（pull-down&#x2F;pull-up）已配置正确。</p></li><li><p><strong>启用 DATX8 接收器和终端</strong>：通过配置 <strong>DXnGCR3 寄存器</strong> 来启用接收器、终端（termination）和数据选通信号（DQS）的拉电阻。具体来说：</p><ul><li><strong>接收器（Receivers）</strong>：确保接收器能够接收环回信号。</li><li><strong>终端（Termination）</strong>：确保数据总线上的信号被适当终结，以避免信号反射。</li><li><strong>DQS 拉电阻（DQS Pulldown &#x2F; DQSN Pullup）</strong>：拉电阻用于控制 <strong>DQS</strong>（数据选通信号）和 <strong>DQSN</strong>（反向数据选通信号）的电平，以确保信号稳定，避免不期望的浮动电平。</li></ul><p>这些配置项都需要在 <strong>DATX8 环回测试</strong> 前进行编程。</p></li></ul><h3 id="3-环回测试的步骤总结"><a href="#3-环回测试的步骤总结" class="headerlink" title="3. 环回测试的步骤总结"></a>3. <strong>环回测试的步骤总结</strong></h3><ul><li>AC 环回测试前：<ul><li>启用 <strong>AC I&#x2F;O 接收器</strong>，通过配置 <strong>ACIOCR0[*PDR]</strong> 寄存器。</li></ul></li><li>DATX8 环回测试前：<ul><li>启用 <strong>DATX8 接收器、终端和拉电阻</strong>，通过配置 <strong>DXnGCR3</strong> 寄存器。</li></ul></li></ul><p>这些配置步骤保证了 <strong>环回测试</strong> 能够成功地进行，确保 <strong>地址、命令</strong> 和 <strong>数据</strong> 信号都能够正确地回到接收路径并被正确处理。</p><h3 id="4-寄存器功能概述"><a href="#4-寄存器功能概述" class="headerlink" title="4. 寄存器功能概述"></a>4. <strong>寄存器功能概述</strong></h3><ul><li><strong>ACIOCR0[*PDR] 寄存器</strong>：用于控制 <strong>AC I&#x2F;O 接收器的电源</strong>，确保其在进行 AC 环回测试时已经启用。</li><li><strong>DXnGCR3 寄存器</strong>：用于配置 <strong>DATX8 接收器、终端</strong> 和 <strong>拉电阻</strong>，这些设置是进行 DATX8 环回测试的必要步骤。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIST Example Test Sequence</title>
      <link href="/2024/11/05/BIST%20Example%20Test%20Sequence/"/>
      <url>/2024/11/05/BIST%20Example%20Test%20Sequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p>描述了如何执行 <strong>BIST（内建自检）</strong> 测试的具体步骤，包括 DDR PHY 的测试初始化、配置和错误检查<a><span id="more"></span></a></p></blockquote><h3 id="BIST-示例测试序列"><a href="#BIST-示例测试序列" class="headerlink" title="BIST 示例测试序列"></a>BIST 示例测试序列</h3><p>下面是每个步骤的详细说明：</p><hr><h4 id="1-配置复位后-PHY-初始化"><a href="#1-配置复位后-PHY-初始化" class="headerlink" title="1. 配置复位后 PHY 初始化"></a>1. <strong>配置复位后 PHY 初始化</strong></h4><ul><li><strong>操作</strong>：在配置复位解除后，系统需要等待 PHY 完成初始化。</li><li><strong>方法</strong>：通过轮询 <strong>PGSR0.IDONE</strong> 位，等到它的值变为‘1’，表示初始化完成。</li><li><strong>注意</strong>：在等待 PHY 初始化时，可以同时配置其他 PUB（PHY 微控制器）寄存器。</li><li><strong>原因</strong>：此步骤确保 PHY 在测试前已经准备好，类似于正常运行模式下的初始化过程。</li></ul><h4 id="2-选择-DRAM-模式或-BIST-循环回路模式"><a href="#2-选择-DRAM-模式或-BIST-循环回路模式" class="headerlink" title="2. 选择 DRAM 模式或 BIST 循环回路模式"></a>2. <strong>选择 DRAM 模式或 BIST 循环回路模式</strong></h4><ul><li><p><strong>DRAM 模式</strong>：</p><ul><li><strong>操作</strong>：向<code>PIR</code>（PHY 初始化寄存器）写入以下设置：<ul><li>设置 <strong>PIR.INIT</strong> &#x3D; 1，表示初始化 PHY。</li><li>设置 <strong>PIR.DRAMRST</strong> &#x3D; 1（仅 DDR3）以重置 DRAM。</li><li>设置 <strong>PIR.DRAMINIT</strong> &#x3D; 1 来初始化 DRAM。</li></ul></li></ul></li><li><p><strong>循环回路模式(Loopback)</strong></p><ul><li><strong>操作</strong>：如果不需要 DRAM 模式，只需设置 <strong>PIR.INIT</strong> &#x3D; 1 和 <strong>PIR.CTLDINIT</strong> &#x3D; 1，表示跳过 DRAM 初始化。</li></ul></li><li><p><strong>原因</strong>：这一步确保选择正确的测试模式（DRAM 模式或循环回路模式）。</p></li></ul><h4 id="3-等待-PHY-初始化完成"><a href="#3-等待-PHY-初始化完成" class="headerlink" title="3. 等待 PHY 初始化完成"></a>3. <strong>等待 PHY 初始化完成</strong></h4><ul><li><strong>操作</strong>：等待 PHY 完成初始化，或者通过轮询 <strong>PGSR0.IDONE</strong> 位来确认初始化是否完成。</li><li><strong>原因</strong>：确保 PHY 在开始 BIST 测试之前已经完全初始化。</li></ul><h4 id="4-配置读-DQS-90-度偏移和门控设置"><a href="#4-配置读-DQS-90-度偏移和门控设置" class="headerlink" title="4. 配置读 DQS 90 度偏移和门控设置"></a>4. <strong>配置读 DQS 90 度偏移和门控设置</strong></h4><ul><li><p><strong>操作</strong>：可选择性地配置在 BIST 运行期间如何控制读 DQS（数据使能信号）的 90 度偏移和门控设置，通过写入 <code>PGCR1.LBDQSS</code>和 <code>PGCR1.LBGDQS</code>。</p><ul><li><strong>推荐</strong>：保持默认值，这样可以确保 DQS 信号正确对齐，并且在 BIST 循环回路测试期间 DQS 门控始终开启。</li></ul></li><li><p><strong>选择回路模式</strong>：在配置PGCR1寄存器时，还需要通过写入 <code>PGCR1.IOLB</code>选择使用 pad-side还是 core-side回路。</p><ul><li><strong>推荐</strong>：使用 <strong>core-side</strong> 回路模式。</li></ul></li><li><p><strong>原因</strong>：确保数据在 BIST 期间正确对齐，避免数据捕获时的对齐问题。</p></li></ul><h4 id="5-设置-BIST-生成的测试模式数量"><a href="#5-设置-BIST-生成的测试模式数量" class="headerlink" title="5. 设置 BIST 生成的测试模式数量"></a>5. <strong>设置 BIST 生成的测试模式数量</strong></h4><ul><li><p><strong>操作</strong>：通过向 BISTWCR.BWNCT写入，设置要生成的模式数量。</p><ul><li><strong>默认值</strong>：默认值 32 个模式通常足以覆盖大部分测试。</li></ul></li><li><p><strong>原因</strong>：这一步是可选的，但可以根据需要配置测试模式的数量。</p></li></ul><h4 id="6-确保地址-命令和I-O-接收器被供电"><a href="#6-确保地址-命令和I-O-接收器被供电" class="headerlink" title="6. 确保地址&#x2F;命令和I&#x2F;O 接收器被供电"></a>6. <strong>确保地址&#x2F;命令和I&#x2F;O 接收器被供电</strong></h4><ul><li><strong>操作</strong>：如果计划使用 <strong>pad-side</strong> 回路，需要确保地址&#x2F;命令 I&#x2F;O 接收器已供电，可以通过向 <strong>ACIOCR0</strong> 写入 <strong>0x20000000</strong> 来确保这一点。</li><li><strong>原因</strong>：地址和命令信号默认是关闭的，这一步确保它们在测试前被供电。</li></ul><h4 id="7-重置-PHY-FIFO"><a href="#7-重置-PHY-FIFO" class="headerlink" title="7. 重置 PHY FIFO"></a>7. <strong>重置 PHY FIFO</strong></h4><ul><li><p>操作：通过写入 <code>PGCR0.PHYFRST = 0</code> 来重置 PHY FIFO。</p><ul><li><strong>等待</strong>：等待至少 8 个 <strong>cfg_clk 周期</strong>，以确保 FIFO 完全重置。</li><li><strong>清除复位</strong>：通过写入 <strong><code>PGCR0.PHYFRST</code></strong> &#x3D; 1 清除复位状态，准备好进行测试。</li></ul></li><li><p><strong>原因</strong>：确保 FIFO 中没有残留的坏数据或错误状态，避免影响 BIST 测试。</p></li></ul><h4 id="8-触发-BIST-运行"><a href="#8-触发-BIST-运行" class="headerlink" title="8. 触发 BIST 运行"></a>8. <strong>触发 BIST 运行</strong></h4><ul><li><p>操作：通过写入 3’b001到 BISTRR.BINST启动 BIST 测试。</p><ul><li><p>其他配置</p><p>：在触发 BIST 时，还需要配置 </p><p>BISTRR</p><p> 寄存器中的其他字段，如：</p><ul><li>选择 <strong>循环回路模式</strong> 或 <strong>DRAM 模式</strong>。</li><li>启用 <strong>地址&#x2F;命令通道</strong> 或 <strong>字节通道</strong>。</li><li>启用 <strong>数据掩码</strong>。</li><li>选择用于测试的具体 <strong>字节通道</strong>。</li></ul></li></ul></li><li><p><strong>原因</strong>：这一步启动了 BIST 测试，并且确保其他配置正确设置。</p></li></ul><h4 id="9-等待-BIST-完成"><a href="#9-等待-BIST-完成" class="headerlink" title="9. 等待 BIST 完成"></a>9. <strong>等待 BIST 完成</strong></h4><ul><li><strong>操作</strong>：通过轮询 <strong>BISTSR.BDONE</strong> 位，等待 BIST 测试完成，状态为 ‘1’。</li><li><strong>原因</strong>：这一步确认 BIST 测试已成功完成。</li></ul><h4 id="10-检查是否有错误"><a href="#10-检查是否有错误" class="headerlink" title="10. 检查是否有错误"></a>10. <strong>检查是否有错误</strong></h4><ul><li><p>操作：通过读取 BISTWER.ACWER地址&#x2F;命令通道错误）或 BISTWER.DXWER字节通道错误）来检查是否有错误。</p><ul><li>如果没有错误，测试完成。</li></ul></li><li><p>如果发现错误，进一步读取 <strong>BIST 错误寄存器</strong>，查看具体哪些信号发生了错误。</p><ul><li>可选地，使用 <strong>BIST 调试模式寄存器</strong> 来帮助定位故障。</li></ul></li><li><p><strong>原因</strong>：确保在 BIST 测试中发现并处理任何错误。</p></li></ul><hr><h3 id="关键操作总结："><a href="#关键操作总结：" class="headerlink" title="关键操作总结："></a>关键操作总结：</h3><ol><li><strong>初始化 PHY</strong> 并配置相关寄存器。</li><li><strong>选择测试模式</strong>（循环回路模式或 DRAM 模式）。</li><li><strong>触发 BIST 测试</strong>，等待完成并检查错误。</li><li>使用 <strong>BIST 调试寄存器</strong> 定位并调试可能的错误。</li></ol><p>这些步骤确保 DDR PHY 的 BIST 测试能够正确运行，并在发现问题时提供调试信息。这为测试人员提供了一种灵活的方式来验证 DDR PHY 的功能，确保其在生产中的可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim操作</title>
      <link href="/2024/11/05/vim%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/11/05/vim%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>VIM的快捷操作<a><span id="more"></span></a></p></blockquote><h3 id="设置文件格式为-Unix"><a href="#设置文件格式为-Unix" class="headerlink" title="设置文件格式为 Unix"></a>设置文件格式为 Unix</h3><blockquote><p>在 vim 中，你可以通过设置文件格式来确保文件使用 Unix 风格的换行符（即仅使用 \n）。<br>输入以下命令：</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> ff=unix</span><br><span class="line">:<span class="keyword">wq</span></span><br></pre></td></tr></table></figure><h3 id="手动调整整个文件的缩进"><a href="#手动调整整个文件的缩进" class="headerlink" title="手动调整整个文件的缩进"></a>手动调整整个文件的缩进</h3><blockquote><p>如果你想一次性调整整个文件的缩进，可以使用 <code>gg=G</code> 命令。这两个命令的作用是：</p></blockquote><ul><li><code>gg</code>：跳转到文件的开始。</li><li><code>=G</code>：对整个文件进行自动缩进。</li></ul><p>使用 <code>gg=G</code> 后，<code>vim</code> 会根据当前的缩进设置（如 <code>shiftwidth</code> 和 <code>tabstop</code>）对整个文件进行重新缩进。</p>]]></content>
      
      
      <categories>
          
          <category> VIM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-swap_4bit_block</title>
      <link href="/2024/11/05/C%E8%AF%AD%E8%A8%80-swap-4bit-block/"/>
      <url>/2024/11/05/C%E8%AF%AD%E8%A8%80-swap-4bit-block/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4e95431e3451c4a47cac61eb048a3eb073f146c1118d7959f460f340d3f79e2e">bc784a9a828376686ad79bc9be5654d361b361fd88beba2111ec0856b1960915f938a61ca008a7d77c2c4dafcc20a13dec000d6e8dfb085dada8da63426de172c8d43ffc55b872d29be296e19b6912bfbf4bc145b62b5e3902781fa369346d2ac0cd153de12acc03908056048b3e24496c6b7155767cfdbe4527f7541f8ee1586638e2538b22c9ebaf2d613266d2f2aedeb0af7663d048464ab0d4cb687655b353490564c428e44e8dee2a2868acc53f0238f2bce6617ad6681d84951ae70e66239abaf093c7defa8a75ae902103d20561085469a55a56229164165b91d07464b9a843b083a4d10427e910f1d4eb2c6f07b03572dace8343912a7fb9d92cc1f7f7b9adb2dc594f01abd348e38f87b3c9d6c39d12090eb92af7d4cf66f739e48bb1c43f8bd9788696ea855afa6acae17baf6fd87c6ba237bcf971724e725efba24673f1941111d496cf16fa1ea10c248791adfefeabca682d7413f14457c6e5a97814265248e28fb785cc210c47ffd1b8b6356cc052ece5dd4281f8cc165742e303a353a7e51510db2d921196d907d75e9676b230a3b91a98f4f01b9910b72a90de7bd7be65fda8a636f568025c115393f7caf937a4f3dad00608fa5941d51d13c428c0eab6877da9e5ee96d3503650e30c2a541060e789e0567ddd8132a1afed0f6aaac0aad8bc22175521f656bf460384a10a41ead5de0c84c0052cded6f3770fc4c63ee1469b66ee53b6488920d311645b410aea432c07d03a22270a48506c099d0c1cefb7deda259cda6c8c7d9e7d43df4fa067ec3a32362ef89ac913d396408508a8ee32bba7400a52aef511d357fffc9b9da056e44c92ea7a47e6448cb96b770c3e04ef062d68978a06510f41cc3c482228faa1f1789b828db47a2acc184e947312aeae0de8ddeaf290f2bb0d5cf4cef29bb3c2ed1703c1940c4f3bfee4c726849fdb9d9d3e0522893daccdd622b28a31d1688d60a083a292b724ba687cf2549fc1058d1256e3bb54a278dfb048a7e7762936b20d84aebc3c814ddaf395c682523217afe8735fe85200e92de95a9ff6fcae418747ae7b7950bb5f4abeaa579e811a25af5efd21c0f072aa85b9112972a7568558d51df06eadb3b5bf3311c6f9bb2bc0e63e71eab55e0e8f6afd94f5d13209aaef0a26fac741d3979b836e67dd27da8afba37c082ae2da12fe2d15ccc0e4aaa1504a4a7fee4d22b5de7ae6e1d92ed22d016ace30dd7473d99245c98d61c220dd34a0a980308949b55ea7fbd01987869a70c756c1bfb502c4440e48d74af1da4f1792d3f580c7013a6ed769e584c57e5b29217825b8b627a540301ec10a35b50dd8efb094bcda477c1b6f87c658b6c7b84fd461aba87a80aa3e3a0e2c0d870797f162a19cb32435b6366a52a018004fa2281bdb184551c88d2408b8a37d09c3a648fefb58bf525ce29841a312b44a1e356b31804852f6011bbb9ca5e38d87541e6bbd01c845af346d4e07422f6ab83dc63d0ce23af7ac983a121f3a851639b0300808ad5671f2afb96c2f723e262d9f580fdb080251adc0758246b3e94c9b575bda3b6835ddcf2ba8be22a2443a62d3af16f724e987c7fae4d2cab8fab0726e0ee4f233d3c9655a84b7e7ca9ef05b2b8c1a1182013b9f082314cd22c878bc9c0e551f30e08ebe028e3b40fa9cd3ba0ba8ddd7f6a6665ca03cf8d00e19e8b87cf7e431583d16b42a2921930f5f298a964951756262ee21fc714b77c364fd0b1c347d9b3c708e7a3486124d2e2ac014ee010590936df494bad3c2a470bb79dd81a672ffd5a78c6fb7666a8eb1499575b3114887f95eb843098504db7ec0122800c498b1b82ef26f762cdad14ce809f34abe0b4d40552d9e01bae64a9a513e0a2c79cf40e7547ed496429fd693c00b6b1c339eb78b3e20b027feb1b83b1ba1299eaaecc70ff481642cae2aa3039e7bdbd6b179ad9ec8d42f81ccf23a05bb9101f95bd37d5eeb3e2edb2042bdd9731b0ff6c4dbb66ac639e66ebf3e398e23e1ab558045a99fa7377df298d12386cd9363b8d91d0b5e1139240c72bc5646e6bc253e608576559224aa38945e1439f4ed74313b48c6c782d5e8d2d56d9663f581eac1905c9561b49b6ac95495e3b364cc26ab4a787ee8578b12a2416d7fa7fd6edbeab2e696e0bb9ea4fc8b65d577bbd3214e417b54a246ab6cd9fda3532f04382e47d058fd1268174802a6fd8a27dd6bf0dc5a76988421e2475ff7ba03aacd61eef89f8bcf5db1730333bcd36cdadd293fc731acb3e3bbf8580721bdb90e468309bf3c3e28df1ff3b09b9916fd24f84710b15eacf3d9ad71a4540e921e21b7af13175973785a4c3840f68f65a3e9c22a5bfa3ffaf3aec285487e981fb54cfd978f46bf091e0bee32ff5c92e9193b55b94080496e27da76848ff1893b305419aa29b61e83a2b2788393714b6973fc6ea61ca031eb1298ba583afee45346278c11c06f042001d8eb5a93639cec89a72919137ff7ef288a0b2985bbdb752d9bfcd53492c45f9cbaeaac863c0e717ba35ee5353c5e2e401e407f63ca5ee37890bc92b478c2082ee57d522c3d360716b74a97a9ea651ac6603b9096b5dec21f32249473b704dff17dd63e634ca320efd37c95a4f421668a97ec29736c38d13b09b4127d5354a964deb78d55285be0cac975022f9c9ee98954f5b1a92a56cea0794e4879a7e6e5132bf83c6b820b4d1437bde3f5ff782ff7d4f72d15ca3c42348de0836ec59c49e1d358e4dcd146803758d6cc7c11bd7574bddb965c7edfa756ac3f831c4726d433ee42c45b01fb45f9d50ff1cb7061b4c69b8b4b2e2921995c557662e37d3000658eb7236cf830cb66e2d690b0e4e617901081fa8b3fabddd0e11c2842e1ce09aeee52c91004aeaa31f6c6a4ca8e051356f545b565d3f471131111dabeaaa599ae9b91ffdaf3897f804d95ad6cc25acb9c5fc936241d2957ec73847911c0f04aa9ba3769923c18050874989ddbdbed51d77a37c3227f727059f1360b6f2cbd44bf669456fc2bdb6c54c1013ed8f1ea61bdfb80aa6aaa1bb49af733b63adff85493e3aa730961c2cab18820b709a0f84ce981c2555cd48dfc0a980ae9212b2ee7c4e3f56de51cdb76336fc145ada79bc248862f349094aad5e4730640d3f45eb8478f6b3c1aaee4a8e30c916f7b7afa3503f8a1d3fcb27274d82984ee65085c6f027f35dc10cf883b6fc946a68e950c5c4f28e3124ceb3e07dfd13d1d70d97922d0ef72a45e272f46fb4f511b5ebca9a51b4e64ff55a7997fc6a50ae019c97441b39ec352159700831a68daf7a3c691da22e646178ed8944dc92f6e791e0812aa8e150a5a3b001faa360822c0e4376cd16a9c14a88d184a3ef11ba6db3e7ef55311ba87557e392f58a065474c9ce05c559c2f4e33c4ee815f714787a4d6a4c789ba5fbd218d7d6fd9bc1a9e923a7b02ced7430e2f6bde1b72e150de19ded699993dc4bf52dd5c9179f56160a5f3f515843ebade91f544c632c806c6c9138a7595d7f1e4de84174e4dc97d02d529aa5780ac2c2ee6a9a2cf7f325558ebcd9e1d8f410a39fcd3b4fe76085d6f997e8fd801cfd8c16069c00c0d5620756edc74e416f783e68ed15538c19877865cc363e2702b8e8b70a5f15c77e6f1326a3d97f5dbbef5978d51831d62a7768b9cc6a43eb8b5fc9ce1903917eae333446aabce25568335cb6884fb412784ae5d9c11b4b626590182b253f8636993f2c4d223d672d09ee06aa72929c356207ed6492cba39ea03f2d4d90bcb65d56b539a5872ddc7b49baf2f226017d2c63ddeb89e87c7d4bc408ba66b551d3ba270093850f674c770582051a8482588b1e5d7fb0e7533666f44a9bd6d593abd97792c68bd4bf5ed21bf6648e2c7dcbe165327b897bc8088ce8e0e20160f1a1649fad2bd3a53f37687346f8574646b18a857a98c7223b81d1569dc6b52fb1e3ae68b669934ee2cd4257b0aee8dcfe5a627a5069a0993c177f8353fff104af578cc125cf7d4f75b42d6c45db45294c9417ae544310f7c52af2d1a02d02bc9d5c19ec5557acdfa2c8b3bf120ef3783cd63feacda3d7d554ac590d9955fc019c3644046880a3169306456805fe8116943065566bd32afa1eaa8e5858175695824a3c03ae038cf778a796812942a2f0533441588cb529979f784254628a5d23e0666bdcb209893507c67166c02307642eaabe7d3bdf2cff0d277be431a077b547fb5ffc5fce17bbcc02e407518637ffa171a0e0280101ee8ac838fbbf6ea04d6ce5ac35dd6ab4048c5ed0849f002134f3d936c29df8a84ac604aa8cdd0bcaa7fe71db2fc4e6490eb959de5d45880ec5b20355b86c7a909827d6d76a287fe71c9fb4e82793b131fec16289382f006d6544cbf31d10ee2579ddb7c0d308310e9478e8d2c48a25197ce17dd664a667dd7dee8a6c067c383f86b6a86f4fdf6aa35d8f069f2cb6b53ff8af8dbf002b27f28221743de53f22de894c6c272c24eb6c515da40c53e528811c5072401a23ebd55b994f3d65e584d45bde538cd87b98ef7b1e67f6540e493643556087ac53626247d4f6aa97d0797fa2429e4a7481bee0c629cb6af47bee5ff629418f0a822b250cc1c3d8ffc79acdd00e53d195c0a8b57ca24bb08415409377abdc9ad45e32ee496c758a9602b94b89574095e2b0a5708f271b1e6960c5444ce06830e45dabdedc705a2394ac475c0861e55e5bc96422258872f3b03c31ade4d43f1bff90e6d0de0ca3cc1a494dc6a4100bb340cfca4563d4f4f02e0bc9203a19c34725563e9e83300f984a17f1affff130b430af12252b67ff3bc8dc040439825539ce0e2efb41a38fdc94b6e3dcf109fccb4207232097a3c7b1b570fe6e63f244e4f83a1d21a97e3c56b91e5ead37d75308b27dd7ce57b492d009733f858d9729b350629730d961c883d977e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不是哥们，你谁啊？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于C-Model的验证方法</title>
      <link href="/2024/11/03/%E5%9F%BA%E4%BA%8EC-Model%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/"/>
      <url>/2024/11/03/%E5%9F%BA%E4%BA%8EC-Model%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="84c95a067a469732ba427cde4507dac4933a2cddd5ff38054478d8419b0eb057">bc784a9a828376686ad79bc9be5654d3969156a2cc4729eb4409fe266c6a49d821a48ad5e7f4c037362fc643ac797f9ad0eb115845ba4a36ef250aa534ec2a1decaf32b71425a12782b02985bff2627e296955a7b0b2ff766b53db46f3eca2570359c4f0feff11059b3981d72ddf6bd9a0b2f05fe2e4eec6b60a67c7ed3f6a60a6aaf7ba2a009abe75c43097b3728a3ad8766655b273cdc3d6e539bc681b731587df7c5e34e0615d9f832ed8421fd35f7636c3d7c6f4b06647ff22f7f72663c143b94ff95afd83fba6fdb2f30c3bc3b462dee06de6bfcbf0245419f3bc985a0583bc0d4bd03806666861c34844458626789a03168ee97fef0460e96e78854073ba1915a31f02ab4f76ee1a2eb9bc694993587744d4db3e919b9165133759acd98e5d8debd59fd3f2108311f6d8071bf025cc2a1abc76ad6edccaf32a6a2a7d0e5b9a175c02f2d0c46923f901eda055f588878a18e1bfc002c21b14ec8ab2f17afad77285296143470dcbc4087a161684f7fe01d4605aafcb8327a8d17a1d5c8e41463ff04b8a6fb6e2b763e97e75836b56c82243536bac5cdc11bb1a5089c92ea02a33528307774da7ba1435c9d817e353ddcf6a1e10d63bd32359bdea82e4e3e5562c3c1e2893de341e67a0faea8e5e677bd268c76ed7c32f0b146b6404fedfd52b2173af7a7d8cf95b01fb0cec54b1f8d4fe8545dc61c04bab1a8d78674d9c8051319b21c381a0427346bc5118a95990811fe5ee48946c2bb23acd9f530c8987085ca110b4ac9646371269da17d1b891026c986c066c8cf86f30956014c110535ceb6d749849b8cf373475b1d5bdf99322e7eb6852c9171476fffc491773b77e34136aa6e46c9469870bade600492a04a37cf55d6ad00e59aefabff9642706a11e97de55e1320ef5dbf4396f66d08572c68704acab487e041fb0686d33a2f3f12c02c21fb4d6b4360e5c4c8c0b3d9d10d04d88b0bc84b97689d99e465f8974880c681a214a9b8aa5654441e7c1724a9050597af028f253a1b76abea348628332d5fb90341988d2a4eb443b1dcd6d963814be86d4ab269ab4a4ea1d817174a6492f98acc20f45a66d4191eb95b34a28b5947b762e9546e398476072a77a6a27513a66c6a5a9705a95db1d6285dad3a78d7a6c03b116323ba4e394a01735ffce0f427fcad461d2c1e9ef25c459956e4fa6c18a9d69d0e6aec1a864d90746a4c2fae0e76fb34fdf48e5a6bd57a0afefd5d28437bc6c6e664a9cfa40a78ed989fc27492e4375359f4db25bed28c4611b530a435cbfc9849d677719c711e67ab63c2c51767c2145bccac9b2795e81e7801148abde1756c87d8de61c4d1e2c6c54d2a943d843bd1a08dc97779afcc8ac1d5be7b253bd08dc2ec1aedba976ecbf9d9be788c3cdf5d762243ab86a4edac7a239d1ccdd5c3f34f95f1fb890c8b8d7e96e4f933acbc89cc519e9acc1b1a984e5ff721386e00267fc9196573767a30576492c3622fc71cccd595f095d72057560a92f02b04f4f122d6e5f1b6548c155231e1f02f980b727ba6734286dadcc3b05f19c56614246ce84c7586ee530906294a726c7531a3d25143d501c0940db9e7a3e1ec5143d6d722e3435db1302336a630ce5111f8cb1a1feed34d05b0770bbc19f8f809fcce7f31595029d33289d03e2d044cfe0e69c4fe2a0213ea25fbd36c56d15589ccd8c31e9a9767ed5f38153e499bedc30fd0941a695a7b693dd1c7460443cb05de5f3d0a66bb9899350d0dd5e278205515d5a7ee689512da3cda3d1bdd3f2562836002651c8a960c93d679dce7600d0f7fc0e2bfc3f8a5d89fc91977ddd1f2ea1a8793acc5b82514a69929951bb8817f2b6920d84172a9361080e66618a7dfd068ac861a973625fa0d6871490ecf61d44f5bbfdfccab9749b8cbb555f8c795cfcb7e94c5154d122b5e06243573fcade37de220744789c624ecc7c96df380a57190f6232423c00a7fc156adca128f924c23bd0daf5be1dab7faf83c14be1d05bd0d5a5c101d2af580c36f343ccb243634e0a930b58b49f89b204aebbcbbc368ace0987453399444d872420d6da8de20bb8350df96271904c69089b36ed72dd006bee94ef734204b84bbed807a0c10a65aa4f465398ea1d81ec6f44d9572e29968eca4f19111f161e190b16c104520a6241e5eefe2864e231d1a2881427c7ca7a6253d597fbad3f006cbccbab31348612fd6760c585d127ae97085a861221c6dd49ea120dbbb7b72580776f5fb83f1bd5e647a1c4f3033e4c3528b285c320820a9c87da9089b0c22115ce9a573d5d4dbf15bacf3f4d326d68433c4e0020966382a26b02b78cfc2fc5901e0f137d929fddd0bac236bbd54dd8593239d41861a906afd4d257dbdf00f909a0cc1c98fb6fc837e0e81aa273da0019f43576ce503221ed8438ee582471d4ca3e75a2db14ddb06b8a69d49a88f37920c40ac2846615da1fe0516817b49766ef38269084aff54685a0594dc6a7318cac5d3b66ba8a69304843741ded943be3d7fd8a9c747215ce1be51c19a55a5c455d622d50db679641f11c70ab4b36378c0a69f1ac2e73d76cd12efa2742bfa2954ad4612e3155c9de371d58f625cd373608e65a4ce27b71cfc75ac282eb4f151d33ad66ae3328e330219e9e466844bd273b71dc4105247cd30fc74ea6826b67fe5be05b34381c1e34ad96aa3ed128dc4ee61a422b894c079b0d9beb448e4e773bacec44db5786396219437e10d084a87e7952a61e1195444215f4dd648557db0c3b73d67ad108101df7c87706b9363e7946c83e08fdab3b97cbad7e460524620466196e6eb01403055b2b8e4d4f4a74ea19ede180f30a9bcdd571218b37909dedbb7c2f7bfb3587b9af224bb5366671bb5a1bd9a83e037eabf4fdfa38a775099115880ce17283d191896679b2b6c582fc0414f01c75cbfcdb9959ef90900509c52536eef878ace50c77bf42de46addf45c172167a9f34f617144e1f86158648b046613b2e8e871a6654c49e8213cac8b4de5e4d6b9cf29f436cf51f5dac66f9608a8d729cb10db91c50c7ef9bfbfe2450b5f61a9db1e6f9e74ce851ad2284eb35a4ab9fd4b9b2cbe97b09e89ecbe3fb3e3880e9cb4ccee75a0ab5e3f75a6bd86d3a5c43c097674849638bc8311560ed01f72af03463fcf3deaedb20badb478ea6346e5cd6383dc63338e9630fe95d601170045f674e64850f229eec0f05f87d142e5a39f3ce9fbb79eabc133c8ee7930d7a08a2a759f09352b59061cd055e366b8cc2bbfb47cd6b7c31254c4e46371c54b0e166e891dffb11e3b312336abcbebf20a90be8e61dcaaba6bee29de85fea986c3c14dcdffd9996976c715d6c1f51b4a698b1dfec6b7a9c36c4094fe1e1805288e9ee6630336a62b87c71b83a0b57d3e8437077ea92d470abc5bee7e0778ff2bbbfd1087f32ed1e021934ec294f99c48d134359578bd5bcf6c2d065923d1dbfb8f96307158ccd9aa8ba91163da5a0e5ac965b3fa66d53e15fc36a1c30930efe954b124fd4b0f439a89e54d21da9991306824eb5ca6ae2eca09f15439369309844bff517b61892ad15b2a55cbfc16aa05ccbc3dedae447eba8312db2896480fe38530a7a69c6c0ef30700c5994b86a3e72a295a5d86be2522ced91d30338c37165cc97cf379eeb80ad7d1be830cec294e24a3d016b626f70c7802cad27babc61e345b946811d95a8458b30f76b72cf91d043f4a2405e074dc267fe8bb49d2129c8a68d7e4e6e86b0ad08459948b35464bbb75ea9a51939d0ccec5fcdd7c517802e16ebb1065cd7f35bcdcbbf25e0ec8a5567fbdf70038e6053720320cccf1c3e2dcd08bfb5e6849040c7544d241badcf02bf35806d1a64744d030b1f18ed924fed9a24bf7d8e19ec6e2d57a2c8ebbdb3bb2a635f6c3d2eac25d139d25d217c157a90f9bae1034206292d80aafa035984b56e9c9aeeac0df9d9350c213afe3736dbab3cb62d0dc698b70b4797372cb47f1d83dc80abac7426d2e317a236e0396209ffbad2113658de223a8020c454a0d68626dc0ebecafc8509090cba0048d65eab9006fbbeb18378c33632a3182b72a695e066a0ffff6065c29d705743f0abeea0afac9c98c53a9dbea141027e079d99fb365e3182e0651bd75ca48ccda4dad274db6d39f1829a64bdfbc8d96124a02b8e7931149d7df3bb986ad88eea05267512242efd555aa7246d847b37cde3568f3317ac4ff90eb638e91439eca03c3f368d020b3836bf33e14a01a2d02429c822d067ebf7d3fd86cd17de336e57f348b38e2281d68a6464a771cc5e356a58fc1e6675ecc378ff73d51d02a8d9ca4454c28a8caadfab74eb377c3e5cb0e04c2608064dd3796962cdee68de2d1060b347355a855cece97060579c362e6dfeeaf0ab8dea259ab97b4091a7762f8fc9a5404fea989c39435423e3ee078b4c6e329db6140b809d3cc2647ee3a3d0f62be92f611372e4fbdd7418258819c92a1feab13acfd05dffcfd9a7ab5c0f94ebf512e45d90dc4465f7ebfe5e9bbbaf9722d159996e2a93466b74c3ffd453bba93d615f72a02c4282e6ba0ec23060464e5a1d4ecac0343e3975c02cea647af37f8428d300cb16154b59bb924ce272c9115c1fc948dc300f032d8a1c4c04f650959bb30b30d504b66c74327cc915b9738cb981cca6a07203bcbaf80992c0f08b454f7bb8d872cc918881d9662512909181da5ecff04b387263c889f82e25b38358b4c52e743f14d8f4385d197fee105a900599e994548f24d2d479564efa03e2cc917133b00e942e41bff27df6bb1c88ef56ba7af74ad64e72cd07f252c49759106b12f5d8333288aa754e70462c62c98a2b0b57be86410863ff955fd03f672889d34c8ab84519e1137219a337ab755aea470342d9b6b4946995a33d4394d1206862346072f91dbeb842e57e658ead30d724f97ccd094db920be86aa7625f45a5543233e609bc8d8c59c2786089e903b47fbec635f0ac3408b56ed56256eea90b719075581517232ccf19506b32b987687e32bfeb5a584d72ca1da9ae611415da967241876a18c45d6c9c9b26873983a4287c485d0d133b22347cf89e696d537b8198c76ac2ef0ed93e6183d79606b89e3cc5b2f591648ca7f318fd9473aaa0362fb5e63f4099e0e2411fa4aafcb5c91fa98ed17ae92cb30318b6a44b169c176ff5ac03e966759490f6cb82ffb2f9c2fef654f8491be6efb039819fdf64aa35a444f35e7e71b1a351be2ff601fa69c65ef398314bedf4c2f8f483f69ee9eb5b760d502ea8253f7cece3f27c0fb7b378d4b2e26c7684e8c340b011244c2a98ca0e78902a0a8ab1d2191a5aedf99ae540753ea8de8ef363b2016c11358c3e821070073d140b06617e7b40955d9845794cfcd27d208b3883462a0bf081fd0295765cca3b5efa6a58ee4afeddfdf306891107bef469558c8e248bbf5a84105f16651c97d36815fa88d7109178e0daa109b9af03605c532936d5eead001933d05cf301be28f81d31cee16587082fa66f1ccba7fca876b4365e66a0c8a676bce1f05f49827fcff2e82f24f5110998cd33ec774c72edbfd7ff4fa9cc52e73a473152406939689aa382fa9daa3570bcfb32b84533101e3bbb4d937c106ab0dde7ccde46f2569efc03f744c3b44e266501c96a917334d6ad47cf2780ca51d93ee737416347a54896e9be0c7357636cba4afa74651c243b9786633c2ddc5d16e775e48a434949382eacb3e2cd5b4a5617a49dad2796d4049007d35c3cf82709bd9ddb12ce518bafce37b84afc78d4b629bbc74e0c100666347c54db8618c3aea7169a2fe5299b0bd94646b2861c7913626300835f99cd589f6754d523d49e1a17d2748391d07feb025490d7bc1060f2d289c5c31c61f74e542f0ef37f407491ad16ba3802b6eb7eab06d25109d29075bf0c8044096eaec346c305fe6f1e8bb89b21d601d3fd012d228e819299b603f2addb6ab7809a39c1c9164fa26463953628f6a7f25a32a088a891478548050c563b5446d56fabe01d7718ec9ffa41e90f04af903a0ca2be099849c907e95457ce0f9badd155521906ab596c4dbaf2372d7813f404fc2c363d28d47069776fefb9fc0e5fd4acf35b050ee0e1b7aa9ccb55ed6649f03f223bcf70f08737cff033dd16900693fd73f63c3627d9232f043ded22ca13a8133cf92f768ca1756bf489c5daed54a8ca55d479457be06affc51bd8b636e75b36242ad4e5ac15b3bedf8daa39e2018da8313563d398da33c056bca449405c7edaf270ef5c3fca7e2dd3eabba0b39f5a7476638669a63c28fded46f91d50f2f0548d0a1ef3027482cc14297406c78ab2e379f0fc45d70c38d19925273713e0f3b3ee0bae22510cc5cdcf0bacee9889969f22a15d01dae4242ffff3593b7aabb9a80472e01a5a60c420af70d3c44aa565cf5a3407da3ddef261280011e07ad5ea032ea1bc0d9fdaa7b106fcbac5924bc0219fc104bfd7474a7a7806a78361115e75e57e88aa79cac739a694b04ee548196d76153799a4bda3f13aa80f1f705040140509c9fd9496d2cfa8aec38e70fbf4d82b2caf64afdd7977a03ba3fe3ffc33e5d0dddc27f4b0e4822c61d172c58cd67cfea82a6c05e9eae75169ad6b7f5942a28ea2f55a4f35500e2706ebaafba4d230bce23677d864d18c504119cc340ec73e42f8fddf8fc4d0485c86f08bdc3e31c3986a2fc2f9a58e4481c061ef12da3c961266d5371a38a2e772536783f41806f9a08ba241864b4f015337be27b13b5a195b84181dc39f5d9e50757c6f3a1dadf78f7a1e43811fdac71f9df97c72e4dff038e50cab5cc5251857a7b78809cf13a9110d69fb453df4bc2b16bb127ff245422c17a12f6f5a95c335cfb077184f4b736eedfad4f63d70e55e2b0ce00ff68150322b60bc84ea115e9a2068ac92f3b5b44ff4652a335a525f6e78a471e1ebc463afc56553199205745eb6ec69fa13fde5aab207af0a7f18c33f8b9d790ed682dac26a0e22e57c8e3cb0346bdd3327de474a39eacb09bded9a7df3bb48f8a967c0d84464684c28b7094801318b4f63561af4bd3f188a85e9ce41ffaf9b3b7375b17234c32014f53bf4848ae01952b94f8ecfea5ed209975068c70694cbfcf06ab8848588c1858164ea7e74ad462ae8cbcf43f7f946b7b648aa94fe9f46de631b94941dd8fee89cd30cdaa5189b07b406818f7a33085f5c776ebfdb81d40270e83950e1a8ec0d4d4039c332da9e0b7b8596c791d6a37c2ef22cc70846ff1730bb7b97f4e9db64cdd84a25862390dae1b9258e4fcadfc0d2138affda914f9c2cdc310577bc814d7726ba891343786e4df6c6bff7f8b9a495b5e7004281b166705cdb60df44e39f6d9f9456f67be8620fac3c8cc96a9ec2689f23f9505e9536618f8f813c687f9c69d0ae98b6441a92a60fef33eeb04ddb934cf58738f87e8709345569b6b1ec0fed32aad7c40fcf1644c9856f74b5623b7255b57264dd98c7b321694db76550974553712c7b661dcaef7d9dd5b776bf1ea693d73387b145713962812a03da2b37027ba97b3eacbd8429cb7ccd12371b1b0a8abc5a3932cbe4a79fa130a14590bf815dfaaa30bb7a119702f4feb4166e74723c4d0a3e95d719895b331fe1739bc7bb361a19eac49442c47e2da4a36468946da4603fc226cb9e97b60df801669423d78f9899c00b91a491c0bb2113e4ac1f5ea279ab8a9e07bf8dbeb18b7d564e3e1807154e212b37a11a9867613b5541acd0f8a73e262803b4caf2665daaab7cae9b6a269e63ccffdd0e6c62cce17be07a1d3a0c79156b08ce72f05ef59d86a3ffc05a2fb1cc0d7893e43cf3da0e592a3b7759e6e7d569020c9fba4b971586241c8cdfd57fd84cd493908f9ac5d6b8f2ab3616b2603ee7dd632dcc58b0625e7e3983c730aa84c8a990ecd5c86f6a2c6d4a36dd8157ef54ed9ec1bfd7ae5864f6ef3d7a787a7115134ee3a147b85c30f3cf370e8be5238f185009562bfe77f4d6a25f66f329d0aacdd20bf933f7032642f6b36aa208442d4aaadd87bb1d2875635a8d0a3f9149e822f52aaeaaf7ddae0ad0fceb2987e41785469ce91fb14a4bc060540d4b55bdc621007fd33aee3e2036a5911bbc4f3f8834546a3fda381fb529d76506e95bf46ed1964b7e0d18a529304629e828ca3ff337e919a1beadc7882596b4b651221faff8ef9c8ac8606066f31307e6bf0afa3369033f34fcdbd6c04f9144472fdea275a3997fda92809aba55c1ac163446a9b577486f74f5ab2cce6ecceccfa864eba8a62e4601a2baa6b92cf3a6c2b98d6b196db459c937f0e581dffac495375d0450a875fa7904549ee5613b280aa935e2bdfd8a16d61d496f0876a986aae8491face5e6877ffcf3d71fed3d43bbf0c8c23d4e634657d2abab6b5adc06079e5454a85451a6bd459ec76353b554a526da8808672da827921b349ab696f99b23724aeecd001326696b515091d7c4fc6138510a84c92d1b7058cd1500f0f50fcea86a16dffefa4ebf7a03c6fcea3c44587a44f0d6bcc094415bb1244601e317a8153553a61a4ed7544bc900d0b99ef33ea894a5957acc52109be0a5d847fbabb6852e83cb50dabd7773904983ebeeb316d24f275535345d42ebf25fab2299e3507b1d26e6f1bc66433836b42d7a38362dca296d17effb4e24ae9846b3aab0960571d631458e9a78a9608a76b84e13b2d294cfd2a78bd5888d2460846c230a328ae1da1ef27a98c101e9b7ded9945714d0ebaa4d1ab2015adf0cf53d545cee88b614e1311b34f140ae94e2c1955257732addd4d9cf9dd103d13124739e542ed2b0f4a5ee2df27a7926f1cec3e9e508c6e41d0b38189fc2a7a0ca43bd59e6055a7679d0888af67fe8b798fafb493495a8dc95ee81822fd04cee832c199e92b1f20b77e56d1ea9d7bc7bb1e1e8c54e280db89f2ffcc9e0cb292eea610505bdd4290cec52ee898cfd1d18bda4a00af82d1845490c6b8920f84a66e1c74e6adccdd69934c5a2655f4fd04517297bd356f7c9bf4433f5a48f837af64aa70bb63d9fc660ef70c67b479760ff969bb3b594f83a88ecf09a509bf4761a9fa0fe5557f71f0cd5a13e2c959dbeb0d648b72f6cde6c86b532da01d1a1b3d7180c3245c5a193903e90c4d27e45a8d60442b76bc85510773e9b55c54727902ab6080f1332e1b3120f05f9f5ac06a5dd0256d5685e2268e459666c3b37a0aabbf386d444b12bb6bd72e4341ba9caabe15d82310add8adf2b79cadc67e58905c5653412717f34785bc5960f02b149366cc792c1b32b38e1b67891e5e0a840ed1b19ef0d863ffc3f5a538c2d312e9268d8ca82fa894ab34ead5fcd9bd0f3bde67a3ee5675399b13fd1e7910e0f7dedefee44521cff29bffbe5396a1fe18f6f84a77d3454b6720d8e1fa3b4dc445bdcaa822e485ba9db3efacfe42fc63fb55dfe520cf5793a9e06b1911d7e0146ea6043b1e91c204d0944256185634ec8bd72a257d03ca417ac16ebbf5e5e933dec51121efd080c9cb48a962a8e688733f1ac4818d8c29c02372e13554f25aa068f33de4dd9ae8a27fce530156587c16c147b393b243e2e933159001d96ce26d7e137cac76216147cbbb294a46cab7bfd3f84fe4f7c3a33925e3424f14b7132f29b49a677031d47349d31add43aa5405150c525df1b7d9fdf19bec0097ab4beb6b792407801945b6c3990f7730ee6e6a2cdb2eb0ebed732016f642d57d2c56c5ca9bf023056ad108e331b7d8eeb314968edfadde2feadc138738383bf45891d3f676f025ae8847dc6325dbca275505e9019b1a257c7dc4f51d21e5d852b9eccd234868ddde6aaa29dd4b5ed1a8fd9b60a06c2d7c46782852611db25f49d4ef762849d80632160e4ea499cdfea7881890475547a90dbe51a490daf2b9447a0cdd5261ee681e2d1bd63487ee6021cd21e089ccb070c3e75518ee9c839e4e3743b8fe96f7089698fb5ae451cc2974ab32687d123f81472c42efb4c2ebc5f9e8be7950ec28075919523e2f8061fba1d6406ac30de3ed207fd186f2a0dd9b18e7307ab25346b7a82d7b4a8d0fd7761cca00f2d6d58ef6f474f900ab8bae80bc3902320e6c8d4e3a559e5a8d535de8fde3369bd7068b519b8279679f409b5af2ddeecea8d50856c3acdea0e3c62ffcff63a84265c539dd73f045fc16bdd5bf7bfc848db350259253304e8168fca772350465506781af2455dd3a9c7df8b78e0e1ad0978dc8dd41517785ede333e6fd441fccaa79134be03775fec22960ace9e2d40a052c222056b621da0369b3f0c28016b859dc5f7a70926a25b09631a86efc9df4fa6d660b7a547aa39bae3651f2d228b5f701756cb8955014a2c7dee899c0db71f42b125380aca85bb572a808f897797bbaceb1a94ce60c6934942d27f975f20cb78a4971a7e9586aaf3711dad77e66cf3f540fa11e604ba5a475d6db15f6494e5bfb8744e799dba8c8094a2d00a6725e09a1dfe102e157058a1c3f0543501faf7b43c04f1cd8af44f68c889d1c1529adf67d7475a1b8ad1d3cfb9756f3954c84e08bca2322f0edd8714fcddb2721439906898bd39f08bea859ee816e79dcdf83be752f212920c1d0c5a7aa29e040087094f321a4210a4212e506bd87ca2608cf96f0a28f8ef31a15b2f81c2576afd15bf972b7c150ee93564d4be45edba107c3a638b78df1111cbb9f1790bd4fcadac93ccda51e56698dd1baee7f2ee989eee4ea83d98b1b0f9a107e0808f2dc8691bffa77ac15c0e18f02ebec294e5b4b42dec6e69c89688148e282dc1ba6421dda40f2a888cbe42d0692b736c0d51fe57a2ede96d3e52040ea10f377e72b8024de172fc2ae494382b0dae1de46381305ac3283e27bff1f3e9fb89d2bc4420da0413988861ae2c38f6024faadedef0eb9cfba3cf3d71627e4a245a61f52e7ef7d20b34c3e33d0ceef809d203d1913dad402c51003c2c506e6670797b0efdb9d5be023b2aa6ccf9b37359a15b04804642e1d9922f784464d7732cfed76d20381a781c88540a708ca92507440583e134965928b5c1ee67fe45194796fc5e7a83008c15b1b1639275e00b2263d2386e9c567c1e900e6eb76d42c9c61cd43e4636fe0d2a577d30863a02d553c63f10cea62bc0f609d8ec1b08cca9e66dde2709ccc172462db17a880b0653eb585b9d7ab1e5177a11916b21689c798cd7c514277b6277f63fa0ea0203d03d0556195b44c2e00f18429636d63cdbf0bf881cb76030f288387cad96e6c2d2126dc90883b5afae53cd1d6e6b2eedcb308cf4666e2e59687d76c312269940bfbd6c1a539cc647c7497b779ff9c32f23e88cb28bf16ddb7a49160d730f82d49bcaa07acddb6c2a392fb7094b50bb8266ed6c2c84566fde1d7cde1790f8c7bbd0be650f9fec0cb63086704e523435c2372a5bf27e7e794aa668ccc8d4357473e29eb2acc4a4b9f3c87d8dfef8692a9feca14c76c2d39664a0bdd7c6f26c05c2be8304a2dee7fd79573eeddc0ffb7d522a1c2f2d5897b145eb5f403edc0fb87e56e04f3a471bd9b200c7877cf264a08a48bfa7066c9122881dc9b5913b2369c965af8e952c9f967dd6fcad945065c21fc1f4960e99f65fafc6278e828717c0882f2b93fc2d3eaa0bcac1e422e192a0af7552702e70a7eb15ff876cb4804fd02449394ac5761f0f3ff7ddf31322b80cfdf079e341dc686140e3df618021fb1b714bec4bce0fcf9c19997d3363db25bec3725ed0c77149b979894f20b4c368adfb50435f32c2bd0a0dee6a6430be282d091c866d8bae8ed4cef5e914e7fbb661c8f28e5308e2e84602d2cd41e25e22470a684a35c4ceba2ea30cf6890be1fc0c61761a90b958a1116a6d4bd8373034e64cdd5d0da6ea45b924359071919cf2975ea0b311eb85d06a1423a8c616c39b8a3c06c13910bdd7a8dd276308faf5254b1525dc007aaa21e255ec8076d5a7834e07dec3b0c612cdfcc7eacc5819c7913f46eb32c25dd01516bfeabfb9d0ba4fcf277c684316b626ed0faa384a08be1a2d62b247a937c21e423f355dbd12398b9ebcfe9d68c2cd1f0585e59ffc9e7ac93d93f8ae4e2ff4789753ca203c0d8e372b44f9fdd906438b34a27b9b961e1349fdc5acfa96624aaab53dac13758898b2caa574ab596a40243df56909c6c874dffece9a97177c15b895345079a894540ac00df15a344d7706c496b758467b5e5f7c66528050a285df075bff3199f5e584011d625006a43b427e9631893bb766557281ba6dc65a6ddb35311bfa35aafde27ee5de8ad4146d677df37d83934e9d22d2b4633ccaffbbfafa2b43bf6d2aa05ef01f3a25842613ff399d79732a1ea468a7ad6f4ea8775f1cfebae0d3513e5d4557e76b7597ce9e68c81682bfaae3aa0fd6511e493ecc85047cbf8427ac3a212fbaafb88b85c1761d17fc197a471a322168ef20aa959ffa3ab24c75e624a56147da12a7dfb3b668543f7148a54b35fc519343074a9bde0e68f1eaa6571a0f61bb65df507e62614e7e944ea210d4c0d4f1973f171723b9bf3e20b6e6417d9b0cf7e5b0699e1fb8219d1104af6aa120536c8403a58ab3b427af751e2381174553f35d0a2affc430c25d96c16330d7e2b52fa79ad64067b02e15e454e06594c69e5dccba3d62f744e8b8905e9601d329e4b914c356793616d7f1a339098d1ac46478342de4e0e25b410e93bd91da7d778bef3cfc869893449ce89031d4fe49334abad79d38a420e3c25b59d0a9bfe8edf389b5929cecd2e0cb18285be3046ecdad1627a4ba28ef809341977f1a8a3ecc70c35d7522891c0859875ddaf18795c037c80926459678184221f1c18ee4eec29b53a882e88e0dc92584484b163a0b39ed43d11ace3fac9b40637b9ef8335568b085dd10a9ea12770c34a3080529c2f4950a0a0c5abeea0bacfc3b93e43e44842c9fbf9cf38f5a90e1c467b2c9f1eadce19ea32ed2e4d66980de0837dd7ab9880d18384c65ca9239fda78128f80fe1538bae42d65eef8e2fe981a3c38d5b97228a9facc6edd131316e51d42b95be9923c2c64dc64100507abc72b81adfe338816f521126ffbe5b107529408406dd9caeac0a1a08ca9f767f83818365ef690962fc7a56a0fcf09f5b86a1bcd5b307f81c7edb2e0215edc71977cc9cfd46df08c0b926c2beb6cc7a793e2799f3e5ddfa16d9f22635624aff805913713aa34bc53e4e22eecbefe681a4dc44acf5996a9cf04eb7da05bd9ec91ca79273cf27c01ee4abc0552bc9db45cf972a18445fbdbebee0d867d1e8c3f25e4db4e481ba56865daba2cbf878faa0fa6a6bf56eddcac669cb9636499ceedb9d6eeb277381234305b69447c3fb81b7e989e108e7e3219d6d726c6722bbb1f92cdb4de5cb678abdec86de0945fa2e831638bbd14b206e33b3eb61ee5de681d28820bacf33e72ef2b96dec5de8b8bca39e105e392e8bcc936f3e1e819b9332400cebce088ed95acbd5f8340640ebf96a00c9733d3adc009e3cdf7c707b274ee04b0d2106f8dd2efa3b88384f9be3c50ad39366d7ea38e58441d1445f94d973445aecb3725e6a88d44bc92ec739154dc3610758d1c9f0661adb928ba268e88fe94c47b2b3e437a64fbec64675866587feba7393d827af335d0ad71018168c203f540a1128a9dddaf1e5e9497258c3a55505ef5e20c1ade7e8a058765462317802611521f8f6fec59a3a47e9deba3bba61c5f368dfdcec6a372f832072d2bfc43d4214d287912bd851fe0e250a1c577cfe22442b73fe46a7790d98ee64c6c846591b010532f85f659a07f5ef9e9c9de0e5f0072fb6947a62d11d0c08befaa58c74fac3c35925397389864c2e495d56293b539f8eb9d993559d5b92d6926a7cf61e7e49f3a7c02300dc28f09f94849cfb164a80cb2bccc7c46834f7fdc915acebb0a4e6684e40a264d19edab1b0a825c28ad037dfd83d7d9c009865e2e23bd02f366719056c5760020b4d4882713037d54528f88fb80df43972f82809e44fa650a41614eeb104ac86db5211212ee19a8aedc108e81c719849c1fa3bd240eb0b53eba4d76f023cba99eee04d46965fac31046e7e6b52f6259807966001f6cfc9eed6727725e2694bd48eb27d7c11cc0ddb6d06ccf0f515f147b6930d4f843c95453c9f9ff771489e7c16434e97d214d0caa99110cd1b23c4797261cf3c6601241b84530524f1f020f0a271b533cd02b4389d94d7d24f27edc0bd11f07b5dafdb914d5930dfb1a2989681d3df51287f3c47f1ebdb90da2019e684051a70ab77a682f4fcf0d0421373324790f6e338ffa091ed1f4c28118128bef5e30c444179109b54fe9da3ec31150f1fddce689f1055eea1c012895bc9c105d88b7b7149d4e9dd769e49bd3fff177cd48a76c9b6fa33aeddd99778f9c66828b5b56873d693e7b5492db1d2f5ba77cf629412b3316be731c509123fea8246c646dfc5d0326cec76b4b0c119f4ea8508b8dfa7fa3aa6886ec7bc081dbee2b8c7d2643fe771d85a94f684a6f390f5ce3af6a738917ff74fd18c4955ad9541feb2659c2ec3a118258174c4d5410f0b869495f47af401233b2dc1fe96b8a166197a12faaabf2fadc46e5dc31b67ea0ebbb48fcd8e7c2efa19231e33b9ccac97bdd9ddd65598035be74014caeb3a1d2737915b573673d1d1d226637acef6bbb6756a710a1837aadac948149644b14f1031232bb50bffd32a238654cd7f69d6c462ef1d5f640247c85805bff2edf54e23422b1021a8fefb4770d29b2ff02d4ebe4e50cfed1bf7b1db53d69f01a000d1463275918ffc36fa2ada4cca652cb6be18cf4b445b8efc48a4ca38a7e12b35aa70492f938a980c80a54fe5b8b94b835f1135e610a94889a492429ad04bbd5a71d88200e0c421fce2554fef9aaeeb13d88fb9e695fd26d70f32fde6c8928f68f76262c6486f82be0bf0f01f568eb4dd8ac8512cdd2541ce77df0599c72e60382fcfb351f61e1942d0f60579c7694282176e572e4718bf78157c547d29f88a83d7cbce82b6b8193c055222cc1e1e9a546c091600f5e732996ffcae22289230f723caea98a8c09ab8ea1cbf1d33327f1621420b9e5bc91804e9e097d92b56921f993a99c678eebe761b2a9306a2db963101a07eaf12966519ac694ec030ae93c88c89b3f873ce3f460d6f4b8e2340022238df82bca066f7cdb2f74768876ad0723e96aa396ce649691e7d5aeac13e807e71b39e27da8497d21d6c3dda4ff60ff726158fa61eca363b7e1dcf75104d2f04d7600ecd5ea0dc75b906f8bab0255a5db6fa5fe7337b5532d12464125fec53d52cac9cf9ea733b9a22e5eeb9d18d091c3c9232097a5a9d8b3206487cccf5b3e5b1720398208ee430c23e743353d1005f14bf3e645b4fdd67751e2aef15c62b9f6a5d1fb3553246800c3998f25f1ef9ec42ae0bae2e727f3953f0ec2f47cd506fb90ea7f05f5db1a8b7dd19c9d3bdf4a04b343f6180895885ec9dac703c987173e498530f95a64bd59fe1f271f32c1bee89f6135b29197ba7bbf0171d3fb65e84e20f28831a3e610ccd1e018e44febd90c9c0e76818c9f82eac6ded113cb4981ee494b2dfb0f12c7a3919795e1134ecef67b036e0dd24952531df8143f95f3840933f1d8487747f2b40f9e1579a9e9f141d08c5188d775ec60a8e10ab7f456064cb3338206de73a30752f3e122b43b628f4222ae5c904418d8b3fa35c73ef9a6e2414fad70030a22d0d3022de67fcde3037924130307c7c2db48976f14c9b31616892985a585a90aaef6566dde844cc4fdc8a302322c403b477be784b1c7e618f0bdba5a791a009bcee55bdb9a6da7e00640840c943654eefc6910e55344a3e546d0bc6b64bc6800725d613504d3363cf6bc8f7875d21b83067f2fbf81fbab296fd86b4d1d3ba016bea39fb441026c68dd59ec1b4add348a639770429c9508378a9c01ef4c91067cd7c0cdd82a85e14d2187af6bb3ac9b070d2dc560efc494e67a156edfc91756501bcaf59f85e5e853749ab13176b9327fff0190c001e25a56fc20b5d1094b19996537dad9330353c50d169292387855a9d9b124ea534e7746fb8eb63e9ea97fbb126a61fdccd23b8552af83df9d48de753f8a04d68482bbe2fdebc3c87be3f206df52fe61aff3f8c8f85964f0b17e7c6d1d17ffad701b05c3883597fffffd04a1c8934a57d327aa04edab69a8994cba2cf439fd49e074a6d7132c433441b38a365089760f7728d4f4c29828cf69955fdc4426cbbbcb66aa79e0007ed0f595c4e9c4534660bdfa056ae034614be559e20ef89181b16edc43225f57daf7cf9599bc4624103b4a96f0025fdf8111b30236abcbdb4e5ee7556dbf37c1bfbf1eb116ad7755817cb93a98dd2ed97192995483db3f37df5bf48fcdb3023b67e04ff2ae738f630bf88c873231eafe35a10590907b0dff6bf8e4eacd044e0452cb63c12f63e832eb93b6044a1fe81df41cf723edb239bb95cd8111ed9a10180629c77b4206beccda6dfb6234f0f9eff20b4600e221fffa6363346e6894b92513e0de78462ec35c9d4be020224592e795e332a355d3fa0dc24d1df88ed08cc6abd9a801375adef3ee70c1400efcba51e8a1f993f342499a6b4b9b62c182c896e58d7015b20927669b115bf571eb0c83ca296f2f75a2770cfd7cc693eea73847c3f7d80eb504764a6cb875bef815559304b7d4d91604723ecfd89cd79fcc430f80f58bf9169953c0715af774f57b774b5801c7fdaad5fbd997f0cf6a736aa7ea45920190a24fb6086fd36c1d6dcdd336f969957b48a11a90ee457436f7c78327852497c5baf6ba2b415d8da4dca42176d3e50b0783b966954578e4f8a65087c4a9aab1b3c10b8d682d327f7d4d04f03893657bcceb09be901f7c59d2235e6fd3ad81a3fc3defb9055c959f09bae4107392f8eeed3fedac125dbc7178de53c4610861f11ddf849bd4bd5bca0d594c2f657a2886f6b968149d808598b8529f4f17a9040121e13b09bf354ed61fc123453e7f3fe92956d661b85dee3afc8b450db3fbb646888201f4bb7436df89e76d9ae88d7d6b07e7a079713fb995d774d205d62d25fff333527e5f3ce6faffd7d506ef74fe4f698ff102d75ca705ec26e6e4c87eed0f8b08daafc98fb5f4b8da2a373354c182e10391cfecb24a72ee220fa5afcbac1370583b09f2213a1817203b4103d26313a9aac9357d8301c90576b9f24c8258ee8e88fb8b62db2a9df9663180f78c78c7138f5671562eeb26bc6500ee14ef4f4d971f1465e87c4bec5a4e5ce846c39cc6f0e64fb10261bbfff89515e147604b95f573bdeaa372293496449c14ff194b2a9571532c9fcdfafca52f86309955533d6599ea0358661b3ce2f0a30c0a7e0aae87993ebcd82532fc6e63d946425455d2b02517c047448460b41a4d8f66caafa23d21053f854638a9b6dfd756087f35ebf173b6fcc53e9d446f1ab84900d17112e60edcb83c8c46a438bd4bada7ad6d4fcb6809b2e57a2e593cecb21c39340d24cb120bec57ed965688921524f90caccc09891c39bee49e7e8c01c94d96eb6cc28752966c33757dd65724de5a2502e4d0db6a4a720d44093e73bf71371dfd51da37519ccdfa5039e46452d396d068f6f800175fdca5f3737f5d42a307ae8a2e6be2cbbb5934588114ab6559b79489dc2160af058d732748a259b165d254b6983224abe55c156bbf454cc36a14972c9e2b0d56b5dc6a9e5f55c4e12f56759c50367f692ea3546469faea238dd601b4e2341ecdbdf5d4f75ab471a2e4e1c919856f7a03624995d14b27cc57a423599aa040d027bcd6d40fe0ef14d8bca55cc546cc21a4a198a71861d4cc13ac7c881b58575dcbb1a44b307d79e493928a8d8a1fafa21acc7bdb37402a0eda0299a8b35f0b90b5f9a4c7ca6067fbb2d46ce2f01942195f87de306be64ead77601d81bd17e9b4dd2ea016db047b4f5d8e16be0227a1005aaa78cb190f5215a05a421839108efd6eccb9e548a06d2f5e5d4e689ee3b3da98c537847ee0056ea64d56f3ce833adee31e3ba88a562e0a2fe26780bedea959a47eb38cf5e64853e8bfb4da73a5f8bd659f9d279a1e9d915fc0150a6c37ad479494e05267c0b0d0ec07844cd7e3fc1f8595873ce5d3e630d56d0817831aef0f9ff7536a2e0a39baf551d1febc6c0f0e4efcb9a6f0cc24b1caa3ea93c33902ef62e79b5660ff19464e2fd4a0a75c1941f0ff40ecaac009e28b6fb75228d940b46b73505e1642a2dc3e72237033a5c261eb9faa2302c57f74b2f4a79dce385c2803c7e347f978bc71fe868116e28a074edf1c9a3f466762f77cfc0b3a2e4bf5495875d83f33a3197cdf646d0014875543b547e4fe09b43ee88d831cca8eb9fe97797d4a8ba44213a5ae595e32ccc1da7490910410335b924d48aa60a2dd723b69a743b768c031c1a817d6df66c2a8a41a6473f560f8ba350bdc732936fc842de396ae1772b9e41c8dcd31635fc5f47873489ceb56b994fa386f1f1c653dc96accd9305b8f07e0e652d1fd0ef63b4d1e014eb44929c8542199b147bd728384a549cded12841a4c8c3809450d84c497e51bcb44f9d6c3b4f608d99fcb2073330490316f8f7e9ab37eb33acc83b86a6311a0ddeb9df0a7c6b56cf4c218f6d590ea3cf8929d57e28cde7bc2b5032874f87652ba496ce9ea8fff9f9f97b38360593512aa1edc6269cf96204d97d59a3067d248ce5704a963e661d934397534712b83946e7782ec6a2b96ea832a05347e04a7d5e8467353193ea031c231c135dc5901767fd311515eab552761473aa0190d3000f4387f7892861d6519dcb08ef5ef7e9081101e61788bf3bdb811e736360f64b49d892a25ecdaaf8e5a52f5bfbd01799bd8537c6b7361ac9870932a1e03d8dce4043154906227e48ff68136abf01ebda9e77ce3f35c053b8e212997c1c367b03cf631a4fdcbd6098aedcede4635e8019fe65a3004ec1304c8be00b55e3868a2958521e23e31f7a5330cd5b658600c66dc8c67fe9319ede1299eba3e6d85d655123d2214230402cf2714bf9af1b23d4841bfa2340c83599853d163e8c28f86e9309c17ab08093f0ab3bdfec31515b5a0b8677d53e1c36016c21ca926060ae9d682c77a485d72a571bbd38ab3866fe5e15a0b5b9235a6616690d86b69c3958c92022e2c674b8a4bd0bf5aa4cbf70002038171f50149a91b8bbd89cf78716e58b269a80f8673c469470515c676cf36a88aacf1486f423a9534f3f0f7553531517437bfbdd78e8dda6aac79516b24183c3ac1ddf17e72d41c6f14317b45ff240e1c4afae772f2b350eb1193fc618023aafc9a56930932d88226a046d5bf4cc64d61ca0cfe4cdacf369fb7a72147992b0cbcac3a1efed2d760a4fc3fd4e72a962444f82292f0a19cd953819fdec3929fd99a9051d8fe0197d392bb29b1122540adf8aa6a22c58d44842f6633c0d23c7d46cfdfff8c4bd6cfe154d2de1cdec6f0b1a3cc851ca90a06b1ef126449d630b5b9db1e0e483521d5bc19f8711d19ea6a2003ff26477a85b3ec29f7c624af7c8443f116332fc298b63e815e9168ad441c41be89aa1f864cc27c00ae1f66b99751f156c56e5876537041f15b3235f0e27494f7615be6d26334b21e357425033cd148b9ffdfefa631a0f417cace31e42de6aa6af11e2717da6c7cfcdeb1767881bc8d10535ae45e2591ed045d38bf83689a5b6567c588244a356362f74db909975a5369146db8577a6c0d69e451f236790ec6ac77cbacb582cc55d7d972fac47d918a031d3ebab72fba34e86132ff828dc4c0353bd6acd062670f3d9ce34bc577db0c4b8d237184214ccc3c7d2b2288f349a5cb00fd73aeb1fcec258fbe36fdb15a079cc8b35341275856cc0b71074c3d17a93a264a79c59a9a08741f3e43656708cbe75d61f3d153536214d0224316d30922d1bee5ed801543be03924a3b157bfebcd7746d217e495df5eda6d9d8500a54b0de2d3336e91342284ec3d1971534edba2199b4c450799d12d8d0277f5b30b59cc7a9fef0d1d848e86329c16d7d11a3a048760edae6cef49e089fe4dcc88a1e66593e16a4047c03ecac8bd9f10af99b33932a74e70813e19a8c1bec3fb5e5db53aa1342d1da5bad66980a55ec8cc1b856cc857257028827158241e4b3a919d01cf9cd64954349824caf781acd2b53ffd3fdab6aa95479b0c6ed863772d24e33ccfa2bb14e1a5ef48123840841030eaba24bf8f3f8377e4214f5725aec2175972f11e2fa9eb793011705937f288ed97787385268be1cca4c4645aec58486f5f6465377d6428405af99b81b4b6857e5695c412d7dab2e0faa6ad9376f750303b118349c9b48a404a88bbc2e3c18cba303a4bd2999fa5a6adbdce572236a90410aed11205e660ff12a9429d250584e2d98582f6fb451ac20e1826be3d185cb483aa9e8ef25b59845831f9cfcac3619389f8c442804d1e285f6235bd6146a42dda779c3adf4dcd9785796e34c6012a891ec2f19d97dfed412febcdafc861e3010ad87881d72b466a6f3a09efd5da04e058129f399755fbe689908aa9c51ff4049fa471c62f0a1e1a7a2fad86bc6bbc024dfb91b3376a40c8deb0327e0004f3b4872aedb824c09f74015c37b9144321119d40d403533159fc28e557884e56906b83a3b952f348ecd2ec560a7ce3c8e9b387ae751df82aa2cdb9738c5cf7544a2492675c28b363d921a5d558197b59d13ee8c3563708257ebf2606cd3e89d38f3b612ad092a0464491565c13d19e98a7d76801bdef7c07d31f5cc5a8cc1620435e7f479ee1dfe85fe86e62510d0d1a20711b22eb2b2aac4bbf9bebf339ec27bb204de2119ae4d1f66bc1cc397ba1c5983da8e4e116e01e87c01a720f32545219bf9c4d04e020eb30204c95ea05bf514694cbe1f0ad2cdf146ad59efadef3633a18616cb67e4a2c2862b2baf9d0af3a9de3d6145c0109fc449a9fbfa27127de57b5f6f674b277d8e89c8b26dc19178b0de27f9cf5c73e4db92d4a8d826770ecb8b71f7780c4f54febe61543d7acfb0d11a6dba692906d81842d50a91c826a303a11bc6c809ea7336fe11bbe09b3fbc420e936d5b4add46217b182bb61f76fa837e18efbce50c159a22bf220f1be9652c2062b22f812769d3f763fd932e9500c1f7afb748fb05d461f3e88eef8ef8740b32d2cdf473377d1872486e7d0f4d08b8bfbf54cb59b4bab7fdf33c955268b15577788234ff7fdde1515e2099411dae82e29f92f559f46cedcb26fb3dae04ab888ea333eb45aec97f3765b830a02198f8d1b407f96818d14ff55f77236278715e76bf29fb7e99105ba31d713db34deddbe986679c3d68329562b637abf2ce141cb20b1ebdde8771b1517f01cee833fdb75a6f444740958fe0da461d2766fb058e9d772a894947c9074d1511e78ebac8d33f0b9f9f55e518da4025d840ce05d458ba1580621711190cd67f661cf0a36c2e0d66fef0cbecd16e5d7134bcea8f96bd89e78b73f5d1350d5f994b71bc81bd36587b9bd7425b82cc11bf1fea8fbf82cf3f4e60a2c0481322ea7036cbf0e471400315b68ff44ea9f0e2e7e182924fcdd59be7145ddce25a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不是哥们，你谁啊？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> C </tag>
            
            <tag> DV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本-delete_output</title>
      <link href="/2024/11/03/shell%E8%84%9A%E6%9C%AC-delete-output/"/>
      <url>/2024/11/03/shell%E8%84%9A%E6%9C%AC-delete-output/</url>
      
        <content type="html"><![CDATA[<blockquote><p>This script traverses the current directory and its subdirectories.<a><span id="more"></span></a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: ZLin</span></span><br><span class="line"><span class="comment"># Date: 2024-11-03</span></span><br><span class="line"><span class="comment"># Description: This script traverses the current directory and its subdirectories,</span></span><br><span class="line"><span class="comment">#              searching for directories that end with &#x27;test&#x27;. If found, it deletes</span></span><br><span class="line"><span class="comment">#              the &#x27;output&#x27; directory within those &#x27;test&#x27; directories, if it exists</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to traverse directories</span></span><br><span class="line"><span class="function"><span class="title">traverse</span></span>() &#123;</span><br><span class="line">  <span class="comment"># Loop through all items in the current directory</span></span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>/*; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Check if the item is a directory</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$item</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># Check if the directory name ends with &#x27;test&#x27;</span></span><br><span class="line">      <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$item</span>&quot;</span>)</span>&quot;</span> == *<span class="built_in">test</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Entering directory: <span class="variable">$item</span>&quot;</span></span><br><span class="line">        <span class="comment"># Check if &#x27;output&#x27; directory exists, then delete it</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$item</span>/output&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;Deleting output directory in: <span class="variable">$item</span>&quot;</span></span><br><span class="line">          <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$item</span>/output&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      <span class="comment"># Recursively traverse subdirectories</span></span><br><span class="line">      traverse <span class="string">&quot;<span class="variable">$item</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start traversing from the current directory</span></span><br><span class="line">traverse <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>editorconfig</title>
      <link href="/2024/11/03/editorconfig/"/>
      <url>/2024/11/03/editorconfig/</url>
      
        <content type="html"><![CDATA[<blockquote><p>EditorConfig file for github <a><span id="more"></span></a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">top-most EditorConfig file</span></span><br><span class="line">root = true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">all files</span></span><br><span class="line">[*]</span><br><span class="line">indent_style = tab</span><br><span class="line">indent_size = 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本-check_process</title>
      <link href="/2024/11/03/Shell%E8%84%9A%E6%9C%AC-check_process/"/>
      <url>/2024/11/03/Shell%E8%84%9A%E6%9C%AC-check_process/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9cf873942620fa4ebb1cdb4f2a08fab0b2047b05cd5c32502e3ba72f37ce0dd3">bc784a9a828376686ad79bc9be5654d3a22b15b1afeb54116cf6fd646f3f269e0adbf41c9a58fae7cceb635ffeacd251950c08839941532676c31774c06305b07dc61c079b8fe4082797c91eb5686b8958f960be5521fbefd802b3cebeb26d8016124a6b2b012342b66d7b83fe8d5b360747491f3287c61981c927c7ce207d02a2f5edbafbab10081c9b384ce716e15cbc49c19af6dda3731c39aeeabee900a2de265329cd129072ee0e645c6f342048437d102f0382c5ec6ec868f503f0d051d16ecceb359ddf97e0e258dd7b8dfd8dacf640e94a7a4208a5071c90745e02ff61793187fef52dc3a903dbf60acb3977f4782b1dd31c5ad005b0f24538fd0b93a609bd401085cc8120f2fa066f9f81ff807f275573b4e7d426455249ea99ef491544a177b09c689f17ee1fc95775b92aba0ec2de223edfcb24ca24f85bc0c8d123106a750eb92f8ccbebaeb6af226706e5b0b796b7ba1a6f539982c223d23daba7a8940099cf7e2f7ae90704bbf6fb432abaf15ec215fa3f63d963059a3bfd641a6574a0607949752ee2e5b6f88a365fe01dd8e921a95e4b699bb5278ba3a2832a2c45d3c804a2aca98ffe367ffb7655689ac2caa047498fd841945cfd1395e16c05b1d7868f3617a0844525be764b4ee94808a80d0f1b6f1801032d0780a6b5fbcd5ecd3019ed760ea46fe19b36f00e56141b1a436fb5298c5d9d93f317eff2e6f6ff81ab7c60f99adf73e10e3438355f74a57d65983640682f67958970efa4ca7c5958c2965d451e1f579b761c7e8fd70599d0506e8329d28eb246e7a2c3db20091f7b9ff028c507537b0fd5a801da8b87a11ee30a13074c284bd2359f4d1a5dc6a4d0faf2555accd9ad6763b078bdb663c64643a9d42def460b3b31d8316763d9f96ca0e2e4fae541c5c5d3c7cb9a1957e9a21c14964dc1d340462ee1931623d78e784db110ccc6ea5a5ce3e53d26903ed7bebf5cec6c237a7d476dbffb6a6e6e93d7f8249bb706278ac19627832fec0e08cc0f6b49ed161f181b1824f48b93ee5dacc612ebfa24db12111c3474483c661749f53215e79317a5dca15be255efb02fbc336affaeb29f460c7672356a11eec25e46d20a8bdb555695f9b3e45b9237e43b103857206b47a4f3aec9214c067507b5f2db9ed9fc94c5ddee6e1ce898f819b9ad2e62f216ce6e92c8bc603908cf0ad6b6cd83debc6ef0a525fc9d6081d598ddacbae33575e0ee7a9527b299c98a0580cd7e6557f8f64115b53fa8f478910c8276295ec176f5a61a88bf1f5c7c644c4fd9fc991e6fada541081e1fbe3c6c8aa7e59141961e28545574c7b6d9af7418bf96bba6f418f56228ae81f4979bdbcb8b913473fd018ac424819ff42180e6219a3c71de954b4d3276926134920135f626d710ddbd76be7682ce06915a4e80069021d6c1e7b1fc939f8b70514867c76342037e08cb1a7a5680e21bd692af8c3b94e605d25c831911ab5459c77ba4d75a99fe6255596a8fec592a671d42f88e3b5ba7bbc565ad06eec4c22a4add83d3fd21344dce71b4de061c175499afe273890277707bea6a2dc6f1823e58d816ec636c8fb89f84e913efb417225475911aff7faf5fd2fd252fb556fa36b1566af1a546595043109366f2437b015c396d728e385d558006fe6c5683d6e71012dd4d5c8f17938c10b2524465e107aad8368e30c948c8c962d3e3d2c1f8a148b561f39ad2d429ff2c23cb5be33529bf71a3febb6340ae210aa277144cfc04b213fd50ef147155aa472680e74f112865086e171949fc62866e8623b2cd91853d84d06e4317122fd4b4378205ed17699927724e09853969ae2c727df98625ccc35897c2454435dee0bc9b9d74e0a24339433fb1a302da83420424648d7059b1e7f96e9323a6476ce22c7ea5692f2cd511270e21838aad66bde97578ba86d607ab08e3dd24018b1eace989b2b3d0d741b1d26aef1f9b5df65b0358c23e36b0f8d297c299a752beaa75206b28630d771ef91a5af6cc9146811d84416f801be265b1f1f5a7f397de02eb4f1bfa8010922e734981b1139b3efaa5698dad0f0dc1dee04a1857dbef6ee728a92971fd34c18539ef241b6d1101bc541fc42c84ef7fad8ae05f17b3651ae6b179d482535ffe331f41ca2e3d6d1efdbd58dbaeabd976b27a0baf89200bbc4a839ceadbf875848a8dc5b530e9aaedf5a992a9c11426f7eb1004ff2806f3622ba60870a6b203cac9b46f16e77b44263b347c62e950c7f3ad9635ce2147ec7b3d25fbc0f0f6f543e27216328b95f0053271080eb0ac9ddd8da1ba5ea976f1eeb28ad60becc3b26cd6279587dc054cf13658d5c0ff56137b2a50df02210d20a6e0dd078a25b2f09afe196ba932a6c70fcd3244ef2af44bbb2037ec6c283c35e086952b23cb6b9a13797573955dbb68e38a67af1de6d0c79172c25a33d91e3b5ab21b64c806dcc4c9bd8f6e518944f891c46c74235d35cde69a40e3507ff408755f03591075ccedf8dc2dae87a03c44ae99e0fc7ee4eb79b2e36fde75d3fd05c8dd0e90f2221d9c06d0c718a48aa602f5cf3b97a85ce303eecf4b18929c2759ddc8eeaf4833f19525a4286a186e1d032e35858694629620b5fc0ffaac0d016ecc0b2d739073ac7363566c3a411ff00e409460931b849343d81fa261e53f5e530b4816d0e64b8cbf4babad84963be7c7adb203d7f89205742e3a5472ae5d6120a3f2ca9adb884b7a73761b1a555ad9469151cf5ac3f5fdcd2458adbc5d3933b0c2f1c3c22c1285e959ac5451dab18e759d68f1ba9f54501f6226d64d860c22e78b0e2e921a32b7b41c654992c7dc5b949240f2bc7d6130fb3f11cc652a1f1a29ebd80d2807ffd5e86a3dd1e78a6b922096f51784e869276a4340d336dfeadb7b61235de239c1f303622829d706d851c2767ad420948e54c3686584f0286dc7ae80ddd1bf510ed75819701fd7a2b06ee6002b94136f59981df63ee0469ebe25524030c6ae9a4e86bc39e0d946911bd4c83fc2610ffb3aa7f14fbcabdba742b15148e0b42acb3abcaa68d3717e257f468334f64dbd9d001a57f20a5b0735a7f1f9fd9cbfc910aad5528283b7d0077cbe69f31522d333e77a70359b626952fe0a259a2090d1e04c35ba390e3ae12974793d1dffa1968afdfd963f39f97aba292a1c829587ad13d61d15c47d574a2787bd910add91f14314d4096aea2590b7bb87482266fbaad4ba136c8636e5777c4b8eea0e7fd23de3ce05d52e52661aefa65c3b6ebcd3d52c1e616771059a948529ffc22a1b0ec0689b00e27ec7f89038c7e44045217dd3fc5c06864b8a044264e9f4acf5174f077d79ca05d543f67edfa48da3f80fd8fa9aa384e3364a3e7b44b10868981fb6ed1eefa4a747c8ed4796efbb509e33b16baa17286b66747be4f81155128049ce7f7b908d83b4dfe3d2f3e830e169e39f0db6b027cc6d06099e99e7b60514dad067e4a7736d56e45d4d5b0a9bd10af7f985a4c346c13aed948335c5ca08080195d4fd6bd9ed9a9c979e2ca2d662e4b90fa584e4c2bec39501544257c7b5120384df3d37c434b1d340bea701a7b1e12860c690c4aa19e4f63c9fc89c719db5c501d858e649bb6dd4650c766b1527a39a32c8209a312e6b51503fc94f5a0c70df4b6b3a04bfadb3a62ba23407e51f1a713dcff04b350adc6356e19b9f252a4fdd5066ab870854a410a5181ce62a1ab2aa8f6f54c914abd660bd607dc480b99ce2b30380918add1458a0aa265f8123a3555e74a18c475b32c3e4357b0cbda36e14bd67b4ab5231f83f510c45a6a768b1f07c35dab014f633a5cd64313ac736e2920bfbdda5e8367e5bf14bd263dbcf47eb32b85f03942d1c124fc472df463174c3e3cd9b9010180697461bd28cbfbc93a569a5e21b2724f38efb3e9f193d5aacb4a30e6e8ce67c20de46f145ed25414d68a5ac34078d525552ba42f263ef7a59a7569b9ababfa46512355ae8c84756cee598de96ebea805961d6446c58539ebc85126947a077ab32fe60f99387f985aa35198b42b91e92400591a76af81a5f4fc6fded1c3d02e18acf2d201c6952855bff20523b1eb5b0596208e971b66829aa1ceca551d91d4c29ce0bf828573f213fd78c4fa77b18bc9575cedc5cc546d4b7627037673e228b9ae9e964d5cdbec85f0e13c4359ae7f8a4468146aa25f17be09b1f75593efa4221402a0b006053d72e6837107aed432e4652389149fbaf1f44e8d3386ba06f88a5e79dd4a04d86741289fe372f2ec6b38501291d7b2a5403b7f56aafa281ebb627ea9f31e8f9e4bf5cef933a8eed7ff56453881d3bec8778fd26bdde343e2d7081a2a8634c1dcfab1d95ee5b7bfbdeeff03916b8a8abcabdb92c87cfa214f095049ecba073d6ce27ee33afc292d79674671af58a9a3a552c3756f9667ef27e3c8b245cf992ace68a396729ba2a120e280cfb8ef9233835edad4559743a76c04a388754d9d07128a73c0134fb8ea204939cb7b70933990cd425cedcb8a919d648043c411362cdc98bc6ef7937dc640f95b7319e34ce019d93fc0cb2fa71429b6e33ef28486adfae5e9685804c5af132e16e02768486af8675bb06eefc0d8500949203e0dc796500dd1c3faff158655e6923fb2dfdfce9a5472e947c416e13316597552fef4427ef405ee72b52296bcc9937d97294f848dbbb9d3dae612225445d1b33fae99a5f4f18f75dd60a14338eb028569363a4d18ca49ae29271695b66d651c0e5cce84be6cc5b8b2f046595fd27b6c33a647623250f1cd55a21dd8c5a015250b6609c433db23b6022a6ccde3811908a8e8e9d28bfd83e9c10cadbb05792bd4c6899ddad01e5e18bb169fb3e4de22e923521e1e0504a81a6036cf48fb2253596fecdae372302e312d13101cfb4a69bc358666389560abb9147fe5a664eba82ba24b4baa7240eb72169e380bd27b254992cb497bb893ff5c87bf7d18951df0f9014a362cf442baf0af7be3e1215b677e406a21fde683555327b6eab7838fd0ee2c8e1592ff279214acdf38afc0450eba1785956fec6e2b4456834e90b7ad4cb2a3bbe935a38f95bfc96b4145282a0e3985c0eb79dd91deaa3e4482432f131195d6313bb5069d2180d679b4c186a523c2a5e3a074a732ed79876d6fc1a9a67d1136adc717140626306b30ccc6d2f7ccf31de4bb0b749b29502a6a52dd392f69242c5da3f597a593847de45080a3cf5d9213b4105e2006c5e02703e8f02a91c2737b19c74d11b7dd2253bafe0dd8d24fd8fcc0b54f2694efae1465bb7f0091d78457d30e55dac4bc826b5125a58a7e56fca2e5d2c2226e82642cf7e6f39ccd638839d7c6c4dd213c13f5e77c4832c0038587f633f594cf7f50c3bb96727eda63475409d45e0304dad8af95044fed38e953a2932fa12c36cd2e75f52616389b1efd34cc2bb256262d4230acfaf2f8f2856ca31dfdfea5151423e42bb378d1ef04086dd01466cf5ea7ab5094ae59999a99c62aaca1ee09168a39bf293cdd4efdb8415fa3d952669b557490b41c650fb3f43048f8ba9493007d89538fa247d8f1e9286928cf23e690e87a909270e03f960f3d8df7e9a7c866d6c589780a36dc511f6d7625e2215ffec6b029a8fa083ec962e78c4b374fcb59e839b59bdb6ba0df9e723f5e68f493eed863a754afaa20bad381dd06c7dd46f556ae79b6aa1417d5216b75873c3c0074874bdf77e1dd81dc75c0917a5527d741380e39ba7d11c2ffedb68d32e683bc4e06d4abc7e4abf5d5de0f7915c6637e06f7e90a0fc7b7955bc3db3336e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不是哥们，你谁啊？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python脚本-replace_script</title>
      <link href="/2024/11/02/Python%E8%84%9A%E6%9C%AC-replace_script/"/>
      <url>/2024/11/02/Python%E8%84%9A%E6%9C%AC-replace_script/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e3f3debe155ab7fe8eb7ee619d05d9074c71a8ac7ce9e4eeeac1918cc93abbe5">bc784a9a828376686ad79bc9be5654d375c1b1a7918f88d63999cfcd832bf8aa3931eda224e47faac92cb32e39b69d03ec3aad5397e049614dd25b084cf84f7ca8c2e304e5aaa2f037e5cfb00e4093b81755ca9a53157387f837c50029837685029851bbbf5d6f79e19b032db1ece2750906de61bd292c5993bb91090db3987b5882abf36d5d2a727209d339e3228830ba0017dcbc62669a079b709858da11a0ea3adf3cca38b0f6bbc192c50d8be27d30b423294ab5ff9f09b33b6f932275541f30e5a6ccd04abb93f0d5c3857b7097e93e9d338796866f631f87fdf340821cdbba4b584d867105f714f225ff5fd7af1e5292938b5d25b3b6dd95de7fa300b1845c460b5126c016e1fb93b1d8b30c9c14572d9e140034fb470ba3e429aaa940d40c9734251e9f14348ec5368cb1854e5b6e1dc61c68ebeeb82132e39465f3830f8f4a3ba7fb3162f207c4288953b046a2bb0833c3feb9289add5c4028f1751ad011e564bd8a5bc3ae8171317e099f6f20be694367b42bee187bc9614a65a116c0a6e2e2225b584946f32dc6f6b5d4dd9db298163c6e5360fe6047c69b96d1cb0d70990531a30b29e8cec16bb93fe24524d028590c1da4f159ba6ec5df545e9770aca4a39150f55d97788536a70d45cddd73496a4d6ffc85a6ca45d3ccdfdf7b08c807300749a6cfca6d66c1c76ae27ea17610a32cba4fa2941ada04cd9b2446282d669a78fe784101348885a34ea2f42dc3f6ff5d6b6f212cd2dc839661dffe981a48e4ff8c66c66a6acdafdac74e1a245899013f7f3c3f84ff4a286b5e28166d3fcbcfe419db4d1000aca9160c6facaac84ad9faba5a46594d2513b0d4e4ada42f1991f1b504f952880c2cc1495d134c7ebc0e84cf61b3bc674aa76971e56fb67d7fa2039bf2c7c81185983ec084f1582ee305145b209d953e199b434c39100908221ca368eedaa2faf0f56264f2545744723cf2374dc40ff35c5cdae998b7b2c921621532148fe07a078619eee8e2204a21fc4158a76d6c0025f9988d9dacba57e8770f6035d6a5865206b9f4303e3af3739bee3c84442f6cd588f8e6d12df64d5245f3e0e44375e9105eacd912975aaac5c92ef099cb230999cce95e41191a949e9ca2765bead3c40d8083731f4c50a2d841c437614a2361c903214e39358ca9da6491bf6af18e2c1b32b6672153ac5fc590fb1cfba6e407f5613f1bc1dc5616f90a238824eee0f78387516fae514038b94910cefe1a55e7838a127178271ef7a444dc8064abcbdf39be3eaf81e0cadc4d1b27df846b8b6d50b7d2ac2107e9877034e2c6ea5c0a71d35f41165788fd2d25f558c5845647c79fac3a81f67d7a9a455cb153990bae7a833010bdca8e371e825f6f134bd6ee38f074a25e6068eaca8e2111a485d6a9da594eb61ef79e323d687252fc862efdd2821c1c6d733ad93f75c92bb10786b8c43e38a348f8b28e1159a6eddc3de918cafec53263dbbaa5a91a543df6913362745e4bdaa87a3897b47885bec4bb7e19f52eb535350ad862b53d4aac9f2c096048257dae23499a922b08a9cec7056d741191691e5dd0bd5cfebaf506642efa237c7b71fd2ce37b52120e58797226936ef1ec8d343a1aaa7eb1737dc58cbf42e7bcae5e2e2cb738f843cdb1272e7e739a3ffd432df85d929c4fc12960d608acd90262b8f7e1d4fd56aa01f046cf60d8f6edf149b74180d0ccf238fefc329824596c04a97e10688c1960e71edd6887fd44cf5df0541c7f3984e46264a391bfaa7c1ef87c4b7b7241c396f3540c12ca9fb488f6596e632ed9b3d423622739c29fb58853951ac35e6300f78474b174cd03af0143b7a51f2f9c27fa0dd7a961e0e0b9a379e1fc21e984d751ff7092b6f5d1812ac7486f647e7a3bc5ef379816da3a266ff8b58e9e89e9ca2c4d07349dceb92972d7c8cc28d86ee9a0c8f7e1dafeae182a938716ae4d4813a76ab42f39dee74a6781acd8a4365a5eb07b61f1ddfb6020130b89c5098e2d56406db87b266755e8579cfcf740839424daa0fa677e53ec2c53054d620dd4cb9baecde08ca737c14c85b5e5f69bc038b057706ef540ab63aaee767ff4488883ecfb59d9ff1ea0d3302833bbfbe228d1fa7744e976352cd33c169475577f1979bdfde31f6162c1eb16aa44663911396a167516822f713bd288266f51619a8e0225bc0e683443e638f8f8a067bd34effb1bf3808a21ef0c9f1ee6b96a5619cf62e8fe1cde2ddf7e3376c4c08bbf9b04ad15246be1b9c14a7c7511e16dd226298869b3fa3911e6c5da4af3f62cfa835028b2c7e369f59f2ae14d7ff3a61da5f83156c98690387b8f8fbf51578c211675ba06262af31da61e217070448e4428b96821017ede6d4fc50b7b768d144fde9cdd402b14d6d838a7b7d69853d3d5bcc03acbd2c0016c101b19039e32df818e910c2fa4c7fe6aec720ab4fc22a1bcaae225ea6477300d915db0415c7b2d0235824fc13b3de80688f2fc6db1c2f56a87488a2c4629dd49517d82c52e14b6fe865376dc63476ea62149c60e0dd9e1fd8928f5f784aadd1b42da1c2d73db00fd8acab8555291c0ac4cf2a8b2b0614e8f30b888e8fb6c42c36fa2707351bbf8fc24ab48a9b2a8997fe2ba2d9f56a4937484d141ae9536b831d21397dc17b5742b7188b1ee79d9018ca5d6a6845924249cd9c39aa47a2230864667e08268f6b4ec790bcdd16d5a04acad54c584a4b3a69981d36446741b105e6b223b90cbc0937a541bebf1ab688bca054cd86ee4b20506a9ec6393680f2c03ee65a4795a11fac0406905eaaf653affc0aaf7d40123382717dc8853ad0c45a86d4ed01feeca43f6a5ca6bf0a8fd065bf0c1ab3417e3163d5e060f56910d2e90079d7c23785803ebcd11cacb7a3a8fc7aaa68e4dbab29da6343cfb3f1b72a81b73e5549b39cb1839c782d19c4274ec62d0e40971e46925af8025d3eb30c4c2f85dc49508f84666edc8d2d4e55c4796be78c2b59842059d02ba2252f00a2d529bd5c936faaceaf050ce66677b8e37d553a3013b209500b4125bd6a8f4cbe80dde3064c18c74c530e2ac1505db997ce12bb947a6195b32d4b50d7f14d27e11c1e18ee8f5fddf60bea50b03f33c90de11dd13a1e36f02341ab5da7654c647fd64acdbdf961678e6967a4c32d565a5c306520d868d52f394d40bbab48facf2c3fc2c48e5bbc65efa93661156a7f1135f892a74b4a117ec5d9281e71c24ccb10d028e8e2cb8aed7830820ed170c02ac4706aec3344ad346f2be1bf5bb79f5f4376f2df944e63d42764d5f0d0585b038ce2be08673337200b30c8c86502607547102f0c46f5b543c0bccb5a1ba266dfc8528fe6c9aa7f39363f20e7e940a24f8602d92610920dca5b40759fbb0c7d8ac507b8e798979c5642da3a9ad0e89cfe25ba5fccccf45066826b2f27fbac86776fcb186576129d7ba42bbe16278a998939d0b5233d2e97bd72b03a95cc55e2eee26df3f84cd60a03194ca8d15ed87fdd118f9983d1e6cfc7a8a88e9c2908775970bd8b45f61560a5c973d4fc42f456a3fc315c7a4f6cdb16a27d375bfc2288ab56ef95e98c457246b2226ed369bf4c6278a2085f830ea02c3f68003c44a1bf7c068ba75902b7fcc44651a038ca21352a7795ee681be7497a999f9d0eb8f832f8802fdc002ab44bc365b47e6267fe38bd9f47b7e6d06f71310babc799a21ec90b9df514f67e7a35f2eeee06c051acc0b045fd5d12f1035581912849cb97190ff151e19b3a3a733e009d99adac2e64b650f73f14bea8551da4cf757b1b300afd723b1c3d3d1cf7e267833f88e11c9353f855b8527d9d6c5a44b6e16d01670f3ad8f9d2ba4cafd875dd64a756dcf1830fe80d04f8d799a6277c01bbd8d996746bb079857d08c7584e01c4e01e8d6882ccd9c4fdb7bef90784dd84a8963138e16d1a55184acfe4ce7c15317d413fbf65fb0d77b8a12e93ee6af5ad0fdf9e8a19686a54527185f8681f91fd6945fdefe11bb4900e79060916779fbbd758f60cd5357c67211b5d8036854dfc57ab56fb18dcc0a1f245691ebddabcbb31fd514ff49602b9592fa253147a0020d7bf6d294a8bd8e5d15c78c101095af3f4a73eb0da46c38255d15433bf16d1b57250768db407b17b7bcef998ab0f72fd8eb269bb4bceebe2a1da8cdb21838c9001dcd1efe439cf968debae0d87e7c8b38ae19df2805ce71f3bd372152dfdda9a64f673afaa5a82483a5c4bb51f167badabe07149f37c263e7cc2f22b5cf9c7b34455736ae35d15846722b47afe2a45f315e90103368b40dccef4a2863fb1410504d87325c1939a93859c6dc9c9eeddceb7721ef2f485fc29692ac6e20e58273612657915eda68c748ffadaf60c60a943fff34d582c8cc791d79ae66e0c3a105f578ad1b4d4f02fd3e294058964f09a64b51cfeb11ee8d1a5a634f3cfeb96d6876f7b5cef0860e6a6005b2f794941ab2336e3a76586723367336e44eb6b21f51bb65feb0ea056dbd09002b49831d213dd7eb40dbaa439d1e654d4d21caff19b8eebb7a8a607297e3f2eeda0bec81c40f7be1233fa116eb244ef04b45e5c3b929968a99210dc70afceb6fa1987e2260097d057f56193a70d7692a29505a85508663413cabfb30b6a2b2c72a895d18a7d35088ccc5c72a675b15282ec0c1dad6c1a113256bc279eaaf0e97b4cfac4e2d216c6fa272d34fc016a0a1db536f9d77498fe5cac722ba55fb79a1c65b91087e5e471b414336cf0ad033e5d07b32b8c59b1cdfe94be09c6a6b525e0aaa8645cd61294c60b273f5ea5f48d9145764dcb2ab8eaf02d5caa2b2e3072918cef324e1f1892268679a05f12e9007bc12548cb52d2956a05322fbc04af588dba31cf5583d0274795d7a93f3a989e38e93074368b827e9ab3d1bbdaff79d7d8da686f4b2c2449f645472e82b872a53fa7597be0fc326c35dab414f39641fc721dc9ec0cf7214b10af102d787348aa06e5fd68c085cb6b62a3a78eec2c691b2b24c9f7cc842c29198748f45c7b5ba3792cd7bc554486139587b5a0ba6670b2220f074c5b70a94dbaa755b63a733013a5ce47180b1164abdb4a342198e2017f216503de9cc8f93b0864d71978ac5e6120484c1b74bc455d6a6721b281280267fd20684f1fc8917196db575a90355bb552e8b0cf5a18a9192f9af29ecb1b7f3f13fd7dba4cec63f7e94dd34b67cf7b8366beb9cabbe48e3862d1d13ce65b40c7c976f86139b388babe175d6d038fd8cb7da1aa05360d78bcb7d7f431c41e440bb70f078942d555f00d52acf7378e3620efebef6f47c2e3210ab9a494ee06a9cd5e52cd19127e7ce175cff4dcbb78074d3347a0bf0f1e5531628303442174fc376b6965a8b3c268f6961a06f54570718301e8546e48198efffebae716d678877fbe6ee05fa9a9d0e19795f71554e4a17ac7ed020035454325377bf07dd077d5450cb98d26c0ec35d7174e25da7ff8021b698d941c825f75e6808a8bbbffdadd0c0a5bcb67b348ffb607368f62a1682c342909955ca318ec57e5cc4589e0942fc29392d8afd6de629d36d61b59e1ea35934e38d95db8da95f1668341d1ad90883f309383d566e3fb057e4ba7b182d61c663390b899abc50f628d092da07ed23f8c85c4e258967efa685d58887233e732f430dbc8c9dc05c506f14fdb4196d4958862412cab554d62f807a40a0edaac67548cfcf0c98dd1162251a106cbf7940f30e06c1354c6d211c023ec544710b218bafdbc3fbb30f997f2e1ca52779ffc28c7250a77f958b32aca14fc69ca79519fc4dcf1d1dcac14028fbc5b56dd27740af80af02f48ae3c3af99fc5bcd5b1de1bd42d396b3ba2b69f62200e29052f07faa0209ab500998f8b75185fc9a9ec8b0177063d28010665ffd3e17a17a452b6985471c68b0b970bd6dbf7021e6eafffe0b30a38b7a1a0a4ee708559778fd20fa6bc3485b5174e09c9c6f2bcaf4e1bdf30e9634325fa8ad69b2a4dba2f4c2c47712692a94f45f67d609c8dd268e09efea150993ec2a3eb478aecb0474c7f135b320e75bee07832dc622907454500fb98ecb04606752bfc2dd50e968fa13fc159ab10c76cdbc8d76996377c115e9ca486255abae4af674e986d9e6a47f4f8c91e6b8003e7fa50584efdb5dcbbeb64c33061e2ea975203d8d3841f19eb5c0e67893ce26a059b2197478e363f0fc36e6fdd6eb8e8af1353fa1a6a47309859696cf1960282e7b6a18d20998dcb7e3ed96987a6bc4e07269aa3cb0173ae1e535439b927a5cc45fd4e89d40f13f07ab4a19bb0ba80658b99f1f801de1253e2019771d001f650292f7915060ad80e43bbf9c6fdfbceafb3f035ba229f0696a0a5f7909e7cf9793551020f451d4db40839b7d59105bffc0e367d429db080663fc832e713bb1ee6a52e65ccd0b44a835265c83217288eb1d9ce5d13fbdbbb9525effd27d03db475e64dea6015a6d0b4b30c665338841bed196030383fad30bf264da2988465b82b4f11497e501d849892a4e58bc527e8663e0fe739bb720c132e6b08d94e93cf83b6d39824c47cff833cdb3d6c4c0307b9177337e20436afcfdeb31bb52461464a72c2ad20d536b63c520e8b5caec9b5b9f179f76447c03c4dbc97ed9273ce7434eb0c5f62c7c6380372c80ea3568bf41688c2fc90ae53503c1faaac2fae71f8e4894e4f521e5b51b0acd9a6a8ef270a2a6e3d06de6f8a278ba5cdc6e071690348f846a66aa3cad728463828fb00f7f794a64c6220c487ea2712ad794330792ccbf790b4b1cd6a2be723692dea7aefad69dd1f2b651d4977b1766e985606c5256057e602917665e09cbc83ca2e80588d164edf8cac7ea69b8e6ba34fd4705bb7affb53c7843ca534639ff89782f7cf1be7d4f6740f7f3043f6c81d61c1d80d71a3bfb0342f5bf6f52f3d13cf082c7e54cd8dd4f1e9450f51e0776aa4468f61eff06b7c1eeca1c2ecded9d79c551ec6d7a2597dab4bfcc0ba1779021ad3ed744d93182a13798822ea567ed28ddefa5c4494dcee53951958b903bb5ecd9fbcd43479a8e26cad223e31fe1064ba7565fbdd58af1184c3e49eb0a8492ccaf738f8afddf8989134896cb1b114b0106732d224e409001a010e99aa69fba8fc5c37229169f95212b6c294ef814bac240ce2af7511c28171a945bda221b212b32fd3754044d50d77892139bf4d6a02e71a46d377171630d48e114eebc46fb9a65c258de43c137543b0fad93e1797c876b373043c027755587262f73ce4e575216a1bd604c1d01b013089f826c4bfb91a7a5a79b794eb662629e523dfcc8f8b10e7bd3de7cc6386c2dfede09b88f87a285e1e7e505bc9ab4ac2e950ce223bdb7b89e8a3eb19fff19838435ba14b39ce356721244d914c549fbbada3b7eed57f9c47627ee9970b068a948de93b3e849167923050dea9367f93e04c00adf314403a2550771c1d139af5c233c7ce9658aa409609547f09dc68a976c2fb689ef0170be48d20d6bb29639bcdb7068bb43935e8d6eb9ef292a90a49ecf80acd2922899bbc184b7c2fface8ddfe1fe1f64625f205055fb266fcd9b5167fe9ea8a868f784e9b1dcc9a640c094717a0f523d8212d866e881c8369f6d6b8b865ac9e0d80d1063d5f5e14cbd04c97022435c8f9b3ca460d3200ef8584e0821e94fe149c3fcf84ee71c748cd2356528dae0792c26514dbf4795129e4ea6b32522b70f113135b2daae53cba4c322c73df7a428e2216db82f05ce876def36ee24dcbe223c2a03e8f5b704c8f96827a1d4254ea4c116d2eee9ac4e17d82c3f653beb812aa9b6ccdc7d236c422af5ba226b539473f27e326f002ccfb629a55c39eb7926d88de6a4f268b2a71a3c27d6e7e1705f51706f0e805c38940f0506dbc6e48e7acc4c4370cd62dc44dce581bdd7021ceb04ef223d45e4fed929e1ce44e0432fc8d81f7fbea14f1d3a0bc097cb0540dfb4db774109fb26e47eafde301a0ac4bcd2f9b7432b80a8316250952881dc2b5c79fa34417bf6897f324270ec9a781442d34f5a772c87db1263fbed9e721cefe8a7812906ea2e6ab01255423046197c7ff3ea5d18cc4a39836809ce06324793b14bd62b354ad3325b5b9adf8c789ab047061e6968d0444c2ccbe44ec9c1b3529005ce761ee5bb97823dc24d35d7052e2118096715a15f6d0e60b49fa0cb677ad08fbf0624dff37cdfe9759d659e2a80ff92910c06f361ad83cd0fa36a7c9cd5fc7422445d0bdc305dfeb36dc798f16be056c35a5eac58a6a8cf12fa579b4522b915bcf05b8aa0423d6bda47a64be9367c0b3c70a1d2ba4f69aac7b45284fba712da03d20c99a50a6124bf2de0e24528ac5faa157b1a1e97ba140f9658fe21895d6a568d8c1f4064bd7f720578e23c659aeccd34801c129accab8edfc7170c3c7cc0c7c7cb48ebda87a15d25107c8463902f37885792f553bd5b822c4fa1a264eb36dfdce1441d4ac389704cdc2f947b0dc0960a7d5991110d9475964c515bcce581e839393528edcee49dcf0a620f8b03095eca49ac5cedcaa40a1ca8e5648d88f28ee348ad48c50773a3443569b8785a916d6114e5e6e8926a4cb9fdbd51cbf9e13e6234569b0179cda74cb37888f299b012fc54034d8c02107721a646feb3bd9df9173e27b6431b18b5ac6a3dcff94500fe15450901bac7c8d70a86eed8c4c85e5a64d8ec127fb8b4c62319dee619aa51fffb4ce2fafafd2cde7a6ca9c64c7779d5181df67fbf919e99d69700ae86f9e071bc73c06d0f73116e216db5fd65b77aa4c0a7431778d19957b878e95e8f6e870e0be69fcf0dc5b4db306bbd0f81ad935ed2581d462cb61ad5cadb8b2748024503d769cc6c0adb9e022cc4bf5e45d8a38314b4575b63c056f2d5232c7bf3d29f22e5fd60638a6e48f8301b1a474af3315d6c08c56445b75f82a0fe15bd27323de118d6412967dc50f9b0eb04fd77657d9116f81482324daf4eb483818d42e68967feb0ef022e1713c71032f18617157fc94878371b4ee47627418ac7fec8d16268edf9c5739bdd7336e44bac9518f96fd69c5edafd56efd4fe962f78e32190fe6a42d2323acdeb4aba56bc80787dc721d9378863be8d202258f33e7e51f83958670f691e19b73952f88126838111c8f58c4eb2e14ed7c60e0303f76e83b2ba6364fc45d55dc54bb0d9360b836acc667003eb4bf0afd2035eac6901b9feb02e35ac41dd78929c24bd8ac44119f251550742282e126acf7e2aef060dbd73d9f222bf73c9ed12b6802d4f56ea73c23a2bac28c07d040bb6e77942b172aea64e1658e739677417af1b6914ee5555e79e8d0dd28c503b1de69c5157e0072fe628f4aa1bbab3db47e2bbfa3c482f8d1453e88c149d6b1d1eff7fe367062305a8875d83069a4b0c672b718e30a7f8e13364546323af3407be131f4216407020845ad1f8b39083a1dc9267066689fd45dceb5d0c3fbef3623b26a72428ad7e72fc8016f6455b5529fbd5396f00d18e9b6efb6bd3129170c228be942c1b7a4e98a61561219814016b74a3c2f79539461d06e0e3889f194209f939e703ceb17c3fd0d702af65c70b20d0defea7125614a7e6f3900a9108684eab690994a470187cea79061df039c50445701688b2c5be20facf841593cb49eb40b4499fecafb1be227f2f4343f39239bffdf19ea5bfd59d6c1c866086e1d8cecfd601b47a3feafbe7365673ec3821945b634846cf2420707214501fab691f44bb06d5263c62565a60b1748e634eb3bbb430f596724e7e8a339749692cdd2605c6d1a7de62c8147af030ddf3f4f5292a04554412327af29d5cddf70f155d01bb784356718b586079b3a46f0139f2ee8e8fd6891d2830cd46f72d00a3c26ca7d146d9fa6685823965299232f916f4ad8fbbc8e02a2aed2aa4ac337ade5154fdc0f089fa63dfc7c89bf4b6b068064f575c436dace70a87bf0786f0094c1f398185abdcaba29d5093a586584b1196f7f638b4992d4a24ae028abc20dc3a1fb50b5dea85840d29288be8d1b2737e606cab655c50d04c2c809200a3e58e32b139b8f5255e4eb29383a377ed6a721ea4508023aedafe70c66f677e709f684685e2c09b024445d0e52b78d5f0ebca780adc7bfc599a20a9875bfc0d3d2074285c9e2388a558f807cdde95f44ef165a40f78f4982d4103655437b830356336126a93d8fcad8ce4cbdba5abad14f8ffbdf082adfc6399c5c8571e44959183b85cfc8ba3068872114faf20f5f200b652bd99e6fd16d375f7bc50fe8efd6a51f0e450042ae1c7f8291d057c412808a1e0dff80a0beac6ad4aaabb48ff756ed670d998f2247bbd9a947f20721810fd5cf196b96836dfabbc1fc9a65a619536f57fdaf37824555333245148339ae7a7d671339ff85e255a8159b5d8a2f7a9c5b3f52e8167b7d48ccca578d915feefe32b836862f848c95704545707abb65df8f3dca6daef8fb9b8d35da0d4f78d5e58c3f69725578968ff179cd349d4dedd5b92d6a12aa8a4cb3ea408cccbcb980392876838c2f34d2ac76ea64148a253ddb276aba0f603c8acc1934304df6b8297efc282a16ce8d59cd01a9c7dd57669558253a31807ce37a5ddcf909aee7bd22282e71d237d332920b13739b673f3a2dc5ecf2da7a1601cfdc0daad9798ac0d10bee11a208f0e3ea375ff671d97efcfcbef00229b2f01e8fd9a7886155f4fddc8da4f37e403d0274e5e26e2620c5a70d9b5e86e938f59eb7eac543abc9ad49c627916f80cd9ed12c5e0e7dd2af73c9c4036497d082fd1867596e3751a1cafdc2724c700ee7cd0129e051e3e9e41c3423d77bf9b02bfca5b46baafba6f7c881c54ea6964063ad926573654c9921a48ee845656dd05e09605132d3fa64295829a00933bdbe992919a1e22558f7806cd4ed80f2948e94d6fcb5e9963d37f539e0193a8fc560467d2deefc3d76b799f28298055555e5614e75d871258f2a102e38c2398f050592f4c802f026979fad3d8b2870467397f67f3f72749f7153f205cb79eda72dd8e2b0ae7ece3d066b10bf5aadd1e129080a467d00726993607d010cd6b364b58b20925ba16d41381607c81c6ef2b351e1f44ac1fefa4ee026e31be18945fb001dd29fb9f04c7a8b076a215406b23ca5cad2f8e386907be96cf3cc9caea172c1106733720eb3ea68d4795554b0eb7f13e61e6c0aacd526f7740f36b31220305d2556572fc6237629a382c286f89cc59b951952fa38562ff9cb362a4bee97013299cd401cb0a22749e0473d2e80b34866b34b6651c4398f611086effd3951bdea7383805d7f12738e20c461bf183f2122f88c7f8887e49b847a8e922ebd11862f8b7acbe67d2bebcc3858fe97fbddbcf5d94f21d77d903ec18ebcf1fe55a687c41d615522f887c935c47de16ecc4988f9d9004cb746cb5e83dea912ebd070721733a51748de8cdb32ab0ac070ec2ab6bff05112413916cb21db5332a8806f5cebdbec725ea299120eb51e98baf070c430538b7ebc54c586e2eecd9067cbcbecdcc08ba6eb9788739984eada087c55601752e84d91b8e1d4292270918f2bf5f2b8247f582dec59cec22415716cea42dd1bbfda00cb43ae9b2427df84b699a4f023b1e02c04a98814f5a15158f5ecf46bab02e19114b7a22678efe4d6857f5872f6812d44f7710012355aee4f0d8e7b7862708fbd80cb87c8240aa94eec41bdf93c849123254e1c4bf17e986a71871df55af98bb13d32db9d5d7bb12d2eb992926b5b169af2111e6e859a753c7843f15bb518b3359bec2a29b4a54ed0346a8b078330493b7da7fc37e0903ce4de04ed1462f1c364af20fa97015662d7c8002300fe29bfbaae4b1b0b41ac1de768d4f3b9ed59dd9a2040315be8d83c2b61fa138831f4a12faba8869f8163b3d8169748073b7461c435fcb9055023cefa12270b98ea16cc80e664ac31116ec6f42707a2b02ec03eed9969441baf9c3e38dcb4963959f0f6594167204087b82d1557c0ea36cfeb478fa15fc3ec3d8881dcf7c8f3582354a426605dbc00c0ec87431e0eef1d20016301b2eaffd8acbe9342c3b86e19088dd973e208c60d177b792a505e6369990351e58d44c51d9d9864f53ffac1a83b965947ccd311f82965a868253d57d7455d55e5719bd5b74b627e17efe4e388006ba9a2ec239df7dd64b2ef839f558566deb3516bc6c63c4532f098f8a9c81fce9d7aebcf2fd966c6e5d0edb7a07310666f56a48da0a51213377d1aad86ddd604d1e8cfe225177179bf62433635a408752aa8af230bb6c086929c31528c8aa13661d5735e4e9dbdb8ad38d9a8fbbebe1e3818952dcf9e5639650598cb29c152bce3c637932e0078cec546f827b03fedd5d13cdc8c4d90fc5c1a0f5d8c1aa06082040510af7996259e79373bf15d79c131b0bf299c2befd080115f28098fe1c90079b9ce16b94de6fcf90316389869b658c5fca2a25cfd246af010bd5278eb39977435686c8f38645662f96a3cb3b594ab28cb9174f29d6b2355a00277de0fb830ce3af1ce5ac68a9c4ffc981ecc5adf79ffb7c3661f31da0daa1c86f431866115f6bc583eff6a0153663ba08159a094ffd2b9d71e4d90899edd7d6cb8b864303cc3a436c59bb21d0aadfd420f8a483c55f8692ce10819423417d59f428fdfc7063dd96c4fa6c8605228d1fb78d5f64238d9dca62eda5f0139f2b2ecabe09907bc78fad215f5d6926654fc0ef305cea10f2ef98e4fa595b5e5eaeeb5dbfa9ed364de1b04d6804113893cf60a6906ac704b78a9eebee88925e80a170797f1be3ff9db45f5ff991f48171caf393835be6662f9604bc578b731a4fd01d127ca148909c877e58132095ab78a217551ea126e2ae9d37a13ce83d2d3a8f779c19b84dc607d314924b6f76d772d149f6a617345d8ecb9b6e50b59f7c266fadc1b66dd38b6e3a9ca718f00027867677bf1f5acc569655fad8600e6589917d85e7f33db90ffac12bb44a817ea139f4878bc85262c4dd08cd016988361c862a05c9a0ab88f0b9e477f09823d8e5560d8d9b8cd47d278f72064b08b40d43880faab410de3f8b60ff79a2047e4b987ff7525d489a3cb182feae79328874f47799ec85272dbf5c43e4e4c2c85001a7cae5edbf61c23d751582547db6ee7fedf2c9964551523f6ab61a0a4e3ceb153ee1dc484821fc2853bec33ac26afb1e08433040f2bb6aa67010f8efb315931737fc98c92c890dc5f00a0bb5119c05a50d4096821b178200c040ed24e0c6d5f7e28ec06a11d9cd70f0e0f9e404823a67891aef7b431f412cc4504c75da1d773af713bcff14f5c4d6e3464b214047c8fd64a99046d39ec31b11ed998b8bc18f74c810565cb2b6e8f2d513d703b5a2bb4a603e698025d44f08f5ac70b6b30ae0cb1bf99be14c90b7d0fb7915d263c37896d099c4c307a35a244a687f5e98ff6aac591296874c176cdd7a3ad4ac2d73a4e509900462cd491be9b84ca20294e169f45e9ab5d45ea3723aec75cdcfdc709f762cb53b4c08a2f30cfaf16875f2e524327ea1d7e4b13a4c9bb7054f33e355a1a39724eddfcfdfdbc6da4116a74325b655aed7b61574c08ecf7593e8516e6e0397292ad1737b5ff4514d57ff7940b7c77ccfacc59f6f11dac195c279ad60dcf826f214ddb11997396c02bb96a998ee55a8a91905797a4834136f6719a4d265e7c430be83274d9ad799d848e8484cbaa64de893f768a7402bd1751d548984e82b582b086d8c87e724c01a194e8de7247d07fd8624eace3fcc1f7efb23ed5705cf520de9a137ef8cb36caca94a26a6cd13debce85607f7897902d96365dea73b6f0192664b8124236847e2f8fdf31a7ecbbc436dc2dd9e39745a3a9f0c83297645962c09235f5f5625df407aaf70be1b9c8fd7f9f03098820a746cb24aae770a5097c63e0104be055711f41b54e13370d6ac23b839327b4ae2adb331c76099cd350f0747a4beb9ded4003b97de857382a0ac884fab55d672f8d06ac202c91056faa81e4f96d0a430dff7fbf9ebba3bd94c0fc66d7cb38e1ecaf9e97bb2d52e3b40ab593b9d704996e0f470b16e92075548b9cc8ad3ef581038ea5a3138124ec3c0282c98bd551d560d7580e023a38665a19910c5cef992e553bef5bf52ebd75ee2bde027280342ebdb82d445e29bf2c681e507e564f2e0071b6d495ddc979c76160b718a6cb58cf71d2ebe80aeb7f17279a05698b3151ddc8bd9bc8525a19b885dd23a17544c70e617cc115c492de54340e426ebba806ff4144a5221c11fa0c0671ee9eb1990c506d905d50582bec2555bf732d248f404e59285633970b9da594de56205e598aee176039e09d89564c8011ad0899eee86434bee5e0802c28fc37055ae89f5859081dde07fd98c7fb1c1e2472a62ab1ce9155867b5c331ff5dd279df42445b981a83b9ba4a5489b71a5c09e97ae08d60c53263ef97df856c067255e32f608e61c8e6d2bacdeed76f3dc5946dbec10c3205d53bd2f2e9465c67b747a4ada31427ddafe3c7b8a468d4ab39cffd02b0dfae4b9d85e583a4d72e57815afe309b043f5b64da7a00c19a661cf3c81d2e40044aced7267141b6ec004f8401b02474af4731c42c48de45280cb836af4de0f2aea9e4bdc3aa2166bcf2748e84474b1f4a03b2804f9afdca498c6b10eaddf8f06bf50171e1c4906139d15551c699926cc28d9541bfcee3a7dd2e71222899b47ccc6df5d476dd6c3efc87e80cbd2fe447dc801db299abc02b2a021b8cf860fd25c5932d1cfbf5eefacd70e0dfa2589c3a492102af02756e25c5952a8bd9a341156b264eb755056b7e2674ed094ef952e961c43b1a0b481021a7a371d6541ab6499e4f6f194fe14cba9b6252bfc5cdfedc8189df31c59e9d5eec81232182dac519802550be5513384b7bfb477abc8b482599724c5ea755861c4a8dc2ab81082ad7a60460dc8fdabc4b572a6bccdf25de00afe5e1fa6b547fd92c98ba618ef6c63b26ce5c833ef248d0439ea2740ea3d7ef7f3a6c528129fc5fa4c6483176685757b3db2ef95550063b64426aa3b3e91fa2c292ba9e8d4a2bff51ad96b3fc8007919c4cdab95a80fba1e442a4d9b45560ccdefd6e8aaaa0bb0e63bd4e163e8ffb2538bf3ddcdfa93b83d66855004fe4a20a5c240356f14b211856e8433a09022107214f3934eda0171faa36ce831893e97ea772d7c7383d53e8175db4ec752fe43d35c5318094ffd6d5d45ec157b42521e95a994c142e538f510b4c8d5888a1319f7912c4ab1822d9212728f1f4beb05d5d7e13a1c3bd79617d4989c2b2b92b681bad5cc9b1baf19f91c1dab4f6097a98843a9c46c97847173ce0acd0cb7fd5b38b8d1d01c19d21f52b924a1d397587eb56dba285a3ec2fc7e8cbd252aac6cc6d106753678245d429e8c964c8ebda8521678adfa85358b837d8010d1d7b19f9404c172c9d34af4a9b31b38a523569bf2b282279738d9f62a69ac126019f64f301ef1d4655ec4c86df106c8483f1b4fb52c80944b66dd8bfc6a2a8727d2fdc7836985c817a3e333c6ac4f78f01cd9e841c7fe6afee6b406583bb431122418dd7489ef7831ea7052eb5d698fbc6d4fce79ac311585224822bfdc1ce1b04d39045fcee4a2f59eca7a8344d65a55ed081f6d162e2e45db6a594c2ae0cfaca2340c4c27f43c84ca08628de2b3f7eeb9fdaefc9169fd8c6e660e229f367ac1ce54851c6e29c9d10634d783937308969bf767a6629225ba5787604336eafcb9832c9e368405182e3c8bf242c5761230efb3c4c00d1a71266d567084450ce4cfacd0c07fc728de2066350307ff00e779b417cf3e34a83a60a078eff696e98b6d80cad7128c33170cf710f5d61246a21d784e27ac5bf1c02cf06cf92a878993b5845037be18e86b0797fa13ebba09f7b9fa1880135f623ae33629053bb0dd433ceebed135127816d09593b5172209766e94848775169c4eae00b32a79cb70c22618a9ae37e3e5a09671f66448bbfae87e77d7f0ee64afff344ffbb6aa3939b8f1bbdfc58b43dc2c5ef87e8294b307ef291ba30a8a545da9f5c1d0f08725597858d84b1ff059ddf242380573ed055fa5ed8bd2e2dbcf766c0fad7f440494f2b3b19d19e6f4c136d3018a5f4abb84565a973d2d5bdf2270308d01ff0a3710ec1ccd5d3d38aea9e34a3d7dcb3ccb032066fb839f54da0627abb4c69bb9d3ffb457e05c08ef49ffed790bdd62684687de1122bbc4edb1e8190d0339103a80e258ba7f693073c93023a2380c127166062b214b9f3ec6ad24467adf6d5ecfd3d2de8c6febd3b91daf2166a37c84afefc96d45f7460ca116b8a03bb08ea268d5d5a0dd07fbabb28dba8187c55a3918d094b40ee0bc67e199a9cf7e76163f07b5bb7cde8e08f84a4742e62f839dd7b2c35f918c6a81428ac32979f8d63957afb98d7f2ee25cb30a7952feae0adabb182874597d4ea23ba166875feda02477cf3ace7bd1b7442e579c9d1882f828ab83220c5c2bedc4883e79785481986fde3d6bf1cd8d29c157eb9e8597d89e4035ebcf928567f5f3de806992e188f93948a7af721ce3704f02f5e97a22f7794ad33b8b63079641745087b9d38a6da4afe424fa7ec0c5d9a2918b7a52a80d7b4fe0958f55c4ed5f8e4844b19f398a5e4df05e13d8017bec57d7505f406f4c241ed15c521b14dc147dcffaa049011c8c1f96c24cca67521dc5723e01ab9d1b1b22c1a26ff084a5d7184ef2c7096436d911339eeb6e7ad5d370d71ce54ad97449a17a58d29ead33a1d1377660c4da490e0046d06779edea97b12c3b999200fb2e06a0321102879c40c8a3e1571d4adf16b8cd2bcc2a6c48ace8bb4327707b8526a876947e01f163cb8d9d301be0f57d3f6c7649df425f65367424a93d7afd737dcaa6b32a7f92814a0d3210fca21ed267e5c695796bb387aca05ae47d3de00caf09bbd85acaf8d8de7876b2fff73940e586d9ffc9f5676a3a5076c85143f241111eebaa633f766440ef2bd2e16402129f42553e9eff437cfb89a8d099804a35b63db59224185c778590b378e48660a5e73630559b87afca3b09397d24760adc4b29f17142b19470008e5bd1fd98b294c88503a69a0441fc34f85145305d04acdc80072c1458df528d18f570834ea553b66f214525135922ffaed1bf4a70bda5761925df513288342dc051ece965e0e78775eace3e7bd06c79f662171b0091e24783b64190c1363ad6361cd0ba67335ef73c6627c07771bdf4b9995a7e5101163a05bfe5d94da794c80277fa961e183535b9dc1693c23ed36aa0a91726b71ba196d282dd2c535191fd38851582bfbe0cb8b9ee3505cb97205c31067c338750f1d4c736e9aa283b74a5c3f0b762f1a29b28a7889fd6734a477e99130e747a9b1cbebf9ad93e9b421166817ae8f035b5b5538b0540bbfe3f2b3a060abf40161284f154bbd5aeafdb7811f8ccca0973e8ab42e40a5499235d4c1202d0b2bd90f0b0bcc69a64e32f66698df30b45c76b126ba1f7d70b3ca4d582a05c5a50930b025d23e7934444e1847f6e194f29b028abec829bd8b52403e96945f567b91acfb8ffbfb9fc29191ec8e63255de28a2495b2609d790176a4f7b4763075f86ba710fdd49f276561f4a185d80a99e11ac33fd4a5bb66e486449f8c104e49a443b8a7cfb43354d233eb533f1a89fdfb16f4cb3f02d8962f013a36f5791dfafc3d310200bc12a4dc50fa83a63129dbd0429cbe1e970af18ff104a3eb366bc1b69969fdf643b294be29f08c88a18bab9d233c402c9c4f822cee62e3ed4da5c84eff885daf8b525e0e4a595a957e469bc52874997c04ca0ada88d884fbbfb8c36a70e8aafb40e188bd0ec85cfcbf6d207ef2364b716653b2e2e6dc35ccdae2c8b858edba5a8d7dfbcaaeb24538723b63a78084205173fa72cfc5e50280df700f830ccadbbe19d31dd7565dc1a2cbf2a1a1d39b3ef69d7738caadb25bea7e78a398b059712622b2c765c5ba8577a8b642655d3c18cc816b618ec85f2f17fa4e20f03d2c57575e92a904bb83e4a8291ba8201f83bba2108396f33617fb112fdb5dfaf3d69bc72180e9dc623907163c8627c5d7463afdb3c61907639965ee9508ef8d1b9d0b9bbbcd20c53a010d55eebc319b355d2eac9c2b1500fff460cda8a748f03d6760cbdfd5f2dbefbe5b216a68a31a8501bf82177366d8e2ca02f16c6fc0d893c44a9e2f9725593e84aded485b2d99d56db510bc60038dcf524ad31ea2c651521ced8c6bd085021b8f6cbc66813ce3fbd81684166f3b0609f035c5ae07fc8316564cce638bbf474913d1219a55f6f9a338b542c8531df4a01e3cbf1de11637e622efc159abf54d73b624109e133e73e27522c350954e81789997f6b33887f9e4fba8eca9a3d30f7265c7b3b83a634ed5dd41b061071d8ad844526363b10bd20f612a0a3be05a827178b05d26c36665c98eaa347b8b1925752a15f0e89a2d994ed40f30914bd017af2bf299702f6d7d7ec33668caaa21ff1f0659c6c1cb07d25d46ab8e3278256b7db380ed07e93abf3a998d306e83304563fd8ca15c5342b9eb78ac280a5f0a0bee4b268b05ba4f153ff99af57f893e674560bcb86fa2c1627f799a7f5fec7bd3c5c0b175d650c9678cd9b44ee894d73f29d34ea6deff3b3bdc6dd0ae01bcef758d6f0eaef7f01a46a99c01ae31da1b09d28932757f83d96e49f11ed94a1b7827eacb4d5285750eddcf2cc2f6a9140418cb07548ced5c6dc7224b03769612ec6c9ef9e323abef86ab13be249b3bebb1530dfdf19ce02a50d98a08d811c9161d6dfcfc4ae4e49bc2b35c5d3f22063686e8cbcfb89bd42e41f93f3d7870f587f7e3a9bb210791de9a0daba5d696c521ba6653ff29d3922a753bd9cd29196e788c35ea3cc631e9da3bfff22205d210fcd3c700e3e2d450bad8bced5eb373f8e65673c110d6a3b67666633bb1c5ad2652e9f3cbef1e046d9e3dd5ac9f128adbf5acc5089c6925baa60ca86eb05367818c370e037e5cf3e73e4894ef561de34e914c3b6b791c3589711c4e46b0ea089b08cea1fa08c7672885d93187c6db3eddb940c99bec1e89437db1fefb482cb9c06b11105f7014118db41b60fc4ebc63b5199bc8db3fcc65f87ad61edac03ce23451354ee1ed8112148ae715c9404535611593aa2d841cdc1eecb5e893b4ddfc41de5bc9d6916eedc75591c371ba60ec4682442b442a63cacb635dc4bec6b3f2db0c2f6fe0270b93a05326f267c65003deab5bb28b84eb152bab2dffeb64d9e2db128d8dc1acd707faa5b672511f56b101ccf42b2994f3c757c96c4f247b80f189f676166b879af39828fb292bfc1b6a3cdab1a3424884953a4c98c63ffbff2f43a5c1fd82f991cee93b78a7f06603ae0c78751f9b3b7c641093283a2dafc44426c862ba01af44ed2b9b78f3665182c14926fbd06b3b6fec38cbf7f083673864298becd400a804c01fd4776d1f2fa6ebb4940e992e8204d460d91cd84825024f494d7856610df19e83b16f02e0bbe891a7f800f1279a2566e61f8e6fca79a16165aa2690182ffb4221b6f8a9ef58aa2ba6b72a97e94e7408b0e17c7bed667c77b1147f6e6d1bb9643b77d356073241a31c7419db0a34f9a105e0229ce2016d403043c59c33ee55c48eed9e5acad888064694e608f08f70bcffa71dd6623d320dd6ee27635710e1c9c6ffd4385948142c5e3ee21de633c8a5d5dca16a5f45e900d57dfd56bd2dd2e309c4dd5703cfd6a4e779a7c2ad753c12effba7e40e3936d07f51db8fed33e6f33fd617586e86e254d22cac603548be8912e800e0477c86c4f512ef28f3e233e12f6180648ba62e6c0adf4d57ce22b38ab5ece882244dd8d9166c0fe709f25448e7857d3a20824f632beaa5cdc5a7d2dacd46e6f11026569db6ff4ac53ab2dea511811279ea0f67273ff236260723ba19df514c0411801bfdecd8fe545ad81916ffef9fdbb3a193a407584050a15ea300deccb95e173f5027ff6edc6decdc5bbf93732a961279f5c25521a759885fa330f8a0053eac38a084d42e6118e458dd9296335d986cd4dd0951e6d83ce969e038503a8b784b1d60760c99823ad605d77c424d3eceacc99e7a11ab0e11f9e882128724ad37b6092f54a98aecf3f98ee3199edac5f39f1ef492741a55a5eeddea6ab55190d8e39884e25a4b9e7f628e4fc6a14b89b563adb131873d149b099739249702da8069c1a262bb2b5289f80074b8ecc43cc23c06c2543fc427b68cbb201481326bffaeca157ae93ac119a7e81d01f08813e43d28163ddc767ddfe8bcbe6b432a1c391df4ccbebdabd6b53f5c2968c60ae1684ff726c6e8a587685f5a9e9405e7621f9ec89aafae9578962808e63d0d2cbb1b08e767061bb9bf3e371c70d91830da77e3dc2ccec981ace1ff182406edf43349bceadd11321e42068b4a9f433268de774094a7872c54b2474a721a1e04c076f00f4d700787a4772cd0c9653c2e3fd5e4754bae32d3f2015dff46f0aa8e190d1983f4222256fbb2f804ff524e3bee563c7177218d7d8d698f9396fafb2153a5e3320704dccba271370d0fed3679440bb5711ca62349d1dfc49070c2104bef936edccfb8e93d675999508001e09d650a46c1e77419cff061d855b60f852adb3bb1fb3dd0e385673a22030ad5088c8e4512c69fa244bb5d1d6e87b8a5835b89720d3be6c7ed943a87886c4a3028ecbdafedb51c009ff9e78ca27905042bfdc3a19964d1534bc4c1d9718fe3ddbd97b9fadd9190882d65f4dfbd57daf719035f30fc2173046ea69a7cb8ac2505dd80b385d980b1d698ce72ce1d3d655cc07689792b63cc7cdc8b54f769cde4b233898163f3f89b958648ff25d711823300aa2cb88e4e88793ec21a04b9559f013ea4ac5dbe45d9967b038518a0f1f9b69e6500ab956bf2d1db5671248d2ade8fe81fd7d6423d163ee10cacd76f3d041d74f7f88d6702bf75ed11339c3a06b979cb276ce4dae81c8e6bfc78902776d7fe4901a6aed7eb605d0e1bcf7b9710cace09f5d43010945c7c8ed1f265c89f5b321d49ff17d5ef46cb31b8f586427f5f5b35e10bf1991272a9b488076a07fc630bf907764368b1955c21fb86a00f784836be405a87f4625d763b2d3e208eba870ecf4655267a73e3158881217fae2785940e764a210991d9c9dbb1abf02b05ab44f521d757e65824c21abf73546b3acf9cbebd6613582fa6bb7406d4e9fcfed78c9983d3716878f9df390ee465d813b97052f1a739d8a78aa1c4dd7c9a640f1bbf674600c72e2aff252f97fb27e4bb7770695bf309bcb0f4012cd5a5c8b8153c03b75a18fac6a453a7b11028f44fb8f862f97210d3fddef55a6f77cc2707d8b7ea33b3bf0095a593aa551ff1a156ca54cac654f3be465da3c42ad04ef5a728f6f12639fdbf9eca82765a22723e22340bd19ff64063a172dd3aad8625dffca365ec7f2beaeb4794b0c93958636aa37d36ea1b32c1d36cb734b34a678e60d82c21aed1a9c613ecfa7678a99001b5e2876b3b2cd5ce84e0e334abf419bec0f26799e88b69e1dcceedf3b7fe18282f96a9a2055c8c4d4d07db05a2fb7fcccbc5234b7e4d4524c55594b214f97a132fa437606748f72feeef4b4605d25230eaa9afa53dd55810b2fad1f286c8d53ce3c9b11ad833f3c8050776da22c3e91508167dbb74caac6a575d738cf63d2e5748c2c7accc7956c9246ff446fdc457d2de40a05a916e186cc655ea1b0100e95b137b4b85c842efe1dd5c2c020d40f2742cf89d866d9cbf549b996fc6f62cbf3b50fc9c8ee55343b14a5a581cd4008148daacbdbcb60e3b679474a6195d2127b0841eb2c3d70323e693e8f0458ae6f5e3063f5c5abb099569f5a57b07942a2459c887aee780ff61dd67ccbc81b65523d035406947ab84769bc49a31ecd7f834a12d4afcdbf4f59a7401740bf5bd138a8fb285025e7c0bfb1a86f50b4869b2709f7a053168a8ed529ac91df517c31c2904071673d23bd876d08a0a4745aec3079c0f777b9a56877c4d6f4a1eb6e59ac73d9dcef95f4b00ee0360a9163b255a03a03db72cf4d98e24f2e5dd4dbee581e1f7d0b2938fc4c831d914502ee2835a147809f84c984711f24f7f9d80ad1f78662afe456774fcc153533896930242be9b664a07e90c785cf57d796c1fa6a0dca30e0d83ddbdd222a6ad22d1e619ade20bee919fb11319423e64634de5eb278e172be0403a42d1fa85973b08461c84a8eca6322c588d6c2453255b916aec3cef259a123f9e09372575ec20d2c0ddf37b20f922f0a957efd0137db37c3de1fa362a1ba58d8e640e21425d3d9f790a090267da7c0a4c8b9a7fa28d81865ef9dfee5209d7126fcbe21aa9aad13a59db154501d2f8cabf50d5a4f52da6230e5f2f1d093a6199c29f800f5609cc5428c1bf70aea9c723c302ca56441099957d28a488a102e6d1d457a4569385ffa458d780ba9b1bd79d4af03236250cf7c71ca0b9168ea95aeaef1dcc402be31b52c728c7340f8c3d38bebb1000aeae28a42aaa9c9a7cd404cfdef45c27022910ff5bd6def68cd334751ef9881029019c02f863a3d22007b61c59d982110abbd255900c14975d5bdba126482d4312c69020815352a52072c289b57eceb150cd9bc9775929110131ed92e333b3d133c21e31d4358de616193f1714a342129032727ed3d704010e1ca460d6c3a5585d3ae9a78a20550d3231cca68d6d86e67a65790fc8d56a15ad1096bc9c377b2f35fcdce7fc3ae62c09eb3fe9dcae8c52ab14f1d3011d5aadabefbe697b5ae3954a03480407c881ecf7ce7ca63da84b237fdd3be132a01ea3cdbafc2fbe4bb2892f7ced9914c18bd91aa6ff0c0d5cd5b7208062b7ba95debbe4763e3590cbc47bd690e22e07b89029a1464d6ef52f3a14de4c334ccaa0e39a06b6747ff5e0131b66183036bf5146a85cbfa5d78d2f52a080420a0a67dac8dbb9cca96bc951482cf90d4a834f5049049a172377f996baf4cdccb5ea020ae27caa4e57eac3a2015a295c6750cb4aed5da7a1f2700364bcd19225d56d6207d75e83ca7986fb82c32844fe786a6dfadc28a2bc082c5e4aa14c90d3a21ab071b41cee4e800b9fa86a23daf3437d391706986016dcbdc3c9a882733e4b7685a00c35d5091aa38f56f7066b192c422ac2f84abd26b4352314cb68f1ab715bffcf79c4e9a26497216c9f5dc0955641e74669561c59dae87251fb4166b97ca782a3ba1198e7c47ecc686fdb29ad8283f950855ce70674eeef6541af2aee563fefd067d256673adaf6c55d1c9ab2a33376d534644b71cf0d9d32a43363ba3c504f131a24a1d57c55e09ae4e2c24fbc1e1a8a190cac509803375cbb6cf804d32f5736c9c5c3f45d92f8ba165786c00cc4eb114cfefefa87d4d0a587ba872c8f958de1f4672bb5a4b0f7f2883bb88f6605740eb85f6d937c0f8ac4db8383b656a0fb02b224476d8c43540e3db7e0cf5321cc8e1650d723c62f57fb1585eeaad6b9150522bfbf246687143f2f2ecf3a97f3ec2fa81bc9c20e0f9442e992eaf4f748aa664cc98bc8df1cfcc68482c720255ce34e82671d76bc24a78d40c29b9b0192e915c1922127f5df87c2e56dddde8452179f25c07bf28394218e5b7ce9da517f0ea8a28380987afeef434442296a2b100051632ce2fa712c6228bb48f8c85890e62fbe5c01d794f2a64e109f6709a8085adad6cc106916af7b3014460fad8a92ae8cc5b7bffb880537a7019fe25fb0c7bb5d580426ee54242d2c5a846ef0edf1a0844b9289fcdeac19c68d1bde9a34bef3144ec3e17708beabf871124ef820a1a93920b347ede6d8f6cb873a8de63b3498df382523ab5e28e47f247e3cd3686d1bb07180d2d340e894f86391c164b287d74386124710a616c49685ae0518e595cfe9dd02f252d97b0ff5cd346346ecfbb13f7d19143a8e4cdd58d4c1bd78ac0ce32be31bd410a5a5238eb59a5fd678de86442c9154f990484ce05cc9d0fee28c9ea83b9da33bc183031c54dc994292baff2a469cd7ee3f1e18de36c38bcd556949f8b32c21078309e67a8049ec721c3c740fcda8df1de4dbe1cf0abd567d2f6a72b5ea19a7bda981556c2bb32686c742744432e163ca8b9d9d8cffaa2cf128431d987a3ddb1690d169562072352d5cf641bc1273849d8552b962a4c86b69758c92481c437311a537d92a689301e0298ff3d232be01977b7736a6e02c108b2ee5b3694a69728e08c41eaccab0936cdae6b6d73bb2cbe95a0057306bb040ee29c0daef1abebe2c2d55f9daae0c7abd5c7a5b3285ec4d46dd70ec44b10d6bf20acea6dd88c76a0f51342733d8c9121cef90c99352a63a76a75b919e24be523c83007bb2cde9d117841cc9e54ae221aed9834954cc1f547c3fc47042be186616ebbdd6dd22e4c2fa41657a664c057b61b6c8bb11a7cf293deafbb809080e63989608589eb080ffe596de49b8c64e894cea9900b594e01e5d642041174153b01461de80459dfadb938e543435db8f7ca6e16f8f735451b1f5cc1114ab5981ec0b757a82eff4ef71dd594b992b6f6885c34b349f0b0124821f13bfee9ec20514217a602048ab1ff5e10415b1270ed902983050649a3a5f896271e997852164722dcb0661dd094bc852295f328c1d368b9d5d8a16d688a58a3d89321ed87005124e9f4a513537d96b36444163a482bca5683610d52638615c196a9f1f6a0b50fa3eea24247e379701f26a3f67340a4507a4ba441eb5c9988e1fcb4459ddfa75852e584734fc6b162b883a883d075108d9e2569f3846e9605486ebb27eb0df7c90ca2e32453a01935099bcdac80a937429c5ff0a2d5fc3b8bd7c4c48bc2dcb96fa7bb77d18e3a8b7317429aefb74af972302662bebb3a4e8d6bab2797158d9863652672436f4d0128921c0c2db7fe17b75261ac66950fc590c0925b0359c58c7b4ca5cd1dafb2c5f2d2467b4b624daf3f5d47dadf983f317ffc22fe28d71f0b6b532bf4f492dd914bba0995067cdf6e11d84d6d81fa5f35c0cf13f8d5c14709aa62ecc023b22a08965e3e0fd05730b8f4741844f6e74087c2672a6c9c66c03ce1db4717f036933de34a0b09149f1c25e8fa7157bd71cb3c67cfdbca32978d0000fd6b465b1b3722dd12dffe61295bd1f38000f0477ca1e79da1c1fab9f964dbfe8a6cad466fedbf85dcad9888fce5767d935a14da9ef3bf7baebffeaae8551d3d086899252f2128b173c8309f18af5a762f914fdfdff7ab3b43a8b59568afa4076c72c7b3aa93cfaca6d51a04bb8bcd3172162f936a053a0fcab0ffd188552b56f90dd364a49bb4b6a77507accf328a99d84bc8beb08caf01aef795ae6f3ea52c259f142708aa3ccd0b371faf6a54d7ecd2bde0ae2c84267e043ce001b56e4ac628b604f16f17a4f29d43aca781179f27fba8db96a9214bf0ddf1c02cc9ad241da9111523a178fe60805bcd9f2bb8655bc5a86163268ace2904b6d70cc0cab8187f44f49a41b6a7a9413fe7edfa3b386cf52210c06333c039d60281df0e2b7794abd446a688b7622e740869ed3ee1a5a0a680aaed146ff05a3db7c88780ded9f6bd23b5e3b5995bb9af0440de040feabfe87c94545d920c2d9e0e3aadffe116f53d0a08ae650817ca1f0f719afd89044edc683020e7216e2d159c5a12d3d867999ef273286a0f2b125bf45e97fd532ec6f9a2722c026e5b286eafa78d6e6a364f388b0065f08cf62cd4072657bc556566da1a40b1c0fa2a3af3eaa2aad8c5f8b8fed68363724c1384ea38f0ef0a8fa540fec8cee1db4f09425f3597231d475d49e7c6ad5d4cd905f3a079263c42eebffe85fddf3a20db2ebd7c32077334718b6f7eed8173ff26707ff003eb771a9f7ced34ecd314ed22293968df5ef649d5825300c54d7b10946420acd87d0d4dea76fff9706cd41c2710e82185cc5be9d54d43f92e1faa8e93dc2ecebcea7ccbb156d23cba791b160d6e6f83601533c312cf3bbd40e72c427359f70127999559e466a59077d7c1c538a885c05b58ebc7f56c5f16ac3ae3eb019cee994369165e3f532c8ba2e7be473b32fbdd4f4c4b095a93dfeabbb1ce7b3c276534b9bc7188ab860b48420cac4e81cb50b4fe47d8dc932c5d10967a96b444d04a07754fe966675ef79aec177ff27b57b33565a23752fd043ecabe4f32a1fe33c32fa55692f2a42ca4ec340df1fdaa1c7b80eeed919457d3da1f735ef6ecaf501019611482a88330415e07774b3069491d4638f84b93ec1bdf0cf33a875b8610706eb18e34bf16b5e572f3f825658009d6b79a2c65150ceeac364c018dc4dc3b3feed252d29c68d18df0a1e23b54b0a524591959a9dfdc27e7514589b36f2a1ae7aeabf3417c92029163b2e40e42fd9a596f5039b9eaacbf5f2adec4f55a2c8faaf3037fdf494666e4497bd2c2dbd92e857f7f7cb4945d23a3890a869bcda0dea811ef8db0ac28577543565a37b0581409c4877402f348589ccb09cf2e6e34b6c03516664a71fd964ae9c55bffe321652fc5df06a42922bc79bcf93d64350def60753121c80043020bc9f51cf6fb7002ce08e11010c94dffb3591cedbbe3fed7cbeded8f33d020de4a4f451fc3d27ef1d46bcb85b6c5bd05695f8f1596b3620216beea3ee321e646e85fb4ec26764d32161fa4ae0cebabdd03b95b1e277c06c1b83e07d774a6eef7eb0eba3abc290f9798bbba61efd2ac286535b720932cc1c9f00d27d4bed426cd0672b2d62f096db5374264fbaec104d4121c4230f8a97c82d0681f7aa2c0d89d58ecbee6abe66339071655b59557a00e3b3eab1c1e306ffc75c3bc67f68f88ef3b1fed3378135b1765b1d7d333b195ce46c460f4494ad7e5dd0f3b7a06f0ca72bbb6d32899467c3485b7d1b881e3476b4f218a20c913133342a3f306d9216f10274e644672e71f49e385913bc081c0fdd02fcc253ec8748593068f6fb2c16a81febb2f9813165ef7df5934e682377dd352eb76f9e6b4da39d89de8d4a23994a912c99c212f98c730fb3e8e2d3e619adb629f2b9e43c60ef01db0fbc8b21b32dc80a3ffd654368c9ae2c5635fd344334083860c5e073157422e32c0a17ea71a66ccba6b6b6a345608413a2a063fe4371f12269253b93c3c283772b1a9dad041b1afc937987ed1c783940d41ead63d34907fb99e0d174bad0b4d7797c95d98a0337df534d7fad7b5948b95efc26d8b8f84dcf4de4d8b14d78b912f5749ad2c8c372d3d52f9ba282abd304d11763bf49215f20a84d0baa692d7f8f318a0534b0778d9751c18c1bb28827f349f54a85293b1ebc3affdbdb023ea32a63088a2f6b8341927974a259c319621b09428be15e81f9dd9bee480278180cbe29fd298aaaf21a1392a15847b56cb3c727504871c237d7fc69e8228e6646710b0fc4527c193bf1f0b4a81586eda6e995458cabe4a4769bd24b83cf1579e605f03c3c60434dee447c1d280079fc51c059b692d4ac1540a9c470e5f226c0e9092b7b35dc5a25ee30c377970131bb53b15d226bfb626a3f60504ca8b4dc2fa3366ae2274fea2e69d3e20d5c62358ab6d2ec05852463dbf794aca782942d69adf13fd44ff6d2d6ee718642ca949d865c9f73f81202166ad48cc1338f4638132d6abaf1fbe61a04ef0fa26b008898ac9825e9bee0c42b8a246f5403b86730c7e6fb90686bd92776404f755466d1066be186618bc41b7242a7178131e8f59e664be0a95b71994d06c5f7cfbe9af5ea6645fbc3a80f8db1fdd8e8189c47e3163365944c2be0e9e3dc05be37f8c6e8d1de0ca4c623a2a667559561fc123becd92d7921cbdd82c3a4c7ff5d021e21e0d34865feb289a1c21faf278905a042d3a4130d1f82a56e4d53007ba2db3b837250fef57cf5c35d9f5e262a190fba8824fc20ebddd0a9ca095c6b9245ffaf31253fb39b1dd7e6f1020ac917f1884236bcccbd25af7d5fa747fd3ee02324d8722cf18ad7984672e9fecd493db2b764ebae1fe3446403b27173da25e75d9a667a14b2bb871d58ad725c892e10a95a0a8c5f33556afa01bf8685791fcb5258b416b3856c02b0117df34c2e6984f1492de846c78751d92857c321383d33657ec38887890da3ccd349df6f3acffbad3d9a42fec8d02533a52672978420fa7e32dade5880ab5740d607d40fc20fa2a509f1157091319b0e1c2c54c5f83993f952f64c7b47332d533b15a19bab2904a5badff20f54a35424f595a7e2f98f69191789d060d78e70093fe459b8b61c34191c47e2f72e68bd7d0d557ac1de6d3b091a53e204bff3b28e6b7523226a012ef58da0f524dd3e437f3ae10661cae4aacc49e593a39fc89173b5bd6a3bf9e0bd62e4dbe004f7ddd452169356eefa991dc08587f250d02e162753716955d07845eee647e1c9dc2e6468902caedd73979c25ec04ea1ac4ef625ea1f620dad11f2899d542754d94762c32d4293ab3bb4c45658bc26348100629583d6f93121ea7b2f6ab4751e380ddb4a15035010a891d7680943889655acd96aad73ccc5b65fc2deb4a4edb7d610579c656012b296ede52ed31c5394ed11b6880beeb4999e543fb88ab15beef5c859efb5794a65e70c63e3224481deceeb45cfca561c422964c234331227f542aedcc74091582521ea28f4e91f6377bd4f2bd2aa13db5229a95dfdb4410d246f56ff9da91ecf589452e2e5a86878ff02ea08ed7fd5bb2c0026fc033015671d37b0ff1e484d3894eb77af813e2762486ff12370e57d07dc251ec48de74683e1968e6fb6737f41357d3eeb95843e633ef7513be61789bc002b254e2b13bf3000fa082c2efbce7884b7f35be4e88b4ced8a3b100889c25cae5cc849e891be5477cc1c710d82d7cde10a64325b1eb97ab44d9e6e38b637591ecbc28d1388d89f1dc48ca6d1dc48288d813f9b55107ba6c59afcf3de7a3af11ff54bf320344ceefc65c49757b6cef907cdab1fb65059e8e160516de6e6b3e426071e7b75ab147e1d3205f09031382c733f589f10c33c95c619c2f60e6678d72b493226ab83a3bfea440300ad3da71d73eeecd665cac2e50ab7027cbaaacf7d4f514773a0b2e5449aea9fc759ec9670212a2fbf23c12379ea5f28b63100fe9285a3802ef301c554776e3353c2b9eeaaa4e27f9fec01e81128c15d5d3b818a188a03e620eeb7f45c6ec963503be45ff47687446d4ea63dffc7e9833e0edd61af553b1e68bd894cd3646f21bcd01527d2b472162f59d347af14a9a84faffb0ed593f4ae446e13cda8f50ac1f80136c8ac6545f153aeb4f2abab4f5bc0d1feb2b03ec6125a518d8526f37a5150aa2810cb9a1c4234a0c5535ff59c7e6d78e0c180214aad04fbcc9c8de1926f3bf9fe8147a3cee5dd21fec1801a4eb4d941df9151c6acb1a81e0841297f4cd09fa8cb4aa449aba9b4deea6ecb9d6dadd13ad6738d349272e778e4170216c4e3ca6a68c38c0f101033c79fb83ebcaf6c9690367670b4aa30c72ba560b228bae3208d3f155903b1def3235654caa79be4def610d5fa37b7f94144ec7dbe68d6fb77099d4391b11c14aa7bf699a49c391c68be4c16280b6370efbb0226a7e2a70744c5f3ff87bed16d0b01936af2d4cf7f14823d8c22dec1fa559ed0b9327a2efd6ecd680443b653ad6a75abd762985c267df249ba0ef5937aca0d10ffba2d57c25ea2423ddef522ec3345c51e6298b921333c945ccc5960866f3a823ef70eb0bce6aadcfb923129f6652e9ca1dbd514ae465205ce69c2174d369b2f464d9352166f1ed7c77424bb25d39e457d9104abc9e2c0aeddeee3cb4944e897bb3b662071ae1ba871d08aefd7bbb51af694315d773e542d2edf1b7abce5a4006d094ce6df51777ba4502fed71bcac81ebc6491ee264241fd52eb4c231f3ae0b73fb71dd31ffb0f311e864e2b20fb8883040ba9313460bcf3a94ec25a67b0121a58c50ca8b18962e0eaf229659c1077bc065b87d322348f121accbb07f1e15c5d1540fd788af25ad0e784a8b2b1cb51ba4cb8b9a0e4f49fa4fa27000003146bb8891833fd01ca745077203527d0ea78dce6602963cc0bf3aa11b300c2a04e6cf43d702d256069c4c5ebf4a4733d232e230fbddd59f14d1520422ae44dfe64fccf365c279c71b64e455a83e0b8a926f8cf877cb79519bc6d68697734e26eaf1e992ee460f7d3a702a2250c7e50023cf8265f4dcb40f670ae75a2ca44686cae29ec3d487d210c6da2e45a48da4424267c450483cc8522c0a7bb3b74b52c3c3200b90ddf0d5f3349f6659785126555cf8cdc6010318399f41e51029bf9b1cabe5dd6dfadbe99720c8bc5235b18f7ea1c4cf20423ba12eacde82c1e88ad1cc47d052536538cd1d724325be235e9c94e26e4420a4a13f8fca7f5e2d50a20416be51c4f09d5181cc329e3540e78a5631faaaedc96175d7fe30d186507dc66bf752b88e6fb991f424e087029c6bb2a3dff6b0b2601167b38f0b64d06b27d8cbfa24e009befd925803aeded4940fdf61797cccd2e6ab54df4da51842029ae91012caa92ce756dceb60644881494c319564ef298227ce6d6bf777cd8378adefee8d310815e985753a539cbc12c010eef7752ec41f1005ebb588be727ee353075f27c1207efdb5f29b0f18fa1cff893a7fc26244f0d60fabaa11d56f5697806d3f09f8c017cdb70a16f19706d0de9ea012f9cbd8a4317d34b83fa1645e053aebc65b91901af399fda8457d052a1efee0321eae91c53802aad462edeb29e7ca066cab3cb115b873447cd70b9661d34f013e3ea61ce0ff7aed0cba8e03a878325d14f49c1323d753a69d3620fcaf23537368c9d68fd1ae617a74b1551b76749fc947ee68085f901dd48ab800bb312f56958955af66741051735c906de954629102be66d591b0e1eb1f9673269efe1651d7c66d48df764a6a660b02d47887a6a28029e0cfe88727e344209b2bc9726f648b3f88e8cd12baf31476c8b80f55c94a307505da208bee2e82e85a610a3660abed7f27f3f42acd50763efa3f1a1e66b972907daac373bd002d012a94c529c6bc5a97f50a199bb8752ae23a1c263b8888032f8bd7db5ce8840ea58c9c480cc6daa87b8120fc94ef15ee86ae</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不是哥们，你谁啊？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eye Diagram</title>
      <link href="/2024/10/30/Eye%20Diagram/"/>
      <url>/2024/10/30/Eye%20Diagram/</url>
      
        <content type="html"><![CDATA[<blockquote><p>眼图（Eye Diagram）是用于分析数字信号完整性的一种图形工具。 <a><span id="more"></span></a></p></blockquote><h3 id="眼图的主要特点包括："><a href="#眼图的主要特点包括：" class="headerlink" title="眼图的主要特点包括："></a><a>眼图的主要特点包括：</a></h3><ol><li><strong>重叠显示</strong>：通过在同一图形中叠加多个信号周期，能够直观地看到信号在不同时间点的状态。这种重叠可以揭示信号的噪声、抖动和失真等问题。</li><li><strong>眼高和眼宽</strong>：眼图的“眼睛”部分的高度（眼高）代表信号的噪声裕度，越高意味着抗干扰能力越强。眼宽则与信号的时钟同步和抖动有关，越宽通常意味着更好的定时裕度。</li><li><strong>使用场景</strong>：眼图常用于评估传输线的设计、信号的放大和调节，以及整个系统的性能。设计工程师可以根据眼图调整电路，改善信号完整性。</li></ol><h3 id="DDR读写眼图的特点："><a href="#DDR读写眼图的特点：" class="headerlink" title="DDR读写眼图的特点："></a><a>DDR读写眼图的特点：</a></h3><h4 id="1-读眼图："><a href="#1-读眼图：" class="headerlink" title="1. 读眼图："></a>1. <strong>读眼图</strong>：</h4><ul><li><strong>读操作时的信号</strong>：在进行读操作时，数据总线上的信号状态会根据时钟的上升沿和下降沿变化。</li><li><strong>眼图的形成</strong>：多个读操作周期的数据波形叠加形成眼图。通过观察眼图，可以评估信号的眼高和眼宽，判断是否存在噪声、抖动和时序问题。</li><li><strong>重要参数</strong>：眼高反映了信号的噪声裕度，眼宽则表示定时裕度，二者都对系统的稳定性至关重要。</li></ul><h4 id="2-写眼图："><a href="#2-写眼图：" class="headerlink" title="2. 写眼图："></a>2. <strong>写眼图</strong>：</h4><ul><li><strong>写操作时的信号</strong>：在写操作中，数据总线也会随时钟的变化而改变。</li><li><strong>眼图的形成</strong>：类似于读眼图，通过叠加多个写操作周期的数据波形生成眼图。</li><li><strong>写操作的关注点</strong>：写眼图通常需要关注信号的上升和下降时间，以确保数据能够在正确的时钟边缘被接收。</li></ul><h3 id="眼图分析的意义："><a href="#眼图分析的意义：" class="headerlink" title="眼图分析的意义："></a><a>眼图分析的意义：</a></h3><ul><li><strong>信号完整性评估</strong>：通过分析眼图，设计工程师可以发现潜在的信号完整性问题，比如时序偏移、过多的抖动和噪声。</li><li><strong>优化设计</strong>：根据眼图的结果，工程师可以调整传输线的设计、增加终端匹配、改善信号的驱动能力等，以优化DDR接口的性能。</li></ul><p>总之，DDR读写眼图是验证和优化DDR信号传输性能的重要工具，有助于确保数据的准确传输和系统的稳定运行。</p><blockquote><p><strong>眼高和眼宽是眼图中两个重要的参数，用于评估信号的完整性。</strong></p></blockquote><h3 id="眼高-Eye-Height"><a href="#眼高-Eye-Height" class="headerlink" title="眼高 (Eye Height)"></a><a>眼高 (Eye Height)</a></h3><ul><li><strong>定义</strong>：眼高是眼图中“眼睛”打开部分的高度。它表示信号的电压范围，反映了信号的抗噪声能力。</li><li><strong>重要性</strong>：眼高越大，说明信号在逻辑高和逻辑低状态之间的差异越明显，这样可以更好地抵抗噪声的干扰。如果眼高较小，信号可能更容易受到噪声的影响，导致错误读取。</li></ul><h3 id="眼宽-Eye-Width"><a href="#眼宽-Eye-Width" class="headerlink" title="眼宽 (Eye Width)"></a><a>眼宽 (Eye Width)</a></h3><ul><li><strong>定义</strong>：眼宽是眼图中“眼睛”打开部分的宽度。它表示信号在有效传输期间的时间窗口，反映了信号的时序裕度。</li><li><strong>重要性</strong>：眼宽越大，表示信号在时钟周期内保持稳定的时间越长，这样可以确保数据在多个时钟边缘被正确采样。如果眼宽较小，意味着信号在有效传输时间内的变化范围有限，容易导致数据的时序错误。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h3><ul><li><p><strong>眼高</strong>：反映信号的抗干扰能力，眼高越大，抗噪声能力越强。</p><ul><li><strong>电压差异</strong>：眼高反映了逻辑高电平（通常对应于信号的高电压状态）和逻辑低电平（通常对应于信号的低电压状态）之间的电压差。当眼高较大时，逻辑高和逻辑低的电压差明显，使得接收器更容易区分这两种状态。</li><li><strong>噪声裕度</strong>：在信号传输过程中，电磁干扰、热噪声和其他因素可能会对信号造成影响。较大的眼高意味着在噪声干扰下，逻辑高和逻辑低的电压仍有足够的差距，可以减少错误判断的风险。也就是说，接收器能够在一定范围内的噪声干扰下，仍然正确识别信号的状态。</li><li><strong>容错能力</strong>：较大的眼高使得系统在面对信号波动时具备更好的容错能力。如果信号电平因噪声而发生轻微变化，但仍在逻辑高和逻辑低之间的电压差距内，接收器能够准确判断信号状态，而不会误判为错误的逻辑状态。</li></ul></li><li><p><strong>眼宽</strong>：反映信号的定时裕度，眼宽越大，数据传输的可靠性越高。</p></li></ul><blockquote><p><strong>通过观察眼高和眼宽，工程师可以评估和优化高速信号传输的设计，确保系统的稳定性和可靠性。</strong></p></blockquote><h3 id="示例：DDR3接口信号"><a href="#示例：DDR3接口信号" class="headerlink" title="示例：DDR3接口信号"></a><a>示例：DDR3接口信号</a></h3><blockquote><p>假设在一个DDR3接口中，逻辑高电平的电压（Vih）为 1.5V，逻辑低电平的电压（Vil）为 0V。这意味着：</p></blockquote><ul><li><strong>逻辑高电平（Vih）</strong>: 1.5V</li><li><strong>逻辑低电平（Vil）</strong>: 0V</li><li><strong>眼高</strong>: 1.5V - 0V &#x3D; 1.5V</li></ul><h3 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h3><h4 id="1-大眼高："><a href="#1-大眼高：" class="headerlink" title="1. 大眼高："></a>1. <strong>大眼高</strong>：</h4><ul><li>如果眼高为1.5V，信号的逻辑高和逻辑低电平有足够的电压差异。在这种情况下，即使信号受到噪声的干扰（例如，0.1V的干扰），逻辑高电平的实际电压可能在1.4V到1.6V之间（1.5V ± 0.1V），而逻辑低电平仍然保持在0V。由于逻辑高和逻辑低之间的电压差异仍然很大，接收器能够轻松区分这两种状态，从而保持信号的准确性。</li></ul><h4 id="2-小眼高："><a href="#2-小眼高：" class="headerlink" title="2. 小眼高："></a>2. <strong>小眼高</strong>：</h4><ul><li>如果眼高较小，比如只有0.3V（逻辑高为0.15V，逻辑低为-0.15V），噪声干扰可能会将逻辑高电平的电压降低到0.1V（0.15V - 0.1V），而逻辑低电平的电压可能保持在-0.15V。这时，接收器在识别信号时可能会出现混淆，因为0.1V可能被误判为逻辑低电平，从而导致错误的信号解码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Write Bit De-skew Algorithm</title>
      <link href="/2024/10/30/Write-Bit-De-skew-Algorithm/"/>
      <url>/2024/10/30/Write-Bit-De-skew-Algorithm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写入比特去偏移（Write Bit De-skew）算法的工作原理和步骤。<a><span id="more"></span></a></p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a><a>目标</a></h3><ul><li>确保在写入路径中的每个数据位都能够正确对齐，特别是在0到1的转换时，确保数据传输的可靠性和准确性。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a><a>算法步骤</a></h3><h4 id="1-初始写入操作"><a href="#1-初始写入操作" class="headerlink" title="1. 初始写入操作"></a>1. <strong>初始写入操作</strong></h4><ul><li>算法首先执行一系列写入操作，以确保数据正确写入指定的地址，包括DTAR0（x0000）、DTAR1（x0008）和DTAR2（x0010）。这些地址是用于后续的数据对齐和错误检测的基础。</li></ul><h4 id="2-执行顺序"><a href="#2-执行顺序" class="headerlink" title="2. 执行顺序"></a>2. <strong>执行顺序</strong></h4><ul><li>写入比特去偏移必须在写入均衡（write leveling）和写入均衡调整（write leveling adjustment，若适用）之后进行。通常建议在执行读取比特去偏移（read bit deskew）或读取比特去偏移和读取眼中心化（read eye centering）之后执行写入比特去偏移。这并不是强制要求，尤其是在已知读取操作正常的情况下。</li></ul><h4 id="3-检测数据眼的左边缘"><a href="#3-检测数据眼的左边缘" class="headerlink" title="3. 检测数据眼的左边缘"></a>3. <strong>检测数据眼的左边缘</strong></h4><ul><li>算法首先尝试检测数据眼（data eye）的左边缘，即至少有一个写入数据位发生故障的位置。数据眼是描述数据传输中有效信号的时序窗口。DQS和DQS#信号在这一位置的最新的0到1的转换会被检测到。</li></ul><h4 id="4-逐位右移检测"><a href="#4-逐位右移检测" class="headerlink" title="4. 逐位右移检测"></a>4. <strong>逐位右移检测</strong></h4><ul><li>每个数据位将被逐个右移，直到检测到相应位的读取故障。比较失败的次数由寄存器“DTCR.DTRPT”定义。当达到这一失败次数时，表明该数据位的时序可能需要调整。</li></ul><h4 id="5-数据掩码对齐"><a href="#5-数据掩码对齐" class="headerlink" title="5. 数据掩码对齐"></a>5. <strong>数据掩码对齐</strong></h4><ul><li>在完成每个写入数据位的去偏移之后，算法可以选择定位数据掩码（data mask）相对于数据位的位置，并随后进行掩码的去偏移。这有助于确保掩码信号与数据信号的同步。</li></ul><h4 id="6-定位数据眼的右边缘"><a href="#6-定位数据眼的右边缘" class="headerlink" title="6. 定位数据眼的右边缘"></a>6. <strong>定位数据眼的右边缘</strong></h4><ul><li>在去偏移掩码之后，算法还可以选择进一步定位数据眼的右边缘。当右边缘被检测到后，算法会计算数据眼的中心位置，并将DQS&#x2F;DQS#信号定位在数据眼的中心。这是为了确保数据的稳定性和正确性，使得信号在其最佳时机内被读取。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h3><blockquote><p>总的来说，这段文字描述了写入比特去偏移算法的目的和步骤，通过精确的时序调整和检测，确保数据在DDR内存中的写入操作是可靠的。通过对数据位和掩码的同步管理，算法能够优化数据传输的完整性，减少错误发生的可能性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Read Bit De-skew Algorithm 2</title>
      <link href="/2024/10/30/Read-Bit-De-skew-Algorithm-2/"/>
      <url>/2024/10/30/Read-Bit-De-skew-Algorithm-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>描述了PUB（物理控制单元）中的读取比特去偏移（de-skew）算法的目标和过程<a><span id="more"></span></a></p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a><a>目标</a></h3><ul><li>确保在读取路径中，数据比特的0到1的转换是对齐的。这是为了优化数据的传输可靠性，确保数据能够被准确读取。</li></ul><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a><a>算法过程</a></h3><h4 id="1-写入数据："><a href="#1-写入数据：" class="headerlink" title="1. 写入数据："></a>1. <strong>写入数据</strong>：</h4><ul><li>算法开始时，会向指定地址（DTAR0: x0000、DTAR1: x0008、DTAR2: x0010）发出一系列写入命令，确保数据正确写入。这一步骤是算法的基础。</li></ul><h4 id="2-可选的写入延长："><a href="#2-可选的写入延长：" class="headerlink" title="2. 可选的写入延长："></a>2. <strong>可选的写入延长</strong>：</h4><ul><li>在写入序列之前，可以选择执行写入定级（Write Leveling Adjustment）。为此，DQS（数据选通信号）可以通过寄存器DTCR.DTEXD延长一个额外的周期。</li></ul><h4 id="3-读取数据："><a href="#3-读取数据：" class="headerlink" title="3. 读取数据："></a>3. <strong>读取数据</strong>：</h4><ul><li>数据写入后，算法进入读取阶段，开始进行读取比特去偏移操作。</li></ul><h4 id="4-检测数据眼的左边缘："><a href="#4-检测数据眼的左边缘：" class="headerlink" title="4. 检测数据眼的左边缘："></a>4. <strong>检测数据眼的左边缘</strong>：</h4><ul><li>读取比特去偏移算法的关键步骤是检测数据眼（data eye）的左边缘，即在这个位置上，至少有一个读取数据比特的故障被检测到。这可以理解为找到数据信号从0到1变化的第一个位置。</li></ul><h4 id="5-右移比特："><a href="#5-右移比特：" class="headerlink" title="5. 右移比特："></a>5. <strong>右移比特</strong>：</h4><ul><li>一旦检测到左边缘，算法将对每个比特进行右移，直到检测到相应比特的读取故障，并且比较失败的次数达到寄存器DTCR.DTRPT中定义的次数n。</li></ul><h4 id="6-扫掠读取数据眼："><a href="#6-扫掠读取数据眼：" class="headerlink" title="6. 扫掠读取数据眼："></a>6. <strong>扫掠读取数据眼</strong>：</h4><ul><li>完成所有比特的去偏移后，算法将扫掠读取数据眼，以定位右边缘。</li></ul><h4 id="7-计算眼中心："><a href="#7-计算眼中心：" class="headerlink" title="7. 计算眼中心："></a>7. <strong>计算眼中心</strong>：</h4><ul><li>一旦检测到右边缘，算法将计算数据眼的中心，并将读取的DQS信号置于该中心位置。这样可以确保在读取数据时，DQS信号与数据的中心对齐，从而提高读取的成功率和准确性。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>整个算法的目标是通过精确定位和调整数据眼的边缘，确保读取过程中的数据比特在时间上是对齐的，从而减少读取错误。这在高速数据传输（如DDR内存）中尤为重要，因为任何微小的偏差都可能导致数据损坏。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Read Bit De-skew Algorithm</title>
      <link href="/2024/10/30/Read-Bit-De-skew-Algorithm/"/>
      <url>/2024/10/30/Read-Bit-De-skew-Algorithm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>描述了读取比特去偏移（read bit de-skew）算法的过程<a><span id="more"></span></a></p></blockquote><h3 id="1-读取比特去偏移算法概述"><a href="#1-读取比特去偏移算法概述" class="headerlink" title="1. 读取比特去偏移算法概述"></a><a>1. 读取比特去偏移算法概述</a></h3><ul><li>目的<ul><li>读取比特去偏移算法旨在消除由于数据传输延迟而导致的比特间偏移，从而确保数据的准确接收。</li></ul></li><li>并行执行<ul><li>该算法在所有字节通道（byte lanes）上并行执行，并且需要对内存进行写入和读取访问。</li></ul></li></ul><h3 id="2-内存访问要求"><a href="#2-内存访问要求" class="headerlink" title="2. 内存访问要求"></a><a>2. 内存访问要求</a></h3><ul><li><strong>单通道访问</strong>：<ul><li>只能访问一个存储器通道（rank），这个通道通过寄存器 <code>DTCR.DTRANK</code> 来定义。</li></ul></li><li><strong>可编程地址</strong>：<ul><li>使用四个可编程寄存器（<code>DTAR0-3</code>）定义内存的起始地址。这些地址用于 SDRAM 的写入和读取突发（burst），要求一共需要访问 32 个地址单元。</li></ul></li><li><strong>寄存器配置</strong>：<ul><li>每个地址的列地址提供一个 BL8（Burst Length 8）或两个 BL4（Burst Length 4）命令的起始地址。</li><li>所有 <code>DTARn</code> 寄存器的行和bank地址必须相同。</li><li>列地址的最低三位（[2:0]）推荐为 3’b000，以便访问连续的 8 个突发地址。</li></ul></li></ul><h3 id="3-SSO-数据模式"><a href="#3-SSO-数据模式" class="headerlink" title="3. SSO 数据模式"></a><a>3. SSO 数据模式</a></h3><ul><li>减少 SSO<ul><li>固定的连续写入序列旨在提供减少的 SSO（Simultaneous Switching Output）数据模式。具体来说：<ul><li>在地址 <code>DTAR3</code> 和 <code>DTAR1</code> 之间，所有奇数位从 0 转换到 1。</li><li>在地址 <code>DTAR3</code> 和 <code>DTAR2</code> 之间，所有偶数位从 0 转换到 1。</li></ul></li></ul></li></ul><h3 id="4-写入和读取过程"><a href="#4-写入和读取过程" class="headerlink" title="4. 写入和读取过程"></a><a>4. 写入和读取过程</a></h3><ul><li><strong>写入访问</strong>：<ul><li>读取比特去偏移算法使用八次 BL8 写入到内存。</li><li>例如，假设 DTAR0-3 的默认值分别为 x0000、x0008、x0010 和 x0018，写入访问的过程如下：<ul><li>向地址 x0000 写入数据（BL8）</li><li>向地址 x0008 写入数据（BL8）</li><li>向地址 x0010 写入数据（BL8）</li><li>向地址 x0018 写入数据（BL8）</li></ul></li></ul></li><li><strong>读取访问</strong>：<ul><li>该算法使用四次 BL8 读取内存，返回 32 个比特的数据。</li><li>例如，在读取过程中，假设读数据的过程如下：<ul><li>从地址 x0000 读取数据（BL8）</li><li>从地址 x0008 读取数据（BL8）</li><li>从地址 x0010 读取数据（BL8）</li><li>从地址 x0018 读取数据（BL8）</li></ul></li><li>仅比较从 0 到 31 中的比特 4 到 11 和 20 到 27。</li></ul></li></ul><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a><a>5. 示例</a></h3><p>假设我们要使用读取比特去偏移算法对一个存储器通道进行去偏移：</p><ul><li><strong>配置寄存器</strong>：<ul><li>DTAR0 &#x3D; x0000</li><li>DTAR1 &#x3D; x0008</li><li>DTAR2 &#x3D; x0010</li><li>DTAR3 &#x3D; x0018</li></ul></li><li><strong>写入过程</strong>：<ol><li>向 x0000 写入数据，奇数位 0 转换为 1。</li><li>向 x0008 写入数据，偶数位 0 转换为 1。</li><li>向 x0010 和 x0018 写入数据，继续执行相同的模式。</li></ol></li><li><strong>读取过程</strong>：<ol><li>从 x0000 读取数据，检查比特 4 到 11 和 20 到 27 的值。</li><li>从 x0008 读取数据，继续比较相关比特。</li></ol></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>通过这个过程，读取比特去偏移算法能够有效地消除由于延迟引起的比特间偏移，确保数据传输的准确性。这一过程结合了写入和读取操作，通过连续访问内存来实现数据的对比和分析，从而优化数据传输。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Built-In Self Test(BIST)</title>
      <link href="/2024/10/28/Built-In%20Self%20Test(BIST)/"/>
      <url>/2024/10/28/Built-In%20Self%20Test(BIST)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内建自测试（BIST）运行的机制、配置选项、错误计数和状态指示。<a><span id="more"></span></a></p></blockquote><h3 id="BIST-运行的触发与配置"><a href="#BIST-运行的触发与配置" class="headerlink" title="BIST 运行的触发与配置"></a><a>BIST 运行的触发与配置</a></h3><h4 id="1-触发-BIST-运行："><a href="#1-触发-BIST-运行：" class="headerlink" title="1. 触发 BIST 运行："></a>1. <strong>触发 BIST 运行</strong>：</h4><ul><li>通过写入 BIST 运行寄存器（<code>BISTRR</code>）并选择 RUN 操作来触发 BIST 运行。</li></ul><h4 id="2-运行配置选项："><a href="#2-运行配置选项：" class="headerlink" title="2. 运行配置选项："></a>2. <strong>运行配置选项</strong>：</h4><ul><li>无限运行<ul><li>BIST 可以配置为无限期运行，直到接收到 STOP 命令为止。</li></ul></li><li>停止条件<ul><li>可以配置为在检测到失败时停止。</li><li>也可以设置为在发出一定数量的测试模式后自动停止。</li><li>或在达到预设的最大地址值时自动停止。</li></ul></li></ul><h4 id="3-BIST-模式选择："><a href="#3-BIST-模式选择：" class="headerlink" title="3. BIST 模式选择："></a>3. <strong>BIST 模式选择</strong>：</h4><ul><li>可选择的测试模式包括：<ul><li>行走1（Walking 1s）</li><li>行走0（Walking 0s）</li><li>伪随机（Pseudo-random）</li><li>用户定义（User defined）</li></ul></li></ul><h3 id="数据字节BIST运行过程"><a href="#数据字节BIST运行过程" class="headerlink" title="数据字节BIST运行过程"></a><a>数据字节BIST运行过程</a></h3><h4 id="1-写入操作"><a href="#1-写入操作" class="headerlink" title="1. 写入操作"></a>1. <strong>写入操作</strong></h4><ul><li>数据字节BIST从<code>BISTARn</code>寄存器中设置的地址开始，执行一系列写入（WR）操作，直到发送的字数达到<code>BISTWCR.BWCNT</code>。</li></ul><h4 id="2-地址递增"><a href="#2-地址递增" class="headerlink" title="2. 地址递增"></a>2. <strong>地址递增</strong></h4><ul><li>地址根据<code>BISTAR1.BAINC</code>递增，同时自动处理<code>bank</code>的关闭或打开以及行激活。</li></ul><h4 id="3-回环模式"><a href="#3-回环模式" class="headerlink" title="3. 回环模式"></a>3. <strong>回环模式</strong></h4><ul><li>在回环模式下，一旦发送的字数等于<code>BWCNT</code>, BIST操作结束，回环数据与写入数据进行比较，记录任何失败。</li></ul><h4 id="4-DRAM-模式"><a href="#4-DRAM-模式" class="headerlink" title="4. DRAM 模式"></a>4. <strong>DRAM 模式</strong></h4><ul><li>BIST现在会执行一系列读取（RD）操作，从DRAM中读取之前写入的数据，并与写入的数据进行比较，记录任何失败。</li></ul><h3 id="无限模式"><a href="#无限模式" class="headerlink" title="无限模式"></a><a>无限模式</a></h3><ul><li>在无限模式下（<code>BISTRR.BINF== 0x1</code>），写入-读取序列将无限进行，直到满足某一停止条件：<ul><li>用户发出 BIST STOP（<code>BISTRR.BINST == STOP</code>）。</li><li>比较失败的次数达到预设限制（<code>BISTRR.NFAIL</code>），如果 <code>BISTRR.SONF == 0x1</code>。</li><li>在 RD 操作中，地址达到预设的最大值（<code>BISTRR.BSOMA == 0x1</code>），允许 BIST 通过完整的内存数组。</li></ul></li></ul><h3 id="错误状态与计数"><a href="#错误状态与计数" class="headerlink" title="错误状态与计数"></a><a>错误状态与计数</a></h3><h4 id="1-错误计数器："><a href="#1-错误计数器：" class="headerlink" title="1. 错误计数器："></a>1. <strong>错误计数器</strong>：</h4><ul><li><p>位错误计数器</p><ul><li>每个 DRAM 引脚有一个位错误计数器，例如，DATX8 上有9个计数器（8个数据位和1个数据掩码位），地址&#x2F;命令通道最多可有34个计数器。</li><li>位错误计数器设计较小，以限制设计尺寸，每个计数器为2位宽，因此可以记录每个引脚上的最多3个错误。</li></ul></li><li><p>字错误计数器</p><ul><li>计数整个字的错误，如果数据字节通道或地址&#x2F;命令通道的任何位发生错误，则相应的字错误计数器会增加。</li><li>字错误计数器为16位宽，可以计数最多64K个错误。</li></ul></li></ul><h4 id="2-数据掩码："><a href="#2-数据掩码：" class="headerlink" title="2. 数据掩码："></a>2. <strong>数据掩码</strong>：</h4><ul><li>提供数据掩码功能，以便在某个位上记录更多错误，通常在诊断阶段使用。</li></ul><h3 id="BIST状态与重置"><a href="#BIST状态与重置" class="headerlink" title="BIST状态与重置"></a><a>BIST状态与重置</a></h3><h4 id="1-完成状态："><a href="#1-完成状态：" class="headerlink" title="1. 完成状态："></a>1. <strong>完成状态</strong>：</h4><ul><li>一旦 BIST 模式执行完毕（停止或执行最后的测试模式），完成状态位（<code>BDONE</code>）将被设置在 BIST 状态通用寄存器（<code>BISTGSR</code>）中，这是测试模式执行结束的唯一有效指示。</li></ul><h4 id="2-轮询状态："><a href="#2-轮询状态：" class="headerlink" title="2. 轮询状态："></a>2. <strong>轮询状态</strong>：</h4><ul><li>用户必须轮询此位，确保它被设置后才能读取其他状态寄存器。</li></ul><h4 id="3-BIST-重置指令："><a href="#3-BIST-重置指令：" class="headerlink" title="3. BIST 重置指令："></a>3. <strong>BIST 重置指令</strong>：</h4><ul><li>提供 BIST 重置指令，通过<code>BISTRR</code>寄存器，重置某些 BIST 状态寄存器位为默认值。</li></ul><h4 id="4-系统重置："><a href="#4-系统重置：" class="headerlink" title="4. 系统重置："></a>4. <strong>系统重置</strong>：</h4><ul><li>注意，所有状态寄存器在系统重置时也会被重置为默认值。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h3><blockquote><p>描述了 BIST 的工作原理、测试模式、错误计数以及如何处理状态和重置。用户可以通过 BIST 进行可靠性测试，并根据需要配置各种选项，以确保设备在运行中的准确性和可靠性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDL Calibration Search Algorithm</title>
      <link href="/2024/10/28/DDL%20Calibration%20Search%20Algorithm/"/>
      <url>/2024/10/28/DDL%20Calibration%20Search%20Algorithm/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>介绍了本地校准延迟线（LCDL）校准的搜索算法，包括如何根据DDR时钟周期进行校准。以下是逐条解析：</p></blockquote><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><h4 id="1-LCDL校准："><a href="#1-LCDL校准：" class="headerlink" title="1. LCDL校准："></a>1. <strong>LCDL校准</strong>：</h4><ul><li>每个LCDL需要为SDRAM时钟周期进行校准。这是通过测量所需的延迟线步数来实现，以产生与DDR时钟周期相等的延迟。</li><li>每个LCDL都是独立校准的，校准过程中信号会通过延迟单元以测量SDRAM时钟周期。</li></ul><h4 id="2-校准算法："><a href="#2-校准算法：" class="headerlink" title="2. 校准算法："></a>2. <strong>校准算法</strong>：</h4><ul><li>DDL校准算法使用<strong>二进制搜索</strong>或<strong>线性搜索</strong>来找到与时钟周期匹配的延迟值。</li><li>通过<code>PGCR8.DCALTYPE</code>寄存器选择搜索类型，默认类型为二进制搜索。</li></ul><h4 id="3-起始值："><a href="#3-起始值：" class="headerlink" title="3. 起始值："></a>3. <strong>起始值</strong>：</h4><ul><li>两种搜索类型的起始值可以通过<code>PGCR8.DCALSVAL</code>寄存器选择。</li><li>对于未使用的延迟单元，由于高频率时不需要，可能会导致在重新校准时出现问题。<code>PGCR8.DCALSVAL</code>寄存器允许用户配置DDL校准搜索算法以缓解这个老化问题。</li><li>用户可以在高频率时设置一个较小的起始值，默认起始值为256。</li></ul><p>4. </p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Byte DDL Control</title>
      <link href="/2024/10/28/Data%20Byte%20DDL%20Control/"/>
      <url>/2024/10/28/Data%20Byte%20DDL%20Control/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><p><img src="https://s2.loli.net/2024/10/28/NPYoG7idgV2nbcx.png" alt="image-20241028233711104"></p><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a><strong>主要概念</strong></h3><h4 id="1-LCDL的类型"><a href="#1-LCDL的类型" class="headerlink" title="1. LCDL的类型"></a>1. LCDL的类型</h4><ul><li>每个字节通道有6种类型的LCDL：<ul><li><strong>WL LCDL</strong>（写入均衡LCDL）：用于平衡写入信号。</li><li><strong>WDQ LCDL</strong>（写数据LCDL）：用于控制写入数据。</li><li><strong>GDQS LCDL</strong>（读DQS门LCDL）：用于读取DQS信号的门控。</li><li><strong>RDQS LCDL</strong>（读DQS LCDL）：用于读取DQS信号。</li><li><strong>RDQS# LCDL</strong>（读DQS# LCDL）：DQS的反向信号。</li><li><strong>GSQDS LCDL</strong>（读DQS门状态LCDL）：用于监测DQS门的状态。</li></ul></li><li>每种LCDL都有相应的控制逻辑，具体的控制逻辑在后文提到。</li></ul><h4 id="2-x4支持："><a href="#2-x4支持：" class="headerlink" title="2. x4支持："></a>2. <strong>x4支持</strong>：</h4><ul><li>对于x4模式，每个字节通道有两个LCDL控制逻辑实例，以独立控制两个半字节（nibble）。</li></ul><h4 id="3-MDL控制逻辑："><a href="#3-MDL控制逻辑：" class="headerlink" title="3. MDL控制逻辑："></a>3. <strong>MDL控制逻辑</strong>：</h4><ul><li>每个字节通道还包括一个MDL控制逻辑实例，用于控制主延迟线（MDL）。</li></ul><h4 id="4-BDL控制逻辑："><a href="#4-BDL控制逻辑：" class="headerlink" title="4. BDL控制逻辑："></a>4. <strong>BDL控制逻辑</strong>：</h4><ul><li>每个字节还包括多个BDL控制逻辑实例，用于独立控制每个字节通道的BDL。</li><li>写路径BDL<ul><li>包括8个写数据（WDQ）BDL、1个（或2个，适用于x4）写数据掩码（WDM）BDL、1个（或2个，适用于x4）写数据时钟（WDQS）BDL、1个（或2个，适用于x4）输出使能（OE）BDL。</li></ul></li><li>读路径BDL<ul><li>包括8个读数据（RDQ）BDL、1个（或2个，适用于x4）读数据掩码（RDM）BDL、1个（或2个，适用于x4）读数据时钟（RDQS）BDL、1个（或2个，适用于x4）读数据时钟#（RDQS#）BDL、1个（或2个，适用于x4）功耗下降接收器（PDR）BDL和1个（或2个，适用于x4）终端使能（TE）BDL。</li></ul></li></ul><h4 id="5-DDL控制的校准和VT补偿："><a href="#5-DDL控制的校准和VT补偿：" class="headerlink" title="5. DDL控制的校准和VT补偿："></a>5. <strong>DDL控制的校准和VT补偿</strong>：</h4><ul><li>字节通道的DDL控制具有将DDL校准和VT补偿串行进行的选项，而不是并行进行。</li><li>这种选项允许将DDL校准和VT补偿逻辑实例化一次，而不是在每个LCDL控制块中重复该逻辑。</li><li>但串行校准和VT补偿的缺点是操作时间会增加。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>这段文字的主要内容是介绍了每个字节通道中的LCDL和BDL的控制逻辑、如何进行独立控制以及在x4模式下的扩展。此外，它还提到DDL控制的校准和VT补偿可以选择串行或并行执行，这对于设计的复杂性和操作时间都有影响。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC DLL Control</title>
      <link href="/2024/10/28/AC%20DLL%20Control/"/>
      <url>/2024/10/28/AC%20DLL%20Control/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol><li><strong>LCDL（本地校准延迟线）</strong>：<ul><li>地址&#x2F;命令通道中只有一个LCDL（称为AC LCDL），其作用是为LPDDR3&#x2F;2地址提供90度的相位偏移。这个LCDL由通用的LCDL控制逻辑来管理。</li></ul></li><li><strong>MDL（主延迟线）控制逻辑</strong>：<ul><li>另外还包含了MDL控制逻辑，用于控制主延迟线（MDL），这部分的逻辑也将在后续章节详细描述。</li></ul></li><li><strong>BDL（可调延迟线）控制逻辑</strong>：<ul><li>地址&#x2F;命令通道中有多个BDL控制逻辑实例，分别独立控制所有地址&#x2F;命令通道的BDL。这部分的详细逻辑也会在后续章节中说明。</li></ul></li><li><strong>DDL校准逻辑</strong>：<ul><li>地址&#x2F;命令通道的DDL校准逻辑嵌套在LCDL控制逻辑中。如果设计编译时启用了CA VT补偿（即未定义<code>DWC_NO_CA_VT_COMP</code>宏），则会在DDL控制级别实例化VT补偿逻辑。</li></ul></li><li><strong>序列执行</strong>：<ul><li>DDL校准和VT补偿在地址&#x2F;命令通道中总是串行进行，因为这个通道只有一个LCDL。</li></ul></li></ol><h3 id="VT补偿"><a href="#VT补偿" class="headerlink" title="VT补偿"></a>VT补偿</h3><ul><li><strong>VT补偿</strong>是用于抵消由于温度变化、工艺变化等引起的电压阈值（VT）变化的逻辑。</li><li>默认情况下，地址&#x2F;命令通道的所有DDL寄存器都经过VT补偿。如果禁用这一特性，特别是在命令&#x2F;地址训练禁用的情况下，可以减少PUB（物理接口块）的面积。</li></ul><h3 id="宏定义的影响"><a href="#宏定义的影响" class="headerlink" title="宏定义的影响"></a>宏定义的影响</h3><ul><li><code>DWC_NO_CA_VT_COMP</code><ul><li>如果这个宏被设置，AC DDL寄存器将不进行VT补偿。此时，AC DDL寄存器的行为如下：<ul><li>AC BDL寄存器将返回其初始值（无论是复位、训练或写入的值），即使VT发生变化。</li><li>AC LCDL寄存器也将返回其初始值（无论是校准、训练或写入的值），与VT变化无关。</li><li><code>ACMDLR.IPRD</code>字段返回其初始的校准值，无论VT如何变化。</li><li><code>ACMDLR.TPRD</code>被编译掉，因此返回的值为0。</li></ul></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段文字的核心在于描述地址&#x2F;命令通道中延迟线的控制和校准机制，以及如何通过宏定义选择是否启用VT补偿。这对于确保信号的准确传输和提高系统的可靠性至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BDL和LCDL的使用</title>
      <link href="/2024/10/27/BDL%E5%92%8CLCDL%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/27/BDL%E5%92%8CLCDL%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="BDL和LCDL字段的结构"><a href="#BDL和LCDL字段的结构" class="headerlink" title="BDL和LCDL字段的结构"></a>BDL和LCDL字段的结构</h3><p><a>1. <strong>BDL字段</strong>：</a></p><ul><li><p><strong>细粒度延迟字段（低4位）</strong>：通常用于调整微小的延迟，每个位代表一个细粒度的延迟步骤。</p></li><li><p><strong>粗粒度延迟字段（高2位）</strong>：用于调整较大的延迟，每个位代表一个较大的延迟步骤。</p></li><li><p><strong>示例</strong></p><ul><li><p><strong>寄存器值</strong>：假设我们将BDL的控制寄存器设置为 <code>0x2F</code>。其二进制表示为：<code>0x2F</code> &#x3D; <code>00101111</code>（二进制表示）</p></li><li><p><strong>位分解</strong>：</p><ul><li><p><strong>高两位</strong>：<code>10</code>（表示粗粒度延迟为<code>2</code>）</p></li><li><p><strong>低四位</strong>：<code>1111</code>（表示细粒度延迟为<code>15</code>）</p></li></ul></li><li><p><strong>各字段的意义</strong></p><ul><li><p><strong>粗粒度延迟</strong>：</p><ul><li><code>10</code>（粗粒度延迟为 <code>2</code>，表示大约有 <code>2</code> 个 CK 周期的延迟）。</li></ul></li><li><p><strong>细粒度延迟</strong>：</p><ul><li><code>1111</code>（细粒度延迟为 <code>15</code>，意味着延迟为 <code>15/16</code> 个 CK 周期）。</li></ul></li></ul></li><li><p><strong>总结</strong></p><ul><li><p>BDL控制寄存器设置为 <code>0x2F</code></p><ul><li><p>粗粒度延迟为 <code>2</code>，即增加大约 <code>2</code> 个 CK 周期的延迟。</p></li><li><p>细粒度延迟为 <code>15</code>，即几乎最大的小延迟。</p></li><li><p>总延迟 &#x3D; 粗粒度延迟 + 细粒度延迟</p><ul><li>粗粒度延迟：<code>0 CK周期</code></li><li>细粒度延迟：<code>1/16 CK周期</code></li></ul></li></ul></li></ul></li></ul></li></ul><p><a>2. <strong>LCDL字段</strong>：</a></p><ul><li><strong>细粒度延迟字段（低4位）</strong>：同样用于微小的延迟调整。</li><li><strong>粗粒度延迟字段（高5位）</strong>：用于设置较大的延迟，允许更多的调节范围。</li><li><strong>示例</strong><ul><li>示例同上，就是粗的延时字段更达了，可以延时更久的时间了。</li></ul></li></ul><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><strong>通过这样的配置：</strong></p><blockquote><ul><li>BDL提供了精细的控制以调节信号的接收时间。</li><li>LCDL则提供了更大的延迟范围，适用于更复杂的时序要求。</li></ul></blockquote><h4 id="这些设置帮助确保在DDR通信中，数据能够准确地在预期的时刻被接收，从而优化性能和稳定性。"><a href="#这些设置帮助确保在DDR通信中，数据能够准确地在预期的时刻被接收，从而优化性能和稳定性。" class="headerlink" title="这些设置帮助确保在DDR通信中，数据能够准确地在预期的时刻被接收，从而优化性能和稳定性。"></a>这些设置帮助确保在DDR通信中，数据能够准确地在预期的时刻被接收，从而优化性能和稳定性。</h4>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLL Testing</title>
      <link href="/2024/10/27/DLL%20Testing/"/>
      <url>/2024/10/27/DLL%20Testing/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="DDL（可调延迟线）测试概述"><a href="#DDL（可调延迟线）测试概述" class="headerlink" title="DDL（可调延迟线）测试概述"></a><a>DDL（可调延迟线）测试概述</a></h3><blockquote><p> 在DDR4多PHY PHY模块中，嵌入了多种可调延迟线（DDL），其基本逻辑功能是缓冲器。测试这些DDL以确保其正常工作和产生正确的延迟值是非常重要的。以下是对DDL测试过程的详细解释。</p></blockquote><p><img src="https://s2.loli.net/2024/10/27/ke8wuvEixZGp5Mf.png" alt="image-20241027225357426"></p><h4 id="1-DDL的基本功能"><a href="#1-DDL的基本功能" class="headerlink" title="1. DDL的基本功能"></a>1. DDL的基本功能</h4><ul><li><strong>可调延迟线（DDL）</strong>：<ul><li>DDL是一种可调节的延迟线，允许在信号传输路径中引入特定的延迟，以补偿时序上的偏差。不同类型的DDL（如LCDL、BDL和NDL）被用于不同的应用场景。</li></ul></li><li><strong>内部逻辑扫描测试</strong>：<ul><li>内部逻辑扫描测试通过将信号从DDL的输入传递到输出，验证DDL能够正确传递逻辑0和1。但是，该测试无法验证每个DDL设置是否产生唯一的延迟值，或者这些延迟值是否组合成特定的延迟特性。</li></ul></li></ul><h4 id="2-DDL的类型与用途"><a href="#2-DDL的类型与用途" class="headerlink" title="2. DDL的类型与用途"></a>2. DDL的类型与用途</h4><ul><li><p><strong>LCDL（Local Calibrated Delay Line）</strong>：</p><ul><li><p><strong>用途</strong>：用于DQ&#x2F;DQS信号的偏移调整。</p></li><li><p><strong>特点</strong>：可调节的延迟线，允许在数据传输中引入可变的延迟，以便精确对齐数据和时钟信号。</p></li></ul></li><li><p><strong>BDL（Buffer Delay Line）</strong>：</p><ul><li><p><strong>用途</strong>：用于DATX8和DATX4X2块中的读写比特去偏移（deskew）。</p></li><li><p><strong>特点</strong>：相较于LCDL，BDL的最大延迟较短，主要用于较小的延迟调整。</p></li></ul></li><li><p><strong>NDL（Fixed Delay Line）</strong>：</p><ul><li><p><strong>用途</strong>：用于匹配LCDL的零延迟。</p></li><li><p><strong>特点</strong>：具有固定的延迟值，不可调节，主要用于为LCDL提供基准延迟。</p></li></ul></li><li><p><strong>总结</strong>：</p><ul><li><p><strong>可调性</strong>：LCDL和BDL是可调的，而NDL是固定的。</p></li><li><p><strong>延迟范围</strong>：LCDL提供较大的延迟调节范围，BDL则提供相对较短的延迟。</p></li><li><p><strong>应用场景</strong>：LCDL主要用于数据对齐，BDL用于读写比特的去偏移，NDL用于提供固定延迟。</p></li><li><p><strong>LCDL与BDL</strong>：</p><ul><li>LCDL（本地校准延迟线）用于DQ&#x2F;DQS偏移，而BDL（短延迟线）用于DATX8和DATX4X2块中的读写比特去偏移。NDL（固定延迟线）用于匹配LCDL的零延迟。</li></ul></li><li><p><strong>可观察性</strong>：</p><ul><li>某些DDL（例如DATX8和DATX4X2中的写比特去偏移DDL）是可观察的，可以通过发送特定的数据模式并直接编程DDL延迟值来检测输出延迟的变化。然而，不是所有DDL都会影响设备的主要输出，某些DDL只影响内部节点。</li></ul></li></ul></li></ul><h4 id="3-DDL的测试挑战"><a href="#3-DDL的测试挑战" class="headerlink" title="3. DDL的测试挑战"></a>3. DDL的测试挑战</h4><ul><li><strong>测量限制</strong>：<ul><li>DDL的最小延迟步长非常小，超出了大多数自动测试设备（ATE）的测量能力。这意味着只能在较大的步长上进行特性测试，这不是理想的解决方案。</li></ul></li><li><strong>直接访问</strong>：<ul><li>通过直接访问DDL的延迟值寄存器，尽管可以进行一些初步测试，但这并不能完全解决所有DDL的测试需求。</li></ul></li></ul><h4 id="4-DDL环振荡器测试模式"><a href="#4-DDL环振荡器测试模式" class="headerlink" title="4. DDL环振荡器测试模式"></a>4. DDL环振荡器测试模式</h4><blockquote><p> 为了更全面地测试DDL，所有PHY块和PUB中都集成了DDL环振荡器测试模式。</p></blockquote><ul><li><strong>环振荡器的构建</strong>：<ul><li>在环振荡器测试模式中，NDL、BDL和LCDL被连接在一起，形成一个单一的环形振荡器。这是通过将一个延迟线的数字测试输出（DTO）连接到另一个延迟线的数字测试输入（DTI）来实现的。</li></ul></li><li><strong>振荡器输出与分频</strong>：<ul><li>环振荡器的输出通过一个可编程的分频器进行分频，产生的输出信号作为延迟线测试输出。每个DATX8、PHYDATX4X2、PHYAC和PHYACX48模块都有自己的环，允许并行测试整个接口。</li></ul></li><li><strong>自动测量功能</strong>：<ul><li>PUB中有额外的逻辑，可以自动测量延迟线测试输出的周期。测量的周期可以从寄存器中读取，并以相对于PUB控制器时钟（ctl_clk）周期的代码表示。</li></ul></li></ul><h4 id="5-测试过程示例"><a href="#5-测试过程示例" class="headerlink" title="5. 测试过程示例"></a>5. 测试过程示例</h4><blockquote><p>假设我们希望测试一个LCDL的性能：</p></blockquote><ol><li><strong>初始化：</strong><ul><li>确保PLL锁定并触发延迟线校准。</li></ul></li><li><strong>进入环振荡器模式：</strong><ul><li>启用DDL环振荡器测试模式，将所有相关DDL连接成一个环。</li></ul></li><li><strong>编程延迟线：</strong><ul><li>通过设置DDL的延迟值，调整环中每个DDL的延迟。</li></ul></li><li><strong>观察输出：</strong><ul><li>通过环的输出观察振荡信号的频率变化，记录输出的周期。</li></ul></li><li><strong>分析结果：</strong><ul><li>通过对比输出周期与期望值，评估每个DDL的延迟性能，确保它们在预期范围内工作。</li></ul></li></ol><blockquote><p> 通过这种方法，工程师可以获得DDL的线性度和范围，确保整个DDR4接口的可靠性和性能。</p></blockquote><h3 id="DDL的组成"><a href="#DDL的组成" class="headerlink" title="DDL的组成"></a><a>DDL的组成</a></h3><p><strong>粗延迟元素（Coarse Delay Elements）：</strong></p><ul><li>这些元素提供较大的延迟步长。它们的数量因不同类型的DDL而异：<ul><li><strong>BDL</strong>（Buffer Delay Line）：包含4个粗延迟元素。<ul><li>下四位（[3:0]）对应于细粒度延迟位。</li><li>上两位（[5:4]）对应于粗粒度延迟位。</li></ul></li><li><strong>LCDL</strong>（Local Calibrated Delay Line）：包含32个粗延迟元素。<ul><li>下四位（[3:0]）同样对应于细粒度延迟位。</li><li>上五位（[8:4]）对应于粗粒度延迟位。</li></ul></li></ul></li></ul><p><strong>细延迟元素（Fine Delay Element）：</strong></p><ul><li>这是一个可调的细微延迟元素，可以提供更精确的延迟调整。在BDL和LCDL中，细延迟元素的数量是相同的：<ul><li><strong>都包含16个细微步长</strong>。</li></ul></li></ul><h3 id="如何设置DDL延迟"><a href="#如何设置DDL延迟" class="headerlink" title="如何设置DDL延迟"></a><a>如何设置DDL延迟</a></h3><ul><li>在设置某个DDL延迟时，可以通过选择一定数量的粗延迟元素和细延迟元素的组合来实现。</li><li>例如，如果需要某个特定的延迟：<ul><li>可以选择2个粗延迟元素（BDL）或4个粗延迟元素（LCDL），然后可能再加上1到16个细微延迟步长。</li></ul></li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><a>举个例子</a></h3><blockquote><p>假设你需要设置一个特定的延迟为200个时钟周期（tCK）：</p></blockquote><ul><li><strong>在BDL中</strong>：<ul><li>选择2个粗延迟元素（每个元素提供50个时钟周期的延迟），总共提供100个时钟周期的延迟。</li><li>然后可以使用细延迟元素，选择6个细微步长（每个细微步长提供约16.67个时钟周期的延迟），总共提供100个时钟周期的延迟。</li><li>最终组合为100 + 100 &#x3D; 200个时钟周期。</li></ul></li><li><strong>在LCDL中</strong>：<ul><li>选择3个粗延迟元素（每个元素提供50个时钟周期的延迟），总共提供150个时钟周期的延迟。</li><li>再使用3个细微步长（每个细微步长提供约16.67个时钟周期的延迟），总共提供50个时钟周期的延迟。</li><li>最终组合为150 + 50 &#x3D; 200个时钟周期。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h3><blockquote><p>这种设计允许在较大范围内快速设置和微调延迟，使得在不同的操作条件下能够实现精确的时序控制。不同类型的DDL通过不同数量的粗细延迟元素组合来提供所需的延迟特性。</p></blockquote><h3 id="可调延迟线（DDL）测试的两种观察方法"><a href="#可调延迟线（DDL）测试的两种观察方法" class="headerlink" title="可调延迟线（DDL）测试的两种观察方法"></a><a>可调延迟线（DDL）测试的两种观察方法</a></h3><blockquote><p> 主要是通过环形振荡器的输出信号来进行测试。这两种方法在测试的有效性和效率上有所不同。</p></blockquote><h3 id="1-环形振荡器输出"><a href="#1-环形振荡器输出" class="headerlink" title="1. 环形振荡器输出"></a>1. 环形振荡器输出</h3><ul><li><strong>环形振荡器</strong>是通过连接多个延迟线构成的一个电路，能产生稳定的时钟信号。</li><li>这个时钟信号会在经过可编程分频器后送入PUB（物理单元控制器）。</li></ul><h3 id="2-测试观察方法"><a href="#2-测试观察方法" class="headerlink" title="2. 测试观察方法"></a>2. 测试观察方法</h3><h4 id="方法一：自动计算频率"><a href="#方法一：自动计算频率" class="headerlink" title="方法一：自动计算频率"></a>方法一：自动计算频率</h4><ul><li>PUB可以计算出环形振荡器输出的时钟频率，并通过取样功能得出这个频率值。</li><li>由于控制器时钟（ctl_clk）可能在较慢的速度下运行，能够通过设置适当的时钟分频比来保证测试的准确性和减少测试时间。</li><li><strong>优点</strong>：这种方法允许所有PHY块（包括AC&#x2F;ACX48和每个DATX8&#x2F;DATX4X2）并行测试，提高了测试效率。</li></ul><h4 id="方法二：数字测试输出"><a href="#方法二：数字测试输出" class="headerlink" title="方法二：数字测试输出"></a>方法二：数字测试输出</h4><ul><li>将分频后的时钟信号直接输出到数字测试输出（dto[0]），使用户能够直接观察时钟波形。</li><li><strong>优点</strong>：这种方法在设备调试和特性测试时比较有用，因为用户可以直接看到波形。</li><li><strong>缺点</strong>：对于生产测试来说，这种方法不是最优的，因为只能一次查看一个PHY块，效率较低。</li></ul><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><blockquote><p>假设在生产测试过程中，设计团队需要测试多个PHY块的延迟线：</p></blockquote><ul><li><p>使用方法一</p><ul><li>将所有PHY块连接到PUB。PUB自动计算每个块的环形振荡器频率，并输出结果。这个过程是并行进行的，可以快速完成多个测试。</li></ul></li><li><p>使用方法二</p><ul><li>如果选择直接观察分频后的时钟信号，测试人员需要逐个连接每个PHY块，并观察其时钟波形。这意味着在测试过程中，必须一一检查，耗时较长。</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>这段描述强调了测试DDL的两种方法的优缺点。在生产测试中，自动计算频率的方法能够提高效率，而直接观察时钟波形则适合调试和特性测试场景。选择合适的方法可以有效地优化测试过程。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCDL</title>
      <link href="/2024/10/27/LCDL/"/>
      <url>/2024/10/27/LCDL/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>LCDL校准是一种用于调整和优化延迟线（Delay Line）的技术，以确保信号的时序准确。以下是校准流程的详细步骤解释：</p></blockquote><p><img src="https://s2.loli.net/2024/10/27/kiOyUTZ6Dw98gbu.png" alt="image-20241027223625640"></p><h4 id="1-初始状态"><a href="#1-初始状态" class="headerlink" title="1. 初始状态"></a>1. 初始状态</h4><ul><li><strong>复位状态</strong><ul><li>在配置复位期间（当<code>cfg_rst_n</code>被置为有效时），LCDL状态机处于空闲状态，直到复位解除。解除复位后，状态机仍然处于空闲状态，直到从主校准状态机触发LCDL校准。</li></ul></li><li><strong>初始延迟选择</strong><ul><li>初始的延迟选择值设置为最大LCDL值的一半。这为后续的校准提供了一个起始参考点。</li></ul></li></ul><h4 id="2-启动校准时钟"><a href="#2-启动校准时钟" class="headerlink" title="2. 启动校准时钟"></a>2. 启动校准时钟</h4><ul><li><strong>校准时钟的使能</strong><ul><li>首先启用校准时钟，但不启用测量。这一过程用于重置LCDL内部的校准测量触发器。校准时钟启用的时长由<code>PTR2.tCALON</code>定义。</li></ul></li><li><strong>定时等待</strong><ul><li>一旦<code>tCALON</code>时间结束，校准时钟被禁用。之后，会有一个可编程的保持时间<code>PTR2.tCALH</code>，在进入下一步之前等待。</li></ul></li></ul><h4 id="3-启用校准测量逻辑"><a href="#3-启用校准测量逻辑" class="headerlink" title="3. 启用校准测量逻辑"></a>3. 启用校准测量逻辑</h4><ul><li><strong>使能校准</strong><ul><li>重置完成后，发出<code>cal_en</code>信号以启用校准测量逻辑。在启用时，需等待一个可编程的设定时间<code>PTR2.tCALS</code>，以确保信号稳定。</li></ul></li></ul><h4 id="4-等待测量完成"><a href="#4-等待测量完成" class="headerlink" title="4. 等待测量完成"></a>4. 等待测量完成</h4><ul><li><strong>轮询结果</strong>：<ul><li>状态机通过轮询<code>cal_en_out</code>信号来等待校准完成。信号的上升沿表示校准时钟已经通过LCDL延迟单元并注册了校准使能信号。此时表示测量操作已完成。</li></ul></li><li><strong>信号同步</strong>：<ul><li>注意，<code>cal_en_out</code>会在使用之前与PHYCTL时钟域同步，而<code>cal_out</code>信号因为其稳定性，使用时无需同步。</li></ul></li></ul><h4 id="5-评估测量结果"><a href="#5-评估测量结果" class="headerlink" title="5. 评估测量结果"></a>5. 评估测量结果</h4><ul><li><strong>延迟调整</strong>：<ul><li>测量完成后，状态机根据结果决定是否需要增加或减少延迟：<ul><li>如果值为<code>1</code>，说明延迟超过一个时钟周期，需减少延迟。</li><li>否则，说明测量的延迟小于一个时钟周期，需增加延迟。</li></ul></li></ul></li><li><strong>搜索类型</strong>：<ul><li>调整延迟的操作基于<code>PGCR8.DCALTYPE</code>中编程的搜索类型。可选择二进制搜索或线性搜索。</li></ul></li></ul><h4 id="6-搜索完成条件"><a href="#6-搜索完成条件" class="headerlink" title="6. 搜索完成条件"></a>6. 搜索完成条件</h4><ul><li><p><strong>二进制搜索</strong>：</p><ul><li>当添加或减去延迟选择值为<code>1</code>时，搜索完成。</li></ul></li><li><p><strong>线性搜索</strong>：</p><ul><li>当检测到<code>cal_out</code>的正边沿或测试到最小或最大延迟选择值时，搜索完成。</li></ul></li><li><p><strong>重复测量</strong>：</p><ul><li>否则，返回步骤2，用新的延迟选择值重复测量过程。</li></ul><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2></li></ul><p><img src="https://s2.loli.net/2024/10/27/p6yrVPGxXdoBQWq.png" alt="image-20241027223726826"></p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设我们需要校准一个LCDL，其最大延迟值为100个时钟周期。</p><ol><li><strong>复位状态</strong>：LCDL状态机处于空闲状态，初始延迟选择设置为50个时钟周期（最大值的一半）。</li><li><strong>启动校准时钟</strong>：启用校准时钟，持续5个时钟周期（<code>PTR2.tCALON</code>），然后禁用。</li><li><strong>启用校准</strong>：发出<code>cal_en</code>信号以启用测量，设定稳定时间为2个时钟周期（<code>PTR2.tCALS</code>）。</li><li><strong>等待完成</strong>：状态机轮询<code>cal_en_out</code>信号，直到检测到信号上升沿。</li><li><strong>评估结果</strong><ul><li>假设测量结果表明延迟值为<code>1</code>，则调整选择值减少1（新的选择值为49）。</li></ul></li><li><strong>搜索完成</strong><ul><li>在二进制搜索中，继续增加或减少延迟，直到找到合适的延迟选择值为止。</li></ul></li></ol><blockquote><p> 这个过程会重复进行，直到校准完成，确保LCDL能够准确反映信号时序要求。通过这样的校准，系统可以优化其性能，确保数据传输的稳定性和可靠性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR BIST</title>
      <link href="/2024/10/27/DDR-BIST/"/>
      <url>/2024/10/27/DDR-BIST/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>BIST 模块是一个可编程的内置自检引擎，它为应用程序提供了一种测试 PHY 和 I&#x2F;O 的方法，以进行高速生产测试。PHY 发送和接收路径的测试是通过环回实现的。还有一个可选功能用于测试外部存储器。</p></blockquote><blockquote><p>字节通道预期数据、读取比较和错误计数器在读取状态块内实现，并由所有其他内部PUB模块共享。</p></blockquote><p><img src="https://s2.loli.net/2024/10/27/YetQxkAZNB3UpMy.png" alt="image-20241027222629770"></p><h3 id="BIST（内建自测试）的操作模式"><a href="#BIST（内建自测试）的操作模式" class="headerlink" title="BIST（内建自测试）的操作模式"></a>BIST（内建自测试）的操作模式</h3><blockquote><p> BIST（Built-In Self-Test）是一种用于测试和验证集成电路功能的技术。根据所述信息，BIST有两种操作模式：环回模式（Loopback Mode）和DRAM模式（DRAM Mode）。以下是对这两种模式的详细解释。</p></blockquote><h3 id="环回模式（Loopback-Mode）"><a href="#环回模式（Loopback-Mode）" class="headerlink" title="环回模式（Loopback Mode）"></a><strong>环回模式</strong>（Loopback Mode）</h3><ul><li><strong>定义</strong>：<ul><li>在环回模式下，DATXn的写路径在输入&#x2F;输出（I&#x2F;O）端口之间进行环回，即将数据写入的信号直接送回到接收路径中。同时，AC（地址和控制）输出路径也通过I&#x2F;O环回到专用的AC环回逻辑。</li></ul></li><li><strong>功能</strong>：<ul><li>这种模式允许BIST在不使用外部内存的情况下，发送数据模式并比较从PHY（物理层）环回的数据。这意味着BIST可以在整个数据通路中进行自我测试，确保各个部分之间的数据传输是正确的。</li></ul></li><li><strong>应用</strong>：<ul><li>环回模式适用于在测试阶段验证PHY的功能，特别是在没有连接外部内存的情况下。它可以帮助设计人员快速检查设计中的错误或问题。</li></ul></li><li><strong>最小写入延迟&#x2F;读取延迟（WL&#x2F;RL）</strong>：<ul><li>在环回模式下，支持的最小写入延迟和读取延迟为6，这意味着在测试过程中，数据传输的延迟最少需要达到6个时钟周期。</li></ul></li></ul><h3 id="DRAM模式（DRAM-Mode"><a href="#DRAM模式（DRAM-Mode" class="headerlink" title="DRAM模式（DRAM Mode)"></a><strong>DRAM模式（DRAM Mode)</strong></h3><ul><li><strong>定义</strong>：<ul><li>在DRAM模式下，BIST进行正常的写入和读取事务，将数据写入到外部DRAM中，然后比较读取回来的数据。</li></ul></li><li><strong>功能</strong>：<ul><li>这种模式允许测试外部内存的功能，确保内存的读写操作正常工作。BIST发送写入命令，然后从DRAM读取数据，并将读取的数据与发送的数据进行比较，以验证内存的正确性。</li></ul></li><li><strong>地址&#x2F;命令通道的环回</strong>：<ul><li>在DRAM模式下，地址和命令通道仍然在I&#x2F;O端口进行环回。这意味着尽管数据是在外部DRAM中传输，地址和命令仍然经过BIST进行内部测试，以确保控制信号的正确性。</li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>BIST的环回模式和DRAM模式提供了两种不同的测试方法：</p></blockquote><ul><li><strong>环回模式</strong>：用于在没有外部内存的情况下测试PHY的内部逻辑，通过环回来验证数据传输的完整性。</li><li><strong>DRAM模式</strong>：用于实际测试外部DRAM的读写操作，通过发送和接收数据来验证内存的功能。</li></ul><blockquote><p>这两种模式使得BIST能够灵活地适应不同的测试需求，帮助设计人员确保硬件的可靠性和性能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Gate Training</title>
      <link href="/2024/10/27/Basic%20Gate%20Training/"/>
      <url>/2024/10/27/Basic%20Gate%20Training/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>基础门控训练(Basic Gate Training)是一种确保DDR内存系统能够在不同延迟条件下准确读取数据的机制。其目标是通过调节DQS门控信号的时序来找到一个最佳的位置，以避免由于时延不一致引起的数据错误。以下是该过程的详细步骤和说明。</p></blockquote><h3 id="训练过程的主要步骤"><a href="#训练过程的主要步骤" class="headerlink" title="训练过程的主要步骤"></a>训练过程的主要步骤</h3><p><a><strong>1. 初始设置：</strong></a></p><ul><li>从最小延迟设置开始，DQS门控的初始位置为左侧（延迟最少）。</li><li>训练分为两个阶段：首先确定左侧（最少延迟）的位置，然后确定右侧（最多延迟）的位置。</li></ul><p><a><strong>2. 确定左侧有效位置：</strong></a></p><ul><li>从左侧开始，以1&#x2F;8个DDR时钟周期的增量向右移动门控，直到读取事务成功。</li><li>记录下当前成功的右边界位置，以及上一个失败的左边界位置。</li><li>在这两个边界之间进行进一步搜索，使用二分搜索算法加速过程，找到左侧有效位置（门控关闭位置）。</li></ul><p><a><strong>3. 确定右侧有效位置：</strong></a></p><ul><li>一旦找到左侧有效位置，接下来从右侧（延迟更多的一端）开始，将门控位置向右移动1&#x2F;4个DDR时钟周期，避免由于抖动引起的读取不稳定区域。</li><li>接着，继续向右移动，以1&#x2F;8个DDR时钟周期的增量，直到读取事务失败。</li><li>记录当前的右边界位置，使用与之前相同的二分搜索算法来确定右侧有效位置（门控开启位置）。</li></ul><p><a><strong>4. 读取验证与稳定性检查：</strong></a></p><ul><li>为了避免错误的读取结果，门控位置会在多个读取中进行验证。如果在某个位置上有一次读取失败，则认为该位置不正确。</li><li>可以通过设置DTCR.DTRPTN控制每个门控位置评估的额外读取次数。</li><li>通过DTCR.DTCMPD控制是否在门控位置评估过程中比较读取数据与期望数据。</li></ul><p><a><strong>5. 时钟周期计算：</strong></a></p><ul><li>DDR时钟周期是从DQS门控时钟周期（DXnGSR0.GDQSPRD）得出的，延迟计算基于此周期值。</li></ul><p><a><strong>6. 重置训练：</strong></a></p><ul><li>当基础门控训练被触发时，所有当前的门控训练结果都会被丢弃，算法会从头开始训练。</li></ul><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><blockquote><p>假设有一个DDR内存系统，DQS门控的时钟周期tCK为1ns。整个训练过程可以描述如下：</p></blockquote><h4 id="初始设置："><a href="#初始设置：" class="headerlink" title="初始设置："></a>初始设置：</h4><blockquote><p>DQS门控初始位置设置为0ns。</p></blockquote><h5 id="寻找左侧有效位置："><a href="#寻找左侧有效位置：" class="headerlink" title="寻找左侧有效位置："></a>寻找左侧有效位置：</h5><ul><li>从0ns开始，以1&#x2F;8个DDR时钟周期（0.125ns）向右移动：<ul><li>位置0ns：成功读取（记录为当前右边界）。</li><li>位置0.125ns：成功读取（记录为当前右边界）。</li><li>位置0.25ns：成功读取（记录为当前右边界）。</li><li>位置0.375ns：失败读取（记录为当前左边界）。</li></ul></li><li>通过二分搜索，确认左侧有效位置可能在0.25ns附近，确定该位置为0.25ns。</li></ul><h5 id="寻找右侧有效位置："><a href="#寻找右侧有效位置：" class="headerlink" title="寻找右侧有效位置："></a>寻找右侧有效位置：</h5><ul><li>从0.375ns开始，向右移动1&#x2F;4个DDR时钟周期（0.25ns）：<ul><li>新位置为0.625ns，继续读取，成功读取。</li><li>移动到0.75ns，成功读取。</li><li>移动到0.875ns，成功读取。</li><li>移动到1ns，失败读取（当前右边界为0.875ns）。</li></ul></li><li>再次使用二分搜索，找到右侧有效位置为0.875ns。</li></ul><h5 id="确定最终门控位置："><a href="#确定最终门控位置：" class="headerlink" title="确定最终门控位置："></a>确定最终门控位置：</h5><ul><li>最终的门控位置取左侧和右侧有效位置的中位数，即(0.25ns + 0.875ns) &#x2F; 2 &#x3D; 0.5625ns。</li></ul><h5 id="验证门控位置："><a href="#验证门控位置：" class="headerlink" title="验证门控位置："></a>验证门控位置：</h5><ul><li>在位置0.5625ns进行多次读取验证，如果所有读取均成功，则该门控位置被确认有效。</li></ul><blockquote><p>通过这一系列步骤，基础门控训练确保了DQS信号的门控位置能够在不同的电路条件下保持准确性，提高了DDR内存系统的可靠性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQS Gate Training</title>
      <link href="/2024/10/27/DQS%20Gate%20Training/"/>
      <url>/2024/10/27/DQS%20Gate%20Training/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>DQS Gate Training是DDR内存系统中一种关键的训练机制，旨在通过抑制噪声和准确捕获读取数据来优化数据传输。由于在读取路径中的延迟（例如电路板的走线长度）常常不精确，因此需要对门控（Gate）进行训练，以确保它与读取数据精确对齐。</p></blockquote><h4 id="主要组成部分"><a href="#主要组成部分" class="headerlink" title="主要组成部分"></a>主要组成部分</h4><blockquote><p><strong>DQS门控：</strong></p><ul><li>DQS（数据选通信号）用于同步读数据。门控信号控制在何时允许数据被读取和采样，以抑制噪声影响。</li></ul></blockquote><blockquote><p><strong>训练机制:</strong></p><ul><li>DDR4 PHY解决方案提供了一种内置的DQS门控训练单元，可以在初始化过程中或通过软件&#x2F;内存控制器触发（使用PIR寄存器）。</li><li>提供了两种训练机制：基础门控训练（Basic Gate Training）和读取定级（Read-Leveling）</li></ul></blockquote><h4 id="基础门控训练（Basic-Gate-Training）"><a href="#基础门控训练（Basic-Gate-Training）" class="headerlink" title="基础门控训练（Basic Gate Training）"></a>基础门控训练（Basic Gate Training）</h4><ul><li><p>执行过程：</p><ul><li>执行一系列读取事务，通过在可能的门控位置上扫描DQS门，以发现一个合适的门控位置，使读取操作成功。</li><li>由于可能的位置数量非常大（最多可达到9个tCK周期的延迟线tap），因此使用二分搜索算法加速搜索过程。</li></ul></li><li><p>具体步骤：</p><ul><li>启动训练，系统将尝试不同的门控延迟位置。</li><li>对于每个延迟位置，进行读取事务并监测读取成功与否。</li><li>通过二分搜索算法有效地缩小可能的延迟范围，找到最佳的门控位置。</li></ul></li></ul><h4 id="读取定级（Read-Leveling）"><a href="#读取定级（Read-Leveling）" class="headerlink" title="读取定级（Read-Leveling）"></a>读取定级（Read-Leveling）</h4><ul><li><p>执行过程：</p><ul><li>采用采样窗口技术来识别读取DQS的上升沿，并确定门控位置。</li><li>读取定级不检查读取数据的正确性，而是关注DQS信号本身的时间对齐。</li></ul></li><li><p>具体步骤：</p><ul><li>对DQS信号进行采样，寻找最佳的时机以确保读取的数据在门控开启时被准确采样。</li><li>在整个过程中，读取数据的准确性并不是重点，主要是确保DQS与读取数据的时间对齐。</li></ul></li><li><p>同步训练</p><ul><li>同时训练所有字节通道：这两个算法都同时训练所有字节通道，确保在每个rank中，所有字节的DQS信号都被有效地门控。</li></ul></li></ul><blockquote><p>逐个训练rank：在共享AC双通道模式下，相关的每个rank也会逐个训练。</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>DQS Gate Training通过精确对齐门控信号和读取数据，提高了DDR内存的信号完整性和性能。通过基础门控训练和读取定级的结合，系统能够有效处理不确定性并优化数据传输过程。基础门控训练负责找到合适的门控位置，而读取定级确保信号的同步，为高效稳定的数据传输奠定基础。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Write Leveling</title>
      <link href="/2024/10/27/leveling/"/>
      <url>/2024/10/27/leveling/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>DDR（双倍数据速率）内存的写入定级（Write Leveling）是一种用于补偿时钟信号与数据信号之间的时延偏差的技术。在多个SDRAM DDR3&#x2F;DDR4系统中，由于信号必须按顺序从一个SDRAM路由到下一个SDRAM，可能会导致时钟信号（CK）和数据选通信号（DQS）之间的偏移。这种偏移可能会影响时序要求，例如tDQSS、tDSS和tDSH。写入定级算法的目标就是在每个SDRAM处重新对齐时钟和数据选通信号。</p></blockquote><h4 id="写入定级的算法步骤"><a href="#写入定级的算法步骤" class="headerlink" title="写入定级的算法步骤"></a>写入定级的算法步骤</h4><ul><li><p><strong>进入写入定级模式</strong>：将一个内存rank中的所有SDRAM都置于写入定级模式。</p></li><li><p><strong>发送DQS脉冲</strong>：向DRAM发送DQS_t&#x2F;DQS_c脉冲，同时逐步增加这些信号的延迟。</p></li><li><p><strong>检测0到1的过渡</strong>：在反馈结果中查找DQS信号的0到1过渡。这个过渡点表明CK的上升沿在DQS的上升沿之后的某个时刻采样到了DQS信号。</p></li><li><p><strong>稳定性检查</strong>：为了确保结果的稳定性，算法要求在8个连续的tap延迟中，采样值为1的稳定时间，或者在DXnGSR0.WLPRD个连续tap延迟中，这个值可以通过DTCR1.WLVLDPRD选择。这样可以过滤掉抖动和毛刺。</p></li></ul><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><blockquote><p>假设我们有一个包含4个SDRAM芯片的rank，它们的DQS信号需要进行写入定级。</p></blockquote><p><a>1. <strong>进入写入定级模式</strong>：</a>将所有4个SDRAM芯片设置为写入定级模式。</p><p><a>2. <strong>发送脉冲并增加延迟</strong>：</a></p><ul><li>初始情况下，DQS_t&#x2F;DQS_c信号的延迟为0ns，发送脉冲。</li><li>监测反馈结果，假设没有检测到0到1的过渡。</li><li>将DQS_t&#x2F;DQS_c的延迟增加到1ns，发送脉冲，继续监测反馈结果。</li><li>逐渐增加延迟，直到在某个时刻（例如3ns）检测到0到1的过渡。</li></ul><p><a>3. <strong>稳定性验证</strong>：</a>一旦检测到0到1的过渡，算法会继续监测在接下来的8个tap延迟中，DQS信号是否稳定为1。如果是，则确认该延迟为有效延迟。</p><blockquote><p>通过这种方式，写入定级算法能够有效地补偿时钟和数据之间的延迟偏差，确保信号的可靠性和系统的稳定性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR DLL</title>
      <link href="/2024/10/27/ddr-dll/"/>
      <url>/2024/10/27/ddr-dll/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="延迟线校准概述"><a href="#延迟线校准概述" class="headerlink" title="延迟线校准概述"></a>延迟线校准概述</h3><blockquote><p>在数字电路，尤其是在高速内存控制器的设计中，延迟线校准是一个重要步骤，以确保时钟和数据之间的时序匹配。以下是对延迟线校准过程的详细解释：</p></blockquote><h4 id="1-PLL锁定后的校准触发"><a href="#1-PLL锁定后的校准触发" class="headerlink" title="1. PLL锁定后的校准触发"></a>1. PLL锁定后的校准触发</h4><ul><li><strong>PLL锁定</strong>：<ul><li>当相位锁定环（PLL）成功锁定时，意味着时钟信号已稳定，系统可以开始其他初始化任务。</li></ul></li><li><strong>触发校准</strong>：<ul><li>延迟线校准可以通过写入PIR（PHY Initialization Register）寄存器来触发。这通常在PLL锁定后进行，以确保校准的准确性。</li></ul></li></ul><h4 id="2-校准的重要性"><a href="#2-校准的重要性" class="headerlink" title="2. 校准的重要性"></a>2. 校准的重要性</h4><ul><li><strong>在初始化之前</strong>：<ul><li>延迟线必须在任何进一步的初始化任务之前完成校准，特别是涉及高速控制器时钟的任务。这样可以确保在访问内存或执行其他高速操作时，信号的时序是准确的。</li></ul></li><li><strong>绕过校准</strong>：<ul><li>用户可以选择通过设置PIR寄存器中的<code>DCALPSE</code>位来绕过延迟线校准。但如果选择绕过，用户必须确保在访问内存之前，延迟线在后续阶段得到了校准。</li></ul></li></ul><h4 id="3-局部校准延迟线（LCDL）"><a href="#3-局部校准延迟线（LCDL）" class="headerlink" title="3. 局部校准延迟线（LCDL）"></a>3. 局部校准延迟线（LCDL）</h4><ul><li><strong>独立校准</strong>：<ul><li>每个LCDL都需要针对SDRAM时钟周期进行校准。这意味着要测量延迟线的步数，以产生等于DDR时钟周期的延迟。</li></ul></li><li><strong>校准过程</strong>：<ul><li>每个LCDL的校准是独立进行的，确保每条延迟线都能精确匹配其对应的时钟信号。</li></ul></li></ul><h4 id="4-校准的执行"><a href="#4-校准的执行" class="headerlink" title="4. 校准的执行"></a>4. 校准的执行</h4><ul><li><strong>初始化序列的一部分</strong>：<ul><li>通常，延迟线校准是PHY初始化序列的一部分，具体过程在相应的文档中描述。这个初始化过程包括各种步骤，确保PHY和连接的内存能够正常工作。</li></ul></li><li><strong>用户触发</strong>：<ul><li>用户可以随时通过将PIR寄存器中的校准位（<code>DCAL</code>）设置为<code>1</code>来手动触发延迟线校准。这提供了灵活性，使得用户在需要时可以进行额外的校准。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>延迟线校准是在高速内存系统中确保数据传输可靠性的重要步骤。通过在PLL锁定后触发延迟线校准，系统可以确保在执行任何内存访问或高速操作之前，所有时序都是准确的。绕过校准虽然是可选的，但必须在后续操作之前确保延迟线的校准，以避免潜在的时序问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR Traning</title>
      <link href="/2024/10/22/DDR-Traning/"/>
      <url>/2024/10/22/DDR-Traning/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="DDR-Training概述"><a href="#DDR-Training概述" class="headerlink" title="DDR Training概述"></a><a>DDR Training概述</a></h3><blockquote><p>DDR使用的是并行接口进行数据传输，这意味着多个数据位（64bits或者是128bits）同时在一组信号线上进行传输。随着总线频率的增加，信号在PCB(印刷电路板)上的传输变得更加复杂，因为PCB走线的长度差异，PVT（工艺，电压，温度）变化等因素会导致信号传播时间（即延迟）的差异。</p></blockquote><blockquote><p>当信号时序没有被正确对齐，或者是信号质量因为上述的原因而下降的时候，DDR控制器在采样点读取的数据可能会出错，导致读写操作异常，这是因为DDR在每个时钟周期的上升沿和下降沿都会进行数据传输，任何微小的时序偏差都可能导致数据被错误地采集。</p></blockquote><blockquote><p>为了解决上述问题，DDR系统就引入了Traning机制。Traning的主要目的是在DDR初始化过程中，动态调整DRAM与PHY之间的数据与地址命令信号线的时序关系，以确保信号在正确的时间被采样。</p></blockquote><h4 id="training的大致流程："><a href="#training的大致流程：" class="headerlink" title="training的大致流程："></a>training的大致流程：</h4><p><img src="https://s2.loli.net/2024/10/22/irSe9UZcqAGflL1.png" alt="image-20241022203829731"></p><h4 id="记住下面几个问题"><a href="#记住下面几个问题" class="headerlink" title="记住下面几个问题"></a>记住下面几个问题</h4><blockquote><ul><li><a style="color: red">Traning的目的是什么</a></li><li><a style="color: red">Traning调节是什么，反馈是什么</a></li><li><a style="color: red">协议规定的是什么</a></li><li><a style="color: red">具体的实现是什么</a></li></ul></blockquote><h4 id="Training的对象"><a href="#Training的对象" class="headerlink" title="Training的对象"></a>Training的对象</h4><p><img src="https://s2.loli.net/2024/10/22/jsCt6QMGeIXEPUf.png" alt="image-20241022204755366"></p><blockquote><p>对象是DDR PHY和DRAM之间的交互信号线</p></blockquote><ul><li>CK：时钟信号</li><li>CS：片选信号，RANK选择</li><li>AC：Address和Command</li><li>DQS：对数据的采样信号</li><li>DQ：数据线</li><li>Alert：用于training过程中，反馈DCS和DCA到达RCD的回应。正式业务场景是不需要的（这个就像是上面流程图的反馈，当然反馈的功能不只是training，有时候这个信号也会作为ecc的反馈）。</li></ul><p><a>整理之后的training流程</a></p><p><img src="https://s2.loli.net/2024/10/22/VeFAOu2iY8zNJfo.png" alt="image-20241022205033448"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法</title>
      <link href="/2024/10/20/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/10/20/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>在 Python 中，你不需要显式声明变量类型。变量名可以直接赋值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="string">&quot;lin&quot;</span></span><br><span class="line">c = <span class="number">2.34</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字：整数（int），浮点数（float），复数（complex）</span></span><br><span class="line">a = <span class="number">10</span> <span class="comment"># int</span></span><br><span class="line">b = <span class="number">3.23</span> <span class="comment"># float</span></span><br><span class="line">c = <span class="number">2</span> + <span class="number">3j</span> <span class="comment"># complex</span></span><br><span class="line"><span class="comment"># 字符串：单引号或者是双引号表示</span></span><br><span class="line">s = <span class="string">&quot;zlin&quot;</span></span><br><span class="line"><span class="comment"># 列表： 有序集合，可以包含不同的元素</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="string">&quot;fuour&quot;</span>, <span class="number">3.2</span>]</span><br><span class="line"><span class="comment"># 元组：有序且不可变的集合</span></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;sdf&quot;</span>)</span><br><span class="line"><span class="comment"># 字典：键值对的集合</span></span><br><span class="line"> dic = &#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;zlin&quot;</span>,  <span class="string">&quot;age&quot;</span> : <span class="number">23</span>&#125;</span><br><span class="line"><span class="comment"># 集合：无序且不重复的元素集合</span></span><br><span class="line"><span class="built_in">set</span> = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">#布尔值：True和False</span></span><br><span class="line">is_true = <span class="literal">True</span></span><br><span class="line">is_false = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>读取文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;zlin.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">content = file.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure></li><li>写入文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;zlin.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(<span class="string">&quot;hhh&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><ul><li>是一种简洁的方式来创建列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><ul><li>一种快速简洁的方式来创建字典<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;x: x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure></li></ul><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><ul><li>一种集合的简洁方式来创建集合<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> = &#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言运算符优先级</title>
      <link href="/2024/10/20/c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2024/10/20/c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存的基本概念</title>
      <link href="/2024/10/20/%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/10/20/%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="DIMM"><a href="#DIMM" class="headerlink" title="DIMM"></a>DIMM</h3><blockquote><p>DIMM即Dual In-Line Memory Module，即内存条印刷电路板正反面均有金手指与主板上的内存条槽相接触的结构。内存条也有人叫DIMM条，主板上的内存槽也有人称为DIMM槽。除了有DIMM，还有SIMM（Single In-Line Memory Module)。</p></blockquote><h3 id="SODIMM"><a href="#SODIMM" class="headerlink" title="SODIMM"></a>SODIMM</h3><blockquote><p>对于笔记本电脑，使用普通内存条会使笔记本尺寸过大，而直接使用内存颗粒则不便于扩展与维修，SODIMM应运而生，SODIMM是Small Outline DIMM，即小尺寸的DIMM。</p></blockquote><h3 id="Memory-Channel"><a href="#Memory-Channel" class="headerlink" title="Memory Channel"></a>Memory Channel</h3><blockquote><p>若干个DIMM可以连接到一组总线上，这组总线被称为内存通道（Memory Channel）。</p></blockquote><h3 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h3><blockquote><p>主板上放3条DIMM可以，但从第四条DIMM开始，因为走线距离过长的原因导致信号质量下降，因此，我们可以将两条物理DIMM的内存颗粒放在一块内存印刷电路板上。我们把这种逻辑DIMM称为Rank。为了支持多RANK的内存条，我们需要在物理DIMM接口上定义多个CS_N片选信号以选择相应的Rank。下图蓝色是Rank1的片选信号，黄色是Rank0的片选信号。</p></blockquote><p><img src="https://s2.loli.net/2024/10/20/QoV5wSBktCda4Xb.jpg" alt="img"></p><blockquote><p>因此，一个Rank就是指一组内存颗粒的CS信号被连在一起，并由内存控制器单独的一根CS_N信号控制，共同组成位宽为64bit（不带ECC）或72bit（带ECC）的存储阵列，共同完成一条内存通道下发的指令。注意，支持ECC功能的内存条除了64bit的数据外，还有8bit的校验数据。</p></blockquote><h3 id="RDIMM"><a href="#RDIMM" class="headerlink" title="RDIMM"></a>RDIMM</h3><blockquote><p>RDIMM的第一个字母R实际就是一颗额外的芯片，称为时钟缓存寄存器芯片（Registering Clock Driver)。没有该芯片的内存条一般被称为UDIMM（Unbuffered-DIMM）。这颗寄存器芯片主要用来缓存（buffer）时钟&#x2F;控制&#x2F;命令&#x2F;地址等信号。缓存的主要目的是解决信号质量以及负载过重的问题。RCD（时钟缓存寄存器芯片）</p></blockquote><h3 id="LRDIMM"><a href="#LRDIMM" class="headerlink" title="LRDIMM"></a>LRDIMM</h3><blockquote><p>为了是一根物理DIMM支持更多的Rank，我们将数据信号通过数据缓存（Data Buffer）芯片缓存，而不直接连接DRAM Devices，从而改善数据信号的质量，这种结构称之为LRDIMM。</p></blockquote><p><a><strong>总结一下，DIMM分为如下三种：</strong></a></p><ul><li>UDIMM</li></ul><blockquote><p>没有缓冲的存储模组（UnbufferDualInlineMemoryModule），简称UDIMM，存储模组上的全部信号线路可以和内存控制器的封装引脚直接进行连接。</p></blockquote><ul><li>RDIMM</li></ul><blockquote><p>RDIMM的第一个字母R实际就是一颗额外的芯片，称为时钟缓存寄存器芯片（Registering Clock Driver)。没有该芯片的内存条一般被称为UDIMM（Unbuffered-DIMM）。带寄存器的存储模组（RegisterDualInlineMemoryModule），简称RDIMM，特点是存储模组控制线路和地址线路先连接寄存器后再接入到控制器的封装引脚，而数据信号线路与控制器的封装引脚采用直接连接的方式。这样的设计不仅可以保证接入到内存控制器的信号受到很小的外界干扰，保证信号完整性。</p></blockquote><ul><li>LRDIMM</li></ul><blockquote><p>负载较低型存储模组（LoadReducedDualInlineMemoryModule），简称LRDIMM，模组上的全部信号总线先连接内存缓存器再连接控制器的封装引脚。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
          <category> Memory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDR </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get_response</title>
      <link href="/2024/10/20/get-response/"/>
      <url>/2024/10/20/get-response/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> SystemVerilog </category>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> SystemVerilog </tag>
            
            <tag> UVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make_run</title>
      <link href="/2024/10/19/make-run/"/>
      <url>/2024/10/19/make-run/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>make_soc</title>
      <link href="/2024/10/19/make-soc/"/>
      <url>/2024/10/19/make-soc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>svt_axi_vip</title>
      <link href="/2024/10/19/svt-axi-vip/"/>
      <url>/2024/10/19/svt-axi-vip/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> Programming </tag>
            
            <tag> UVM </tag>
            
            <tag> VIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svt_ahb_vip</title>
      <link href="/2024/10/19/svt-ahb-vip/"/>
      <url>/2024/10/19/svt-ahb-vip/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> UVM </tag>
            
            <tag> VIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svt_apb_vip</title>
      <link href="/2024/10/19/svt-apb-vip/"/>
      <url>/2024/10/19/svt-apb-vip/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> Programming </tag>
            
            <tag> UVM </tag>
            
            <tag> VIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR</title>
      <link href="/2024/10/19/DDR/"/>
      <url>/2024/10/19/DDR/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h1 id="DDR介绍"><a href="#DDR介绍" class="headerlink" title="DDR介绍"></a>DDR介绍</h1><h4 id="DDR子系统是由两个部分组成的，ddr-controller和ddr-phy。ddr-controller主要是负责承担CPU（或者说是外部）和memory系统之间进行数据交互时候的传输效率和调度的。ddr-phy主要是负责数据交换过程中的传输速度了。（如下图）"><a href="#DDR子系统是由两个部分组成的，ddr-controller和ddr-phy。ddr-controller主要是负责承担CPU（或者说是外部）和memory系统之间进行数据交互时候的传输效率和调度的。ddr-phy主要是负责数据交换过程中的传输速度了。（如下图）" class="headerlink" title="DDR子系统是由两个部分组成的，ddr controller和ddr phy。ddr controller主要是负责承担CPU（或者说是外部）和memory系统之间进行数据交互时候的传输效率和调度的。ddr phy主要是负责数据交换过程中的传输速度了。（如下图）"></a>DDR子系统是由两个部分组成的，ddr controller和ddr phy。ddr controller主要是负责承担CPU（或者说是外部）和memory系统之间进行数据交互时候的传输效率和调度的。ddr phy主要是负责数据交换过程中的传输速度了。（如下图）</h4><p><img src="https://s2.loli.net/2024/10/19/5WCbYzpnBrKU3M8.png" alt="img"></p><p>ddr phy主要是由两个部分来组成的，一个pub（soft ip）和另外一个phy（hard ip）。</p><p><img src="https://s2.loli.net/2024/10/19/N4Bph3x1SVvuyFr.png" alt="image-20241019182354234"></p><p>其中pub的结构如下图所示：</p><p><img src="https://s2.loli.net/2024/10/19/tqeWV5swdzvXAG2.png" alt="image-20241019182423919"></p><p>pub具有一下特点：</p><ul><li>不支持SDRAM的DLL off模式</li><li>数据通路的位宽以8bit的增量递增</li><li>支持最多4个rank</li><li>支持单数据通道或者双数据通道的配置</li><li>能够完成PHY的初始化，tranning以及控制逻辑</li><li>支持自动化的DQS Gate Tranning</li><li>支持Delay line和VT补偿</li><li>支持自动化的Write Leveing</li><li>支持自动化的Write，Read的data bit deskew</li><li>支持自动化的DQ&#x2F;DQS eye tranning</li><li>支持apb或者其他的通用接口配置寄存器</li><li>支持DFI接口</li></ul><h2 id="PUB模块实现初始化流程"><a href="#PUB模块实现初始化流程" class="headerlink" title="PUB模块实现初始化流程"></a>PUB模块实现初始化流程</h2><h3 id="DDR系统初始化"><a href="#DDR系统初始化" class="headerlink" title="DDR系统初始化"></a>DDR系统初始化</h3><p><img src="https://s2.loli.net/2024/10/19/M53dul89eLDIJyn.png" alt="image-20241019182857357"></p><p><img src="https://s2.loli.net/2024/10/19/kZ5zbw3nlfeBqR4.png" alt="image-20241019182913841"></p><p><img src="https://s2.loli.net/2024/10/19/eoq6BtyOYgSrh1j.png"><img src="https://s2.loli.net/2024/10/19/sD9fcjVyJOFwlvZ.png" alt="image-20241019182938780"><img src="https://s2.loli.net/2024/10/19/TWYxRvhF1EjzPVB.png"><img src="https://s2.loli.net/2024/10/19/bGQc4DjLaWzyqT6.png"><img src="https://s2.loli.net/2024/10/19/qXKekYH1EI4LW5r.png" alt="image-20241019183010016"><img src="https://s2.loli.net/2024/10/19/2hwVvX7fxRQDcFT.png" alt="image-20241019183016978"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile基础</title>
      <link href="/2024/10/19/Makefile/"/>
      <url>/2024/10/19/Makefile/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a><br>这是关于Makefile的基本用法</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="目标：依赖"><a href="#目标：依赖" class="headerlink" title="目标：依赖"></a>目标：依赖</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先检查tb.sv和dut.sv是不是存在，以及是否有修改。如果依赖有修改或者是目标不存在得时候，就执行下面得命令</span></span><br><span class="line"><span class="section">simv:tb.sv dut.sv</span></span><br><span class="line">vcs -full64 -sverilog tb.sv </span><br></pre></td></tr></table></figure><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:sim</span></span><br><span class="line"><span class="section">sim:simv</span></span><br><span class="line">    ./simv </span><br></pre></td></tr></table></figure><h3 id="ONESHELL"><a href="#ONESHELL" class="headerlink" title=".ONESHELL:"></a>.ONESHELL:</h3><ul><li>所有的指令就会在一个shell中执行了</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.ONESHELL:</span></span><br><span class="line"><span class="comment">#正常些指令</span></span><br></pre></td></tr></table></figure><h3 id="语句的回显问题"><a href="#语句的回显问题" class="headerlink" title="语句的回显问题"></a>语句的回显问题</h3><ul><li>可以在语句前面用”<strong>@</strong>“就行了，但是不想每个前面都打的话，就用.SILENT</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.SILENT: main all    # 后面是目标</span></span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="ifeq"><a href="#ifeq" class="headerlink" title="ifeq"></a>ifeq</h3><ul><li>判断一个变量是不是已经定义了</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OS = Linux</span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OS = Linux</span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifdef</span> Mac</span><br><span class="line">    OS= MacOS</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifdef</span> Mac</span><br><span class="line">    OS= MacOS</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    OS = Linux</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h3><ul><li>判断一个变量是不是没有定义</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version = 3.0</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(version)</span>,1.0)            <span class="comment"># ifeq后一定要一个空格</span></span><br><span class="line">    msg := 版本太旧了，请更新版本</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(version)</span>, 3.0)</span><br><span class="line">    msg := 版本太新了，也不行</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    msg := 版本可以用</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外的写法</span></span><br><span class="line">msg = Other</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;<span class="variable">$(OS)</span>&quot;</span> <span class="string">&quot;Windows_NT&quot;</span></span><br><span class="line">    msg = This is a Windows Platform</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> &#x27;<span class="variable">$(OS)</span>&#x27; &#x27;Windows_NT&#x27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> &#x27;<span class="variable">$(OS)</span>&#x27; <span class="string">&quot;Windows_NT&quot;</span></span><br></pre></td></tr></table></figure><h3 id="ifneq"><a href="#ifneq" class="headerlink" title="ifneq"></a>ifneq</h3><ul><li>判断两个值是不是不相等</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和上面的一样用法</span><br></pre></td></tr></table></figure><h2 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h2><h3 id="是二次展开，-是立即展开"><a href="#是二次展开，-是立即展开" class="headerlink" title="=是二次展开， :=是立即展开"></a><kbd>=</kbd>是二次展开， <kbd>:=</kbd>是立即展开</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只需要修改文件开头就行了，&quot;:=&quot;表示变量决定于它在makefile中的位置（顺序执行的），而&quot;=&quot;是makefile最后的位置</span></span><br><span class="line">tbfile := tb.sv env_pkg.sv test_pkg.sv</span><br><span class="line">rtlfile := dut.v a.v b.v</span><br><span class="line"><span class="section">simv: <span class="variable">$(tbfile)</span> <span class="variable">$(rtlfile)</span></span></span><br><span class="line">    vcs -full64 -sverilog <span class="variable">$(tbfile)</span> <span class="variable">$(rtlfile)</span></span><br></pre></td></tr></table></figure><h3 id="取消变量的定义"><a href="#取消变量的定义" class="headerlink" title="取消变量的定义"></a>取消变量的定义</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">undefine</span> &lt;变量名&gt;</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(USERNAME)</span></span><br></pre></td></tr></table></figure><h3 id="shell运行赋值"><a href="#shell运行赋值" class="headerlink" title="shell运行赋值"></a>shell运行赋值</h3><ul><li>使用<kbd>!=</kbd>，运行一个shell命令，返回值赋值给一个变量</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files != ls </span><br></pre></td></tr></table></figure><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files += linzhiwen.cpp</span><br></pre></td></tr></table></figure><h3 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h3><ul><li>条件赋值的**<kbd>?=</kbd>**,变量如果已经赋值了，那么就保持原来的值，如果没有就把右边的赋值给左边</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1 = 100</span><br><span class="line">var1 ?= 200</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo <span class="variable">$(var1)</span> </span><br></pre></td></tr></table></figure><h3 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h3><ul><li>语法：$(var:a&#x3D;b)，意思是将变量var的值中每一项结尾的a替换为b</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var = main.cpp a.cpp b.cpp</span><br><span class="line">objs := $(var:.cpp=.v) </span><br><span class="line">objes := $(var:%.cpp=%.v)</span><br></pre></td></tr></table></figure><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><ul><li>makefile中的所有的变量都可以通过终端传递，实现覆盖</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GUI=xxx</span><br></pre></td></tr></table></figure><h2 id="字符替换函数"><a href="#字符替换函数" class="headerlink" title="字符替换函数"></a>字符替换函数</h2><h3 id="subst"><a href="#subst" class="headerlink" title="subst"></a>subst</h3><ul><li>文本替换函数，返回替换后的文本</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> target,replacement,text)</span></span><br><span class="line">        <span class="comment">#--- 用relacement替换text中的target</span></span><br><span class="line">        <span class="comment">#--- target 需要替换的内容</span></span><br><span class="line">        <span class="comment">#--- replacement 替换为的内容</span></span><br><span class="line">        <span class="comment">#--- text 需要处理的内容，可以是任意字符串</span></span><br><span class="line"></span><br><span class="line">objs = main.o hello.o</span><br><span class="line">srcs = <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$(objs)</span>)</span></span><br><span class="line">headers = <span class="variable">$(<span class="built_in">subst</span> .cpp,.h,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(srcs)</span></span><br><span class="line">    @echo <span class="variable">$(headers)</span></span><br></pre></td></tr></table></figure><h3 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h3><ul><li>模式替换， 返回替换后的文本</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br><span class="line">        <span class="comment">#--- pattern 需要替换的模式</span></span><br><span class="line">        <span class="comment">#--- replacement 需要替换为</span></span><br><span class="line">        <span class="comment">#--- text 待处理内容，各项内容需要用空格隔开</span></span><br><span class="line">objs = main.ohello.o</span><br><span class="line">srcs = <span class="variable">$(<span class="built_in">subst</span> %.o,%.cpp,<span class="variable">$(objs)</span>)</span></span><br><span class="line">headers = <span class="variable">$(<span class="built_in">subst</span> %.cpp,%.h,<span class="variable">$(srcs)</span>)</span>  </span><br></pre></td></tr></table></figure><h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><ul><li>去除字符串头部和尾部的空格，中间如果连续有多个空格，则用一个空格替换，返回去除空格后的文本</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> string)</span></span><br><span class="line">        <span class="comment">#--- string 需要去除空格的字符串</span></span><br><span class="line">files = aa hello.cpp      main.cpp     test.cpp</span><br><span class="line">files := <span class="variable">$(<span class="built_in">subst</span> aa,        ,<span class="variable">$(files)</span>)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h3><ul><li>查找字符串，如果找到了，则返回对应的字符串，如果没找到，则反回空串</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> find,string)</span></span><br><span class="line">        <span class="comment">#--- find 需要查找的字符串</span></span><br><span class="line">        <span class="comment">#--- string 用来查找的内容</span></span><br><span class="line">files = hello.cpp main.cpp test.cpp</span><br><span class="line">find = <span class="variable">$(<span class="built_in">findstring</span> hel,<span class="variable">$(files)</span>)</span></span><br><span class="line">find = <span class="variable">$(<span class="built_in">findstring</span> HEL,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul><li>从文本中筛选出符合模式的内容并返回</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern…,text)</span></span><br><span class="line">        <span class="comment">#--- pattern 模式，可以有多个，用空格隔开</span></span><br><span class="line">        <span class="comment">#--- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理</span></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">filter</span> %.o %.h,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h3><ul><li>与filter相反，过滤掉符合模式的，返回剩下的内容</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern…,text)</span></span><br><span class="line">        <span class="comment">#--- pattern 模式，可以有多个，用空格隔开</span></span><br><span class="line">        <span class="comment">#--- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">filter</span>-out %.o %.cpp,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li>将文本内的各项按字典顺序排列，并且移除重复项</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> list)</span></span><br><span class="line">       <span class="comment"># --- list 需要排序内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">sort</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="word"><a href="#word" class="headerlink" title="word"></a>word</h3><ul><li>用于返回文本中第n个单词</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> n,text)</span></span><br><span class="line">        <span class="comment"># --- n 第n个单词，从1开始，如果n大于总单词数，则返回空串</span></span><br><span class="line">        <span class="comment"># --- text 待处理文本</span></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">word</span> 3,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h3><ul><li>用于返回文本指定范围内的单词列表</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> start,end,text)</span></span><br><span class="line">        <span class="comment">#--- start 起始位置，如果大于单词总数，则返回空串</span></span><br><span class="line">        <span class="comment">#--- end 结束位置，如果大于单词总数，则返回起始位置之后全部，如果start &gt; end，什么都不返回</span></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wordlist</span> 3,6,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="words"><a href="#words" class="headerlink" title="words"></a>words</h3><ul><li>返回文本中单词数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(words text)</span></span><br><span class="line">       <span class="comment"># --- text 需要处理的文本</span></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">nums = <span class="variable">$(words <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h3><ul><li>返回第一个单词</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> text)</span></span><br></pre></td></tr></table></figure><h3 id="lastword"><a href="#lastword" class="headerlink" title="lastword"></a>lastword</h3><ul><li>返回最后一个单词</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">lastword</span> text)</span></span><br></pre></td></tr></table></figure><h2 id="文件名处理函数"><a href="#文件名处理函数" class="headerlink" title="文件名处理函数"></a>文件名处理函数</h2><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><ul><li>返回文件目录</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> files)</span></span><br><span class="line">        <span class="comment">#--- files 需要返回目录的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp</span><br><span class="line"></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h3><ul><li>返回除了目录部分的文件名</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> files)</span></span><br><span class="line">        <span class="comment">#--- files 需要返回文件列表，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h3><ul><li>返回文件后缀名，如果没有后缀返回空</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> files)</span></span><br><span class="line">        <span class="comment">#--- files 需要返回后缀的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">suffix</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><ul><li>返回除了文件名字后缀的部分</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> files)</span></span><br><span class="line">       <span class="comment"># --- files 需要返回的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">basename</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h3><ul><li>给文件名字添加后缀</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> <span class="built_in">suffix</span>,files)</span></span><br><span class="line">        <span class="comment">#--- suffix 需要添加的后缀</span></span><br><span class="line">        <span class="comment">#--- files 需要添加后缀的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">addsuffix</span> .exe,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h3><ul><li>给文件名字添加前缀</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> prefix,files)</span></span><br><span class="line">        <span class="comment">#--- prefix 需要添加的前缀</span></span><br><span class="line">        <span class="comment">#--- files 需要添加前缀的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">addprefix</span> make/,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><ul><li>将两个列表中的内容一对一连接，如果两个列表内容数量不相等，则多出来的部分原样返回</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> list1,list2)</span></span><br><span class="line">        <span class="comment">#--- list1 第一个列表</span></span><br><span class="line">        <span class="comment">#--- list2 需要连接的第二个列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = hello main test</span><br><span class="line">f2 = .cpp .hpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">join</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><ul><li>返回符合通配符号的文件列表</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span></span><br><span class="line">        <span class="comment">#--- pattern 通配符</span></span><br><span class="line"></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> *)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> src/*.cpp)</span></span><br></pre></td></tr></table></figure><h3 id="realpath"><a href="#realpath" class="headerlink" title="realpath"></a>realpath</h3><ul><li>返回文件的绝对路径</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">realpath</span> files)</span></span><br><span class="line">       <span class="comment"># --- files 需要返回绝对路径的文件，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">f3 = <span class="variable">$(<span class="built_in">wildcard</span> src/*)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">realpath</span> <span class="variable">$(f3)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h3><ul><li>返回绝对路径，用法同realpath，如果一个文件名不存在，realpath不会返回内容，abspath则会返回一个当前文件夹一下的绝对路径</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">abspath</span> files)</span></span><br></pre></td></tr></table></figure><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul><li>条件判断，如果条件展开不是空串，则反回真的部分，否则返回假的部分</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> condition,then-part[,else-part])</span></span><br><span class="line">        <span class="comment">#--- condition 条件部分</span></span><br><span class="line">        <span class="comment">#--- then-part 条件为真时执行的部分</span></span><br><span class="line">        <span class="comment">#--- else-part 条件为假时执行的部分，如果省略则为假时返回空串</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(files)</span>,有文件,没有文件)</span></span><br></pre></td></tr></table></figure><h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><ul><li>返回条件中第一个不为空的部分</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">or</span> condition1[,condition2[,condition3…]])</span></span><br><span class="line"></span><br><span class="line">f1 = </span><br><span class="line">f2 = </span><br><span class="line">f3 = hello.cpp</span><br><span class="line">f4 = main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">or</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>,<span class="variable">$(f3)</span>,<span class="variable">$(f4)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><ul><li>如果条件中有一个为空串，则返回空，如果全都不为空，则返回最后一个条件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">and</span> condition1[,condition2[,condition3…]])</span></span><br><span class="line"></span><br><span class="line">f1 = 12</span><br><span class="line">f2 = 34</span><br><span class="line">f3 = hello.cpp</span><br><span class="line">f4 = main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">and</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>,<span class="variable">$(f3)</span>,<span class="variable">$(f4)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="intcomp"><a href="#intcomp" class="headerlink" title="intcomp"></a>intcomp</h3><ul><li>比较两个整数大小，并返回对应操作结果（GNU make 4.4以上版本）</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(intcmp lhs,rhs[,lt-part[,eq-part[,gt-part]]])</span> </span><br><span class="line">        <span class="comment">#--- lhs 第一个数</span></span><br><span class="line">        <span class="comment">#--- rhs 第二个数</span></span><br><span class="line">        <span class="comment">#--- lt-part  lhs &lt; rhs时执行</span></span><br><span class="line">        <span class="comment">#--- eq-part  lhs = rhs时执行</span></span><br><span class="line">        <span class="comment">#--- gt-part  lhs &gt; rhs时执行</span></span><br><span class="line">        <span class="comment">#--- 如果只提供前两个参数，则lhs == rhs时返回数值，否则返回空串 </span></span><br><span class="line">        <span class="comment">#    参数为lhs,rhs,lt-part时，当lhs &lt; rhs时返回lt-part结果，否则返回空</span></span><br><span class="line">        <span class="comment">#    参数为lhs,rhs,lt-part,eq-part，lhs &lt; rhs返回lt-part结果，否则都返回eq-part结果</span></span><br><span class="line">        <span class="comment">#    参数全时，lhs &lt; rhs返回lt-part，lhs == rhs返回eq-part, lhs &gt; rhs返回gt-part</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@echo <span class="variable">$(intcmp 2,2,-1,0,1)</span></span><br></pre></td></tr></table></figure><h2 id="makefile常用函数"><a href="#makefile常用函数" class="headerlink" title="makefile常用函数"></a>makefile常用函数</h2><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><ul><li>读写文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">file</span> op filename[,text])</span></span><br><span class="line">        <span class="comment">#--- op 操作</span></span><br><span class="line">        <span class="comment">#        &gt; 覆盖</span></span><br><span class="line">        <span class="comment">#        &gt;&gt; 追加</span></span><br><span class="line">        <span class="comment">#        &lt; 读</span></span><br><span class="line">        <span class="comment">#--- filename 需要操作的文件名</span></span><br><span class="line">        <span class="comment">#--- text 写入的文本内容，读取是不需要这个参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">write = <span class="variable">$(<span class="built_in">file</span> &gt; makewrite.txt,<span class="variable">$(files)</span>)</span></span><br><span class="line">read = <span class="variable">$(<span class="built_in">file</span> &lt; makewrite.txt)</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul><li>对一列用空格隔开的字符序列中每一项进行处理，并返回处理后的列表</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> each,list,process)</span></span><br><span class="line">        <span class="comment">#--- each list中的每一项</span></span><br><span class="line">        <span class="comment">#--- list 需要处理的字符串序列，用空格隔开</span></span><br><span class="line">        <span class="comment">#--- process 需要对每一项进行的处理</span></span><br><span class="line"></span><br><span class="line">list = 1 2 3 4 5</span><br><span class="line">result = <span class="variable">$(<span class="built_in">foreach</span> each,<span class="variable">$(list)</span>,$(<span class="built_in">addprefix</span> cpp,$(<span class="built_in">addsuffix</span> .cpp,<span class="variable">$(each)</span>)</span>))</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ul><li>将一些复杂的表达式写成一个变量，用call可以像调用函数一样进行调用。类似于编程语言中的自定义函数。在函数中可以用$(n)来访问第n个参数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> funcname,param1,param2,…)</span></span><br><span class="line">       <span class="comment"># --- funcname 自定义函数（变量名）</span></span><br><span class="line">       <span class="comment"># --- 参数至少一个，可以有多个，用逗号隔开</span></span><br><span class="line"></span><br><span class="line">dirof =  <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">realpath</span> $(1)</span>)) <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">realpath</span> $(2)</span>))</span><br><span class="line">result = <span class="variable">$(<span class="built_in">call</span> dirof,main.cpp,src/hello.cpp)</span></span><br></pre></td></tr></table></figure><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><ul><li>对于不是立即展开的变量，可以查看变量的原始定义；对于立即展开的变量，直接返回变量值</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">value</span> variable)</span></span><br><span class="line"></span><br><span class="line">var = value function test</span><br><span class="line">var2 = <span class="variable">$(var)</span></span><br><span class="line">var3 := <span class="variable">$(var)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">value</span> var2)</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">value</span> var3)</span></span><br></pre></td></tr></table></figure><h3 id="origin"><a href="#origin" class="headerlink" title="origin"></a>origin</h3><ul><li>查看一个变量定义的来源</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> variable)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var2 = origin function </span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> var1)</span>    <span class="comment"># undefined 未定义</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> CC)</span>        <span class="comment"># default 默认变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> JAVA_HOME)</span> <span class="comment"># environment 环境变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> var2)</span>    <span class="comment"># file 在Makefile文件中定义的变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> @)</span>        <span class="comment"># automatic 自动变量</span></span><br></pre></td></tr></table></figure><h3 id="flavor"><a href="#flavor" class="headerlink" title="flavor"></a>flavor</h3><ul><li>查看一个变量的赋值方式</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">flavor</span> variable)</span></span><br><span class="line"></span><br><span class="line">var2 = flavor function</span><br><span class="line">var3 := flavor funciton</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var1)</span>    <span class="comment"># undefined 未定义</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var2)</span>    <span class="comment"># recursive 递归展开赋值</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var3)</span>    <span class="comment"># simple 简单赋值</span></span><br></pre></td></tr></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><ul><li>可以将一段文本生成Makefile的内容</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">eval</span> text)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> eval_target = </span><br><span class="line"><span class="section">eval:</span></span><br><span class="line">    @echo Target Eval Test</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">eval</span> <span class="variable">$(eval_target)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul><li>用来执行shell的命令的</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">files = <span class="variable">$(<span class="built_in">shell</span> ls *.cpp)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> echo This is from <span class="built_in">shell</span> function)</span></span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>将一个字符串序列中的项拆开放入多个变量中，并对各个变量进行操作（GNU make 4.4以上版本）</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(let var1 [var2 ...],[list],proc)</span></span><br><span class="line">       <span class="comment"># --- var 变量，可以有多个，用空格隔开</span></span><br><span class="line">       <span class="comment"># --- list 待处理字符串，各项之间空格隔开</span></span><br><span class="line">       <span class="comment"># --- proc 对变量进行的操作，结果为let的返回值</span></span><br><span class="line">            将list中的值依次一项一项放到var中，如果var的个数多于list项数，那多出来的var是空串。如果</span><br><span class="line">            var的个数小于list项数，则先依次把前而的项放入var中，剩下的list所有项都放入最后一个var中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list = a b c d</span><br><span class="line">letfirst = <span class="variable">$(let first second rest,<span class="variable">$(list)</span>,<span class="variable">$(first)</span>)</span></span><br><span class="line">letrest = <span class="variable">$(let first second rest,<span class="variable">$(list)</span>,<span class="variable">$(rest)</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合call可以对所有项进行递归处理</span></span><br><span class="line">reverse = <span class="variable">$(let first rest,$(1)</span>,<span class="variable">$(<span class="built_in">if</span> <span class="variable">$(rest)</span>,$(<span class="built_in">call</span> reverse,<span class="variable">$(rest)</span>)</span> )<span class="variable">$(first)</span>)</span><br><span class="line"><span class="section">all: ; @echo $(call reverse,d c b a)</span></span><br></pre></td></tr></table></figure><h2 id="信息提示函数"><a href="#信息提示函数" class="headerlink" title="信息提示函数"></a>信息提示函数</h2><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><ul><li>用来提示错误信息并终止make执行</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> text)</span></span><br><span class="line">        <span class="comment">#--- text 提示信息</span></span><br><span class="line"></span><br><span class="line">EXIT_STATUS = -1</span><br><span class="line"><span class="keyword">ifneq</span> (0, <span class="variable">$(EXIT_STATUS)</span>)</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> An <span class="built_in">error</span> occured! make stopped!)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h3><ul><li>提示警告信息，make不会终止</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> text)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (0, <span class="variable">$(EXIT_STATUS)</span>)</span><br><span class="line">    <span class="variable">$(<span class="built_in">warning</span> This is a <span class="built_in">warning</span> message)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><ul><li>输出一些信息</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(info text…)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(info 编译开始.......)</span></span><br><span class="line"><span class="variable">$(info 编译结束)</span></span><br></pre></td></tr></table></figure><h2 id="多个makefile文件"><a href="#多个makefile文件" class="headerlink" title="多个makefile文件"></a>多个makefile文件</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul><li>可以读入其他makefile文件的内容，效果就如同在include的位置用对应的文件内容替换一样。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> mkf1 mkf2 <span class="comment"># 可以引入多个文件，用空格隔开</span></span><br><span class="line"><span class="keyword">include</span> *.mk    <span class="comment"># 可以用通配符，表示引入所有以.mk结尾的文件</span></span><br></pre></td></tr></table></figure><ul><li>如果找不到对应文件，则会报错，如果要忽略错误，可以在<code>include</code>前加<code>-</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> mkf1 mkf2</span><br></pre></td></tr></table></figure><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><ul><li>可以通过export指令向子项目传递变量</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> var  <span class="comment"># 传递var</span></span><br><span class="line"><span class="keyword">export</span>         <span class="comment"># 传递所有变量</span></span><br><span class="line"><span class="keyword">unexport</span>    <span class="comment"># 取消传递</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="-C"></a>-C</h3><ul><li>去到另一个文件夹里面执行make命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(MAKE)</span> -C dir_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2024/10/19/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/10/19/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h1 id="检测服务器端口"><a href="#检测服务器端口" class="headerlink" title="检测服务器端口"></a>检测服务器端口</h1><h3 id="本地服务端查看的"><a href="#本地服务端查看的" class="headerlink" title="本地服务端查看的"></a>本地服务端查看的</h3><ul><li><p>netstat -tunlp</p></li><li><p>ss -tunlp</p></li><li><p>lsof</p></li></ul><h3 id="远程登陆查看的"><a href="#远程登陆查看的" class="headerlink" title="远程登陆查看的"></a>远程登陆查看的</h3><ul><li>telnet</li><li>nmap</li><li>nc</li></ul><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><ul><li>管道命令</li><li>以行为单位</li><li>参数<ul><li>-n：仅仅显示脚本处理之后的结果</li><li>-e：使用指定脚本文件处理输入的文本文件</li><li>-f：直接将sed的动作写到一个文件内，-f filename</li><li>-r：支持拓展正则表达式</li><li>-i：直接修改读取的文件内容，不输出到终端</li><li>-v：显示版本信息</li></ul></li><li>删除第1-2行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed &#x27;1,2d&#x27;</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     4          do \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">     6          done</span><br></pre></td></tr></table></figure><ul><li>删除第2行到文件末尾</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl makefile | sed &#x27;2,$d&#x27;</span><br></pre></td></tr></table></figure><ul><li>在第二行后面加上字符，如果是<kbd>2i</kbd>的话就是在第二行的上面，不是下面了，如果是后面加上多行的话，就是另外一个引号先不给，然后给\，后面再给另外一边的引号就结束了</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed &#x27;2a linzhiwen&#x27; </span><br><span class="line">     1  all:</span><br><span class="line">     2          @read -p &quot;Input element :&quot; var; \</span><br><span class="line">linzhiwen</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     4          do \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">     6          done</span><br></pre></td></tr></table></figure><ul><li>将2到5行替换成linzhiwen, 就是change</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed &#x27;2,5c linzhiwen&#x27; </span><br><span class="line">     1  all:</span><br><span class="line">linzhiwen</span><br><span class="line">     6          done</span><br></pre></td></tr></table></figure><ul><li>只显示处理的结果-n，打印信息p，print，不加-n的区别就是重复显示，-n就是只显示处理的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed -n &#x27;2,5p&#x27;</span><br><span class="line">     2          @read -p &quot;Input element :&quot; var; \</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     4          do \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">-bash-4.2$ nl makefile | sed  &#x27;2,5p&#x27;</span><br><span class="line">     1  all:</span><br><span class="line">     2          @read -p &quot;Input element :&quot; var; \</span><br><span class="line">     2          @read -p &quot;Input element :&quot; var; \</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     4          do \</span><br><span class="line">     4          do \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">     6          done</span><br></pre></td></tr></table></figure><ul><li>搜索匹配的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed  -n &#x27;/for/p&#x27;</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><blockquote><p>文本分析工具， awk ‘{pattern+action}’ &lt;filename&gt;</p></blockquote><ul><li>-F 来指定分隔符的，没有指定的情况下默认的是空格，或者是tab</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ cat /etc/passwd | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">sync</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">ftp</span><br><span class="line">nobody</span><br><span class="line">ods</span><br></pre></td></tr></table></figure><ul><li>$0是所有的域，$1是第一个</li><li>想要多个输出的话，中间中逗号分开，空格是没有用的，要给的话中间要给双引号，” “这样的是可以的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ cat /etc/passwd | awk -F : &#x27;&#123;print $1,$7&#125;&#x27;</span><br><span class="line">root /bin/bash</span><br><span class="line">bin /sbin/nologin</span><br><span class="line">daemon /sbin/nologin</span><br><span class="line">adm /sbin/nologin</span><br><span class="line">lp /sbin/nologin</span><br><span class="line">sync /bin/sync</span><br></pre></td></tr></table></figure><ul><li>加上开头和结尾，都要加上双引号的，这个结尾我没有加是错的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ cat /etc/passwd | awk -F : &#x27;BEGIN &#123;print &quot;nameshell&quot;&#125; &#123;print $1,$7&#125; END&#123;print hhhh&#125;&#x27;</span><br><span class="line">nameshell</span><br><span class="line">root /bin/bash</span><br><span class="line">bin /sbin/nologin</span><br><span class="line">daemon /sbin/nologin</span><br><span class="line">adm /sbin/nologin</span><br><span class="line">lp /sbin/nologin</span><br></pre></td></tr></table></figure><ul><li>匹配字符串，在输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ cat /etc/passwd | awk -F : &#x27; BEGIN &#123;print &quot;nameshell&quot;&#125; /^root/ &#123;print $1,$7&#125; END&#123;print &quot;hhhh&quot;&#125;&#x27;</span><br><span class="line">nameshell</span><br><span class="line">root /bin/bash</span><br><span class="line">hhhh</span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><ul><li><p>精确匹配 -w（就是匹配word）</p></li><li><p>–color&#x3D;auto，给匹配到的加上颜色</p></li><li><p>取反 -v，就是不匹配</p></li><li><p>grep -c统计行数</p></li><li><p>-l显示匹配的文件，就是在多个文件里面搜索</p></li><li><p>-i 是不区分大小的，没有这个参数默认是区分大小写的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell基础</title>
      <link href="/2024/10/19/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/19/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><h3 id="取出变量值"><a href="#取出变量值" class="headerlink" title="取出变量值"></a>取出变量值</h3><ul><li><p>单引号：所见即所得</p></li><li><p>双引号：输出引号里面的所有内容，识别特殊字符，弱引用</p></li><li><p>无引号：连续的符号可以不加引号，有空格有歧义，最好使用双引号</p></li><li><p>反引号：<kbd><code>ls</code></kbd>引用命令执行的结果，就等于$()用法</p></li><li><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3></li><li><p><a>$</a> : 获取shell脚本的文件名，以及脚本路径</p></li><li><p><a>$n</a> : 获取shell脚本的第n个参数，n在1-9之间，就可以写$1这样的，如果大于了10，就需要用$(10)，参数之间用空格隔开</p></li><li><p><a>$#</a> : 获取执行shell脚本后面的参数总个数</p></li><li><p><a>$*</a> : 获取shell脚本所有参数，不加引号等同于$@的作用，加上了引号就是把接受的参数作为单个字符串了 “$1  $2”</p></li><li><p><a>$@</a> : 不加引号，效果同上，加上了引号， 效果是分开每个参数，”$1”, “$2”， 空格保留</p></li></ul><h3 id="特殊状态变量"><a href="#特殊状态变量" class="headerlink" title="特殊状态变量"></a>特殊状态变量</h3><ul><li>$? ： 上一次命令执行是不是正常执行的，0正确，非0就是失败了</li><li>$$ ： 当前shell脚本的进程号</li><li>$! ： 上一次后台进程的PID</li><li>$_ ： 上次命令的最后一个参数</li></ul><h3 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h3><ul><li><h4 id="echo-：-输出内容到指定的"><a href="#echo-：-输出内容到指定的" class="headerlink" title="echo ： 输出内容到指定的"></a><a>echo</a> ： 输出内容到指定的</h4><ul><li>-n : 不换行输出内容</li><li>-e ： 解释转移字符</li><li>\n : 换行</li><li>\r ：回车</li><li>\t : tab</li><li>\b : 退格</li><li>\v ： 纵向制表符</li></ul></li><li><h4 id="eval-：-执行多个命令"><a href="#eval-：-执行多个命令" class="headerlink" title="eval ： 执行多个命令"></a><a>eval</a> ： 执行多个命令</h4></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval ls; cd xxx</span><br></pre></td></tr></table></figure><ul><li><h4 id="exec：-不创建子shell，执行该命令，完成命令之后自己就exit了"><a href="#exec：-不创建子shell，执行该命令，完成命令之后自己就exit了" class="headerlink" title="exec： 不创建子shell，执行该命令，完成命令之后自己就exit了"></a><a>exec</a>： 不创建子shell，执行该命令，完成命令之后自己就exit了</h4></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec date</span><br></pre></td></tr></table></figure><ul><li><h4 id="export"><a href="#export" class="headerlink" title="export"></a><a>export</a></h4></li><li><h4 id="read"><a href="#read" class="headerlink" title="read"></a><a>read</a></h4></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;Input :&quot; var</span><br></pre></td></tr></table></figure><ul><li><h4 id="shift"><a href="#shift" class="headerlink" title="shift"></a><a>shift</a></h4></li></ul><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a><a>if</a></h3><blockquote><p>语法: 如果一行里面写了多个语句，就要写分号；了，如果是一行就写了一句话了，就不用写分号了</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if command</span><br><span class="line">then </span><br><span class="line">  command</span><br><span class="line">if</span><br></pre></td></tr></table></figure><ul><li>bash的if语句会直接运行if后面的命令，如果该命令执行正确（状态码位0），处于then的命令就会被执行，否则就不会被执行，或者执行其他的逻辑语句，最后到fi结束逻辑控制</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ pwd ]</span><br><span class="line">then </span><br><span class="line">echo &quot;hhh&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if-then-else"></a><a>if-then-else</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -ge 2 ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;you need input a number more than 1&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;sorry&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="嵌套if"><a href="#嵌套if" class="headerlink" title="嵌套if"></a><a>嵌套if</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $1 -ge 2 ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;you need input a number more than 1&quot;</span><br><span class="line">else</span><br><span class="line">  if [ $1 -le 2 ]</span><br><span class="line">     echo &quot;sorry&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="elif语句"><a href="#elif语句" class="headerlink" title="elif语句"></a><a>elif语句</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $1 -le 20 ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;you need input a number more than 1&quot;</span><br><span class="line">elif [ $1 -ge  30 ]</span><br><span class="line">  then</span><br><span class="line">        echo &quot;hhhh&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a><a>test</a></h3><ul><li><p>test命令最短的定义可能是评估一个表达式；如果条件为真，则返回一个0。如果表达式不为真，则返回一个大于0的数值，也可以将其称为假值。检查最后所执行命令的状态的最简便的方法就是<kbd>$？</kbd></p></li><li><p>检测文件类型的option： test [option] filename，</p><ul><li><p>-e ： 该filename是不是存在</p></li><li><p>-f ： 该filename是不是文件</p></li><li><p>-d ： 该filename是不是目录</p></li><li><p>-b ： 该filename是不是要给block device</p></li><li><p>-c ： 该filename是不是一个character device</p></li><li><p>-s ： 该filename是不是一个socket</p></li><li><p>-p ： 该filename是不是一个FIFO（pipe）文件</p></li><li><p>-L ： 该filename是不是要给连结档</p></li></ul></li><li><p>文件权限的option ： test [option] filename</p><ul><li>-r 检测文件是不是有可读属性</li><li>-w 检测文件是不是有可写属性</li><li>-x 检测文件是不是有可执行属性</li><li>-u 检测文件是不是有SUID属性</li><li>-g 检测文件是不是有SGID属性</li><li>-k 检测文件是不是有Sticky bit属性</li><li>-s 检测文件是不是非空白文件</li></ul></li><li><p>两个文件之变的比较 ： test filename1 [option] filename2</p><ul><li>-nt （newer than）判断filename1是不是比filename2新</li><li>-ot （older than）判断filename1是不是比filename2旧</li><li>-ef 判断filename1与filename2是不是一个文件，可以用在判断hard link上面，是不是指向了同一个文件</li></ul></li><li><p>判断两个整数 ： test num1 [option] num2</p><ul><li>-eq : equal 判断两个数值相等的吗</li><li>-ne ： not equal 判断两个数值不相等的吗</li><li>-gt ： greater than 判断n1 大于 n2吗</li><li>-lt : less than 判断n1 小于 n2 吗</li><li>-ge ： greater than or equal 判断n1 大于等于 n2吗</li><li>-le ： less than or equal 判断n1 小于等于 n2吗</li></ul></li><li><p>判断字符串</p><ul><li><p>-z : 判断是不是空的，是用的就是true，不是空个，就是false</p></li><li><p>-n ： 判断是不是不是空的，不是空个就是true，是空的就是false</p></li><li><p>&#x3D; ： string1 是不是等于string2</p></li><li><p>!&#x3D; ： string1 是不是不等于string2</p></li></ul></li><li><p>&amp;&amp; 与 || （和c语言中的是一样的）</p></li><li><p>数学表达式： bash支持<strong>双小括号</strong>写入高级的数学表达式</p></li></ul><p><img src="https://s2.loli.net/2024/10/19/yfeJ1AmC9bQkFvL.png" alt="image-20240317154916014"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=199</span><br><span class="line">if (( &quot;$var&quot; &gt; $1 ));then</span><br><span class="line">  echo &quot;$var is greater than $1&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="双中括号"><a href="#双中括号" class="headerlink" title="双中括号[[]]"></a>双中括号[[]]</h3><ul><li>双中括号提供了针对字符串的高级特性，模式匹配，正则表达式的匹配</li><li>&#x3D;&#x3D; ： 就是c语言里面的，是不是相等意思</li></ul><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><ul><li>就是和c语言里面是一样的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case &quot;$1&quot; in</span><br><span class="line">1)</span><br><span class="line">  echo &quot;\$1 is 1&quot;</span><br><span class="line">;;</span><br><span class="line">2)</span><br><span class="line">  echo &quot;\$2 is 2&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a>for命令</h3><ul><li>和c语言的一样,但是里面可能需要转义符号和双引号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..100&#125;;do</span><br><span class="line"> echo &quot;$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>for遍历文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">for word in $(cat lin.sh)</span><br><span class="line">do</span><br><span class="line">echo &quot;$word&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>c语言风格的for循环</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( a=1,b=2;a&lt;=10;a++,b++ ))</span><br><span class="line">do </span><br><span class="line">        echo &quot;$a &amp;&amp; $b&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while [ $1 -gt $2 ];do</span><br><span class="line"> echo &quot;$1 is greater than $2&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>执行多个命令的时候，每条命令都是单独一行的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">while echo &quot;$1&quot; </span><br><span class="line"> [ $1 -gt $2 ] </span><br><span class="line">do</span><br><span class="line"> echo &quot;$1 is greater than $2&quot;</span><br><span class="line">sleep 23</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h3><ul><li>和while的用法是一样的，就是意思是相反的</li></ul><h3 id="IFS分隔符"><a href="#IFS分隔符" class="headerlink" title="IFS分隔符"></a>IFS分隔符</h3><ul><li>用来指定分隔符的，没有指定的话，好像是空格，可以指定的分割符有：空格，制表符，换行符，逗号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">oldifs=$IFS</span><br><span class="line">IFS=,</span><br><span class="line">names=&quot;lin,zhi,wen&quot;</span><br><span class="line">for i in $names;</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line">IFS=$oldifs</span><br></pre></td></tr></table></figure><h3 id="打断循环"><a href="#打断循环" class="headerlink" title="打断循环"></a>打断循环</h3><ul><li>break<ul><li>break 2，就是跳出两层循环，其他的和c语言是一样的</li></ul></li><li>continue： 和c是一样的</li></ul><h3 id="循环输出的重新定向"><a href="#循环输出的重新定向" class="headerlink" title="循环输出的重新定向"></a>循环输出的重新定向</h3><ul><li>在shell脚本里面，循环输出后的结果，可以进行重定向</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">oldifs=$IFS</span><br><span class="line">IFS=,</span><br><span class="line">names=&quot;lin,zhi,wen&quot;</span><br><span class="line">for i in $names;</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done &gt; tudou.txt</span><br><span class="line">IFS=$oldifs</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h3><ul><li>当你需要一段重复的代码的时候，就可以把这段代码定义成函数了，可以重复的调用，下面是两种常用的定义函数的方式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标准的函数的定义，func_name后面可以不给括号，建议标准的写法吧</span></span><br><span class="line">function func_name() &#123;</span><br><span class="line">command</span><br><span class="line">return 状态码</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">简化的函数的定义</span></span><br><span class="line">func_name() &#123;</span><br><span class="line">command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lin_func_use() &#123;</span><br><span class="line">        echo &quot;$1&quot;</span><br><span class="line">&#125;</span><br><span class="line">if [ $# -gt 1 ];then</span><br><span class="line">  lin_func_use &quot;$1&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li>函数名需要唯一，负责会覆盖函数的定义的，就是和c语言一样的</li><li>在函数里面使用<kbd>return</kbd>命令来定制特殊的退出状态码，也可以保存到变量里面</li><li>函数里面的变量是属于局部变量的，写在脚本里面的变量是全局变量（除了函数体内部的）</li><li>可以在函数体里面生命上<kbd>local</kbd>，声明为局部的，虽然我认为没有什么用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">name=&quot;linzhiwen&quot;</span><br><span class="line">lin_func_use() &#123;</span><br><span class="line">        local name=&quot;lin&quot;</span><br><span class="line">        echo &quot;$name&quot;</span><br><span class="line">        return 2;</span><br><span class="line">&#125;</span><br><span class="line">if [ $# -gt 1 ];then</span><br><span class="line">  lin_func_use &quot;$1&quot;</span><br><span class="line">fi</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog基础</title>
      <link href="/2024/10/19/Programming/SystemvVerikog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/19/Programming/SystemvVerikog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> IC </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> SV </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
