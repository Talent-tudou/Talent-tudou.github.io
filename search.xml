<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AHB-DMAC</title>
      <link href="/2024/11/29/DWC/AHB-DMAC/"/>
      <url>/2024/11/29/DWC/AHB-DMAC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>手册1.3，3.4，3.5，3.6，3.7.1。DMA（直接存储器访问）控制器<span id="more"></span></p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><a>基本概念</a></h2><h3 id="1-Source-peripheral（源外设）"><a href="#1-Source-peripheral（源外设）" class="headerlink" title="1. Source peripheral（源外设）"></a><strong>1. Source peripheral（源外设）</strong></h3><ul><li><strong>定义</strong>：源外设是DMA控制器（DW_ahb_dmac）读取数据的设备，通常位于AHB总线层级。DMA控制器将从源外设读取的数据存储在通道FIFO（先进先出队列）中。</li><li><strong>角色</strong>：源外设与目标外设一起组成DMA通道。源外设可以是AHB或APB从设备。如果是APB从设备，则通过AHB-APB桥接器访问。</li></ul><h3 id="2-Destination-peripheral（目标外设）"><a href="#2-Destination-peripheral（目标外设）" class="headerlink" title="2. Destination peripheral（目标外设）"></a><strong>2. Destination peripheral（目标外设）</strong></h3><ul><li><strong>定义</strong>：目标外设是DMA控制器将FIFO中存储的数据写入的设备。</li><li><strong>角色</strong>：目标外设也可以是AHB或APB从设备。如果是APB从设备，则同样需要通过AHB-APB桥接器访问。</li></ul><h3 id="3-Memory（内存）"><a href="#3-Memory（内存）" class="headerlink" title="3. Memory（内存）"></a><strong>3. Memory（内存）</strong></h3><ul><li><strong>定义</strong>：内存是源或目标外设的一种形式，通常表示不需要握手接口即可与DMA控制器交互的数据源或目标。内存外设不需要等待信号，而是“随时准备”进行DMA传输。</li><li><strong>条件</strong>：如果外设插入的等待状态超过16个，则不能作为内存外设，而需要通过握手接口来与DMA控制器交互。如果外设的等待状态较少，则可以将其配置为内存外设。</li></ul><h3 id="4-Channel（通道）"><a href="#4-Channel（通道）" class="headerlink" title="4. Channel（通道）"></a><strong>4. Channel（通道）</strong></h3><ul><li><strong>定义</strong>：通道是源外设和目标外设之间的数据传输路径。数据通过通道的FIFO从源外设传输到目标外设。</li><li><strong>特征</strong>：如果源外设不是内存，则通道会有一个源握手接口；如果目标外设不是内存，则会有目标握手接口。可以动态配置这些握手接口。</li></ul><h3 id="5-Master-interface（主接口）"><a href="#5-Master-interface（主接口）" class="headerlink" title="5. Master interface（主接口）"></a><strong>5. Master interface（主接口）</strong></h3><ul><li><strong>定义</strong>：DMA控制器在AHB总线上充当主设备，读取源外设的数据并将其写入目标外设。DMA控制器最多可以有四个主接口，这意味着最多可以同时运行四个独立的源和目标通道。</li><li><strong>作用</strong>：每个通道需要竞争主接口。如果源和目标外设位于不同的AHB层上，则需要多个主接口。</li></ul><h3 id="6-Slave-interface（从接口）"><a href="#6-Slave-interface（从接口）" class="headerlink" title="6. Slave interface（从接口）"></a><strong>6. Slave interface（从接口）</strong></h3><ul><li><strong>定义</strong>：这是DMA控制器用来配置的AHB接口。这个从接口可以与主接口在同一层级，也可以位于不同的层级。</li></ul><h3 id="7-Handshaking-interface（握手接口）"><a href="#7-Handshaking-interface（握手接口）" class="headerlink" title="7. Handshaking interface（握手接口）"></a><strong>7. Handshaking interface（握手接口）</strong></h3><ul><li>定义：握手接口是用来控制DMA传输的信号或软件寄存器集合，它遵循特定的协议，用于请求、确认和控制DMA事务。握手接口有三种类型：<ul><li><strong>Hardware handshaking interface（硬件握手接口）</strong>：通过硬件信号控制DMA传输。适用于要求实时传输控制的情况。</li><li><strong>Software handshaking interface（软件握手接口）</strong>：通过软件寄存器控制DMA传输。适用于无需修改外设硬件的情况下，可以方便地与现有外设进行DMA交互。</li><li><strong>Peripheral interrupt handshaking interface（外设中断握手接口）</strong>：使用外设中断信号作为握手接口，控制DMA传输。</li></ul></li></ul><h3 id="8-Flow-controller（流控制器）"><a href="#8-Flow-controller（流控制器）" class="headerlink" title="8. Flow controller（流控制器）"></a><strong>8. Flow controller（流控制器）</strong></h3><ul><li><strong>定义</strong>：流控制器是决定DMA块传输长度并终止传输的设备。流控制器可以是DMA控制器本身，也可以是源或目标外设。</li><li>情况：<ul><li>如果传输块的长度已知，可以由DMA控制器充当流控制器。</li><li>如果传输块的长度不确定，外设充当流控制器，控制数据块的结束。</li></ul></li></ul><h3 id="9-Flow-control-mode-CFGx-FCMODE-（流控制模式）"><a href="#9-Flow-control-mode-CFGx-FCMODE-（流控制模式）" class="headerlink" title="9. Flow control mode (CFGx.FCMODE)（流控制模式）"></a><strong>9. Flow control mode (CFGx.FCMODE)（流控制模式）</strong></h3><ul><li><strong>定义</strong>：只有在目标外设作为流控制器时，这种模式才适用。它控制从源外设的数据预取（pre-fetch）方式。</li></ul><h3 id="10-Transfer-hierarchy（传输层次结构）"><a href="#10-Transfer-hierarchy（传输层次结构）" class="headerlink" title="10. Transfer hierarchy（传输层次结构）"></a><strong>10. Transfer hierarchy（传输层次结构）</strong></h3><ul><li><strong>定义</strong>：下图说明了DW_ahb_dmac传输、块传输、事务（单次或突发）和AHB总线传输之间的层次关系。它显示了DMA控制器如何管理不同类型的传输，并进行调度。</li></ul><p><img src="https://s2.loli.net/2024/11/29/uJIHyz93twngLrQ.png" alt="image-20241129215457419"></p><hr><h2 id="和内存的通信"><a href="#和内存的通信" class="headerlink" title="和内存的通信"></a><a>和内存的通信</a></h2><h3 id="Block（块）"><a href="#Block（块）" class="headerlink" title="Block（块）"></a><strong>Block（块）</strong></h3><ul><li><strong>定义</strong>：块是DMA控制器传输的数据单元，块的大小由流控制器决定。在与内存的传输中，一个块会直接分解成多个突发传输（burst）和单次传输（single transfer）。而在与非内存外设的传输中，块会被分解成多个DMA事务（单次或突发），这些事务进一步分解为AHB总线传输。</li></ul><h3 id="Transaction（事务）"><a href="#Transaction（事务）" class="headerlink" title="Transaction（事务）"></a><strong>Transaction（事务）</strong></h3><ul><li>定义：事务是DMA传输的基本单位，事务的类型和长度由硬件或软件握手接口决定。在与非内存外设的传输中，每个事务对应一个或多个AHB传输。事务分为两种类型：<ul><li><strong>Single transaction（单次事务）</strong>：长度为1的事务，直接转换为一个单独的AHB传输。</li><li><strong>Burst transaction（突发事务）</strong>：长度可编程，通常与FIFO大小和源&#x2F;目标外设的容量有关。突发事务会被转换为多个突发传输和AHB单次传输的序列。</li></ul></li></ul><h3 id="DMA-transfer（DMA传输）"><a href="#DMA-transfer（DMA传输）" class="headerlink" title="DMA transfer（DMA传输）"></a><strong>DMA transfer（DMA传输）</strong></h3><ul><li>定义：DMA传输由软件控制块的数量，传输完成后，DMA控制器会禁用通道，并可能产生中断来通知传输完成，之后可以重新编程通道进行新的传输。<ul><li><strong>Single-block DMA transfer（单块DMA传输）</strong>：仅包含一个块。</li><li><strong>Multi-block DMA transfer（多块DMA传输）</strong>：可以由多个DMA块组成，支持块链（linked list）、自动重载寄存器和连续块等方式。</li></ul></li></ul><h3 id="Linked-lists-block-chaining-（链表和块链）"><a href="#Linked-lists-block-chaining-（链表和块链）" class="headerlink" title="Linked lists (block chaining)（链表和块链）"></a><strong>Linked lists (block chaining)（链表和块链）</strong></h3><ul><li><strong>定义</strong>：链表指针（LLP）指向下一个链表项的位置。每个链表项（LLI）包含描述下一个块的寄存器。DMA控制器每次传输开始时都会获取链表项。链表访问总是32位，不能更改为其他数据宽度，即使支持更宽的数据总线接口。</li></ul><h3 id="Auto-reloading（自动重载）"><a href="#Auto-reloading（自动重载）" class="headerlink" title="Auto-reloading（自动重载）"></a><strong>Auto-reloading（自动重载）</strong></h3><ul><li><strong>定义</strong>：在每个块结束时，DMA控制器自动将通道寄存器重新加载为通道最初启用时的值。这样可以简化多块传输的管理。</li></ul><h3 id="Contiguous-blocks（连续块）"><a href="#Contiguous-blocks（连续块）" class="headerlink" title="Contiguous blocks（连续块）"></a><strong>Contiguous blocks（连续块）</strong></h3><ul><li><strong>定义</strong>：连续块的地址选择方式是从前一个块的结束地址继续。即块与块之间的地址是连续的。</li></ul><h3 id="Scatter（分散）"><a href="#Scatter（分散）" class="headerlink" title="Scatter（分散）"></a><strong>Scatter（分散）</strong></h3><ul><li><strong>定义</strong>：适用于目标传输。分散操作意味着在每到达一个分散边界时，目标地址会按程序设定的增量（或减量）变化，且软件可以控制每两个分散边界之间的AHB传输数量。</li></ul><h3 id="Gather（聚集）"><a href="#Gather（聚集）" class="headerlink" title="Gather（聚集）"></a><strong>Gather（聚集）</strong></h3><ul><li><strong>定义</strong>：适用于源传输。聚集操作意味着在每到达一个聚集边界时，源地址会按程序设定的增量（或减量）变化，软件也可以控制每两个聚集边界之间的AHB传输数量。</li></ul><h3 id="Channel-locking（通道锁定）"><a href="#Channel-locking（通道锁定）" class="headerlink" title="Channel locking（通道锁定）"></a><strong>Channel locking（通道锁定）</strong></h3><ul><li><strong>定义</strong>：软件可以将通道设置为锁定状态，这样在DMA传输、块或事务期间，DMA控制器会保持AHB主接口的控制权，防止其他模块争用总线。</li></ul><h3 id="Bus-locking（总线锁定）"><a href="#Bus-locking（总线锁定）" class="headerlink" title="Bus locking（总线锁定）"></a><strong>Bus locking（总线锁定）</strong></h3><ul><li><strong>定义</strong>：软件可以通过总线锁定机制来保持DMA控制器对AHB总线的控制，直到DMA传输完成。总线锁定通常伴随通道锁定一起使用。</li></ul><h3 id="FIFO-mode（FIFO模式）"><a href="#FIFO-mode（FIFO模式）" class="headerlink" title="FIFO mode（FIFO模式）"></a><strong>FIFO mode（FIFO模式）</strong></h3><ul><li><strong>定义</strong>：FIFO模式通过减少请求总线接口的次数来提高带宽。启用FIFO模式后，DMA通道只有在FIFO缓冲区未满一半时才会从源外设请求数据，只有在FIFO达到或超过一半时才会将数据传输到目标外设。</li></ul><h3 id="Pseudo-fly-by-operation（伪飞行操作）"><a href="#Pseudo-fly-by-operation（伪飞行操作）" class="headerlink" title="Pseudo fly-by operation（伪飞行操作）"></a><strong>Pseudo fly-by operation（伪飞行操作）</strong></h3><ul><li><strong>定义</strong>：在源外设和目标外设位于不同的AHB层时，DMA控制器可以同时从源外设读取数据并将数据写入目标外设。这意味着数据既能存储到FIFO，又能从FIFO写入目标外设，从而优化了数据传输的效率。</li></ul><p><img src="https://s2.loli.net/2024/11/29/x8ZXATusdh641tJ.png" alt="image-20241129215509252"></p><hr><h2 id="传输计算"><a href="#传输计算" class="headerlink" title="传输计算"></a><a>传输计算</a></h2><h3 id="1-源单次传输大小（Source-single-transaction-size-in-bytes）"><a href="#1-源单次传输大小（Source-single-transaction-size-in-bytes）" class="headerlink" title="1. 源单次传输大小（Source single transaction size in bytes）"></a>1. <strong>源单次传输大小（Source single transaction size in bytes）</strong></h3><ul><li><strong>定义</strong>：源单次传输大小指的是每次DMA从源外设读取的数据量。该值由源传输宽度（<code>CTLx.SRC_TR_WIDTH</code>）决定。<code>CTLx.SRC_TR_WIDTH</code>是一个寄存器字段，表示源传输的宽度（通常是一个数据宽度，单位为位）。为了得到源单次传输的字节数，必须将该宽度除以8，因为1字节等于8位。</li><li><strong>公式</strong>：<br>$$<br>\text{src_single_size_bytes} &#x3D; \frac{\text{CTLx.SRC_TR_WIDTH}}{8}<br>$$<br>例如，如果<code>CTLx.SRC_TR_WIDTH = 32</code>，那么源单次传输大小为4字节。</li></ul><h3 id="2-源突发传输大小（Source-burst-transaction-size-in-bytes）"><a href="#2-源突发传输大小（Source-burst-transaction-size-in-bytes）" class="headerlink" title="2. 源突发传输大小（Source burst transaction size in bytes）"></a>2. <strong>源突发传输大小（Source burst transaction size in bytes）</strong></h3><ul><li><p><strong>定义</strong>：源突发传输大小是指源外设在DMA传输时一次突发（burst）传输的数据量。突发传输可以包含多个单次传输，因此源突发传输大小是源单次传输大小和源突发大小（<code>CTLx.SRC_MSIZE</code>）的乘积。<code>CTLx.SRC_MSIZE</code>表示源突发的大小，单位是源单次传输的数量（即一次突发中包含的源单次传输的个数）。</p></li><li><p><strong>公式</strong>：<br>$$<br>\text { src_burst_size_bytes }&#x3D;\text { CTLx.SRC_MSIZE } \times \text { src_single_size_bytes }<br>$$<br>例如，如果<code>CTLx.SRC_MSIZE = 4</code>且<code>src_single_size_bytes = 4</code>字节，那么源突发传输大小就是16字节。</p></li></ul><h3 id="3-目标单次传输大小（Destination-single-transaction-size-in-bytes）"><a href="#3-目标单次传输大小（Destination-single-transaction-size-in-bytes）" class="headerlink" title="3. 目标单次传输大小（Destination single transaction size in bytes）"></a>3. <strong>目标单次传输大小（Destination single transaction size in bytes）</strong></h3><ul><li><p><strong>定义</strong>：目标单次传输大小指的是DMA写入目标外设时每次写入的数据量。它由目标传输宽度（<code>CTLx.DST_TR_WIDTH</code>）决定，<code>CTLx.DST_TR_WIDTH</code>表示目标传输的宽度，单位是位。与源单次传输大小类似，它需要通过除以8来转换为字节。</p></li><li><p><strong>公式</strong>：</p></li></ul><p>$$<br>\text { dst_single_size_bytes }&#x3D;\frac{\text { CTLx.DST_TR_WIDTH }}{8}<br>$$</p><p>​例如，如果<code>CTLx.DST_TR_WIDTH = 32</code>，那么目标单次传输大小就是4字节。</p><h3 id="4-目标突发传输大小（Destination-burst-transaction-size-in-bytes）"><a href="#4-目标突发传输大小（Destination-burst-transaction-size-in-bytes）" class="headerlink" title="4. 目标突发传输大小（Destination burst transaction size in bytes）"></a>4. <strong>目标突发传输大小（Destination burst transaction size in bytes）</strong></h3><ul><li><strong>定义</strong>：目标突发传输大小是指DMA写入目标外设时一次突发（burst）传输的数据量。与源突发传输大小类似，目标突发传输大小是目标单次传输大小和目标突发大小（<code>CTLx.DEST_MSIZE</code>）的乘积。<code>CTLx.DEST_MSIZE</code>表示目标突发的大小，单位是目标单次传输的数量。</li><li><strong>公式</strong>：</li></ul><p>$$<br>\text { dst_burst_size_bytes &#x3D; CTLx.DEST_MSIZE × dst_single_size_bytes }<br>$$</p><p>​例如，如果<code>CTLx.DEST_MSIZE = 4</code>且<code>dst_single_size_bytes = 4</code>字节，那么目标突发传输大小就是16字节。</p><h3 id="5-块大小（Block-size-in-bytes）"><a href="#5-块大小（Block-size-in-bytes）" class="headerlink" title="5. 块大小（Block size in bytes）"></a>5. <strong>块大小（Block size in bytes）</strong></h3><ul><li>块大小定义了DMA一次传输中要处理的数据量，可以根据不同的流控制器角色来计算：</li></ul><h4 id="DW-ahb-dmac作为流控制器："><a href="#DW-ahb-dmac作为流控制器：" class="headerlink" title="DW_ahb_dmac作为流控制器："></a><strong>DW_ahb_dmac作为流控制器</strong>：</h4><ul><li><strong>定义</strong>：当DMA控制器本身作为流控制器时，处理器通过编程DMA控制器的<code>CTLx.BLOCK_TS</code>字段来指定每个块中要传输的数据项数（即块大小）。<code>CTLx.SRC_TR_WIDTH</code>是源传输宽度，表示每个数据项的大小。</li><li><strong>公式</strong>：</li></ul><p>$$<br>\text { blk_size_bytes_dma &#x3D; CTLx.BLOCK_TS × src_single_size_bytes }<br>$$</p><p>​例如，如果<code>CTLx.BLOCK_TS = 100</code>且<code>src_single_size_bytes = 4</code>字节，那么块大小为400字节。</p><h4 id="源外设作为块流控制器："><a href="#源外设作为块流控制器：" class="headerlink" title="源外设作为块流控制器："></a><strong>源外设作为块流控制器</strong>：</h4><ul><li><strong>定义</strong>：当源外设作为块流控制器时，块大小是源突发传输和源单次传输的数量加权平均。它由源外设进行控制。</li><li><strong>公式</strong>：</li></ul><p>$$<br>\text { blk_size_bytes_src }&#x3D;\text { (Number of source burst transactions in block × src_burst_size_bytes) + (Number of source single transactions in block } \times \text { src_single_size_bytes) }<br>$$</p><p> 这表示块大小是由源突发事务和源单次事务的数量来决定的。</p><h4 id="目标外设作为块流控制器："><a href="#目标外设作为块流控制器：" class="headerlink" title="目标外设作为块流控制器："></a><strong>目标外设作为块流控制器</strong>：</h4><ul><li><strong>定义</strong>：当目标外设作为块流控制器时，块大小是目标突发传输和目标单次传输的数量加权平均。它由目标外设进行控制。</li><li><strong>公式</strong>：</li></ul><p>$$<br>\text { blk_size_bytes_dst }&#x3D;\text { (Number of destination burst transactions in block } \times \text { dst_burst_size_bytes })+ \text { (Number of destination single transactions in block } \times \text { dst_single_size_bytes) }<br>$$</p><p>​这表示块大小由目标突发事务和目标单次事务的数量来决定。</p><h2 id="内存外设"><a href="#内存外设" class="headerlink" title="内存外设"></a><a>内存外设</a></h2><h3 id="1-内存外设与DMA传输的特点"><a href="#1-内存外设与DMA传输的特点" class="headerlink" title="1. 内存外设与DMA传输的特点"></a>1. <strong>内存外设与DMA传输的特点</strong></h3><ul><li><strong>没有握手接口（No handshaking interface）</strong>：内存外设通常不具有像外设那样的握手接口（handshaking interface）。这意味着，内存外设无法直接告知DMA控制器何时准备好进行数据传输。因此，当DMA通道被启用后，数据传输会立即开始，而无需等待任何事务请求或信号。</li><li><strong>DMA控制器为流控制器（DMA controller as flow controller）</strong>：在内存外设的情况下，DMA控制器总是充当流控制器。流控制器负责管理数据传输的调度，控制每个块的传输，而不依赖外设来控制流量。因此，对于内存外设，DMA控制器直接控制数据的读取和写入过程，不需要外设插入等待状态。</li></ul><h3 id="2-等待状态（Wait-States）"><a href="#2-等待状态（Wait-States）" class="headerlink" title="2. 等待状态（Wait States）"></a>2. <strong>等待状态（Wait States）</strong></h3><ul><li>如果内存外设没有握手接口，DMA控制器将尝试执行AHB总线传输。此时，内存外设可能会因为无法接受这些传输而插入等待状态。具体来说，如果外设不能立即处理DMA请求，它会通过<strong>de-asserting hready</strong>（即使得<code>hready</code>信号不为高）来插入等待状态，表示当前没有准备好处理数据。DMA控制器将在等待状态结束后继续传输。</li><li><strong>推荐不超过16个等待状态</strong>：插入过多的等待状态可能会影响总线的效率。文中建议不要让外设插入超过16个等待状态，因为过多的等待状态会导致DMA传输过程的延迟，降低数据传输的效率。</li></ul><h3 id="3-握手接口的优势"><a href="#3-握手接口的优势" class="headerlink" title="3. 握手接口的优势"></a>3. <strong>握手接口的优势</strong></h3><ul><li><strong>使用握手接口（Handshaking interface）</strong>：如果外设有握手接口，它可以向DMA控制器发送信号，表明它已经准备好发送或接收数据。通过这种方式，DMA控制器可以在没有等待状态的情况下与外设进行数据传输。</li><li><strong>避免等待状态</strong>：通过握手接口，外设可以主动告知DMA控制器其准备情况，减少了等待状态的数量，提高了数据传输效率。</li></ul><h3 id="4-SRC-MSIZE和DEST-MSIZE在内存外设中的使用限制"><a href="#4-SRC-MSIZE和DEST-MSIZE在内存外设中的使用限制" class="headerlink" title="4. SRC_MSIZE和DEST_MSIZE在内存外设中的使用限制"></a>4. <strong><code>SRC_MSIZE</code>和<code>DEST_MSIZE</code>在内存外设中的使用限制</strong></h3><ul><li><strong>不适用于内存外设</strong>：<code>SRC_MSIZE</code>和<code>DEST_MSIZE</code>是DMA控制器配置的参数，用于定义突发传输的大小，这对于具有握手接口的外设是有意义的，因为外设可能需要规定一个突发传输的大小。然而，这两个参数<strong>不适用于内存外设</strong>。</li><li><strong>内存外设不需要这两个参数</strong>：因为内存一般没有像外设那样有限的资源（比如FIFO缓存），所以内存可以直接进行DMA传输，且不需要设置突发大小。DMA控制器会根据可用的FIFO空间或块传输的要求来决定传输长度。</li></ul><h3 id="5-内存外设的传输规则"><a href="#5-内存外设的传输规则" class="headerlink" title="5. 内存外设的传输规则"></a>5. <strong>内存外设的传输规则</strong></h3><ul><li>从内存到外设的突发传输长度：从内存到外设的突发传输长度取决于通道FIFO中的可用数据项数量和块传输所需的数据项数量（两者取最小值）。<ul><li>这意味着如果FIFO中有足够的空间，DMA将使用更长的突发传输；如果FIFO空间不足，DMA将传输较小的数据块，直到完成块传输。</li></ul></li><li><strong>从外设到内存的突发传输长度</strong>：从外设到内存的突发传输长度规则相似，也是取FIFO中的可用空间和块传输要求的最小值。</li></ul><h2 id="早期终止的突发事务"><a href="#早期终止的突发事务" class="headerlink" title="早期终止的突发事务"></a><a>早期终止的突发事务</a></h2><h3 id="1-早期终止的突发事务"><a href="#1-早期终止的突发事务" class="headerlink" title="1. 早期终止的突发事务"></a>1. <strong>早期终止的突发事务</strong></h3><ul><li>什么是早期终止的突发事务？<ul><li><strong>突发事务</strong>通常指一次连续地传输多个数据项，而不是单独的传输。但如果DMA控制器发现剩余的数据量小于请求的突发大小（即 <code>src_burst_size_bytes</code> 或 <code>dst_burst_size_bytes</code>），那么它会提前终止这个突发事务，仅传输足够的数据以完成当前的数据块传输。</li><li>这种早期终止的突发事务仅在DMA控制器与外设（而不是内存）之间进行时发生，且外设不是“流控制器”时（也就是说DMA控制器负责数据的传输控制）。</li></ul></li></ul><h3 id="2-何时会发生早期终止？"><a href="#2-何时会发生早期终止？" class="headerlink" title="2. 何时会发生早期终止？"></a>2. <strong>何时会发生早期终止？</strong></h3><ul><li>早期终止发生的条件是：<ul><li>外设不是流控制器（也就是DMA控制器在控制传输）。</li><li>数据源或数据目的地外设处于<strong>单事务区（Single Transaction Region）</strong>。</li></ul></li><li>在<strong>单事务区</strong>，DMA控制器本应进行单独的事务，但如果触发了突发请求，而此时剩余的数据量不足以完成整个突发传输，DMA控制器会提前终止突发事务。</li></ul><h3 id="3-早期终止的突发事务行为"><a href="#3-早期终止的突发事务行为" class="headerlink" title="3. 早期终止的突发事务行为"></a>3. <strong>早期终止的突发事务行为</strong></h3><ul><li>当DMA控制器在单事务区检测到突发请求时，但剩余的数据不足以完成整个突发，它将：<ul><li><strong>只传输完成当前数据块所需的数据量</strong>，而不会传输整个突发大小（<code>src_burst_size_bytes</code> 或 <code>dst_burst_size_bytes</code>）。</li><li>这意味着DMA控制器只会传输剩余的数据，以完成当前块的传输，而不会传输多余的数据。</li></ul></li></ul><h3 id="4-DMAH-INCR-BURSTS-配置位的影响"><a href="#4-DMAH-INCR-BURSTS-配置位的影响" class="headerlink" title="4. DMAH_INCR_BURSTS 配置位的影响"></a>4. <strong>DMAH_INCR_BURSTS 配置位的影响</strong></h3><p>发生这种早期终止行为时，DMA控制器的配置位 <code>DMAH_INCR_BURSTS</code> 会影响DMA如何处理突发请求。</p><ul><li>当 <code>DMAH_INCR_BURSTS = 0</code> 时：<ul><li>如果DMA控制器在<strong>单事务区</strong>检测到突发请求，<strong>只会发出单事务传输</strong>，即使是突发请求，也会分成单独的事务进行传输，而不会发起突发事务。</li></ul></li><li>当 <code>DMAH_INCR_BURSTS = 1</code> 时：<ul><li>如果 <code>DMAH_INCR_BURSTS</code> 被设置为 <code>1</code>，DMA控制器会尝试发出<strong>递增突发</strong>（INCR类型的突发）。但这时，突发的长度会被限制为<strong>仅足够完成当前数据块的传输</strong>，而不会传输全部的 <code>src_burst_size_bytes</code> 或 <code>dst_burst_size_bytes</code>。这意味着，突发的长度是未定义的：它会根据当前块的需要来确定长度，而不是按照预定的突发大小。</li></ul></li></ul><h3 id="5-早期终止突发事务的总结"><a href="#5-早期终止突发事务的总结" class="headerlink" title="5. 早期终止突发事务的总结"></a>5. <strong>早期终止突发事务的总结</strong></h3><ul><li><p><strong>早期终止的突发事务</strong>发生在DMA控制器尝试执行一个突发传输，但由于剩余的数据不足以填充整个突发长度，它只会传输足够完成当前块的数据。</p></li><li><p>DMA控制器在单事务区时会自动调整突发事务的长度，确保传输的数据量足够完成数据块的传输。</p></li><li><p><code>DMAH_INCR_BURSTS</code> 配置位的设置决定了DMA如何处理这种情况：</p><ul><li><p>如果 <code>DMAH_INCR_BURSTS = 0</code>，则DMA控制器会发出<strong>单事务传输</strong>，而不是突发事务。</p></li><li><p>如果 <code>DMAH_INCR_BURSTS = 1</code>，DMA控制器会发出<strong>递增突发</strong>，但它的长度会根据需要传输的数据量调整，而不是传输整个预定的突发大小。</p></li></ul></li></ul><h2 id="单事务区"><a href="#单事务区" class="headerlink" title="单事务区"></a><a>单事务区</a></h2><h3 id="1-什么是单事务区（Single-Transaction-Region）？"><a href="#1-什么是单事务区（Single-Transaction-Region）？" class="headerlink" title="1. 什么是单事务区（Single Transaction Region）？"></a>1. <strong>什么是单事务区（Single Transaction Region）？</strong></h3><ul><li><strong>单事务区</strong> 是指在某些情况下，当数据块的大小不足以完全通过突发事务来传输时，DMA控制器会使用单事务（Single Transaction）来完成剩余的数据传输。</li><li>在 DMA 数据传输过程中，如果剩余的数据量小于一个完整的突发事务所能传输的大小（即小于 <code>src_burst_size_bytes</code> 或 <code>dst_burst_size_bytes</code>），DMA控制器就会切换到单事务模式，使用单个事务来完成剩余的数据传输。</li></ul><h3 id="2-为什么会进入单事务区？"><a href="#2-为什么会进入单事务区？" class="headerlink" title="2. 为什么会进入单事务区？"></a>2. <strong>为什么会进入单事务区？</strong></h3><ul><li><strong>原因</strong>：通常，数据块的大小不能完全被突发事务的长度整除，导致剩余的数据量小于一个完整的突发长度。例如，如果数据块大小为 100 字节，而突发长度为 64 字节，最后剩余的数据是 36 字节，不能通过一个 64 字节的突发事务完成。此时，DMA控制器将切换到单事务模式，只传输剩余的 36 字节数据。</li></ul><h3 id="3-DMA控制器和外设的交互"><a href="#3-DMA控制器和外设的交互" class="headerlink" title="3. DMA控制器和外设的交互"></a>3. <strong>DMA控制器和外设的交互</strong></h3><ul><li><strong>外设的单事务标志</strong>：外设通过设置<strong>单事务标志</strong>来通知 DMA 控制器，表示它准备好接收或发送一个完整的单事务数据。这是DMA控制器判断是否可以进入单事务区的一个信号。</li></ul><h3 id="4-单事务区的定义和使用"><a href="#4-单事务区的定义和使用" class="headerlink" title="4. 单事务区的定义和使用"></a>4. <strong>单事务区的定义和使用</strong></h3><ul><li><strong>单事务区</strong>仅在 DMA 控制器使用单事务来完成数据块传输时有效。换句话说，单事务区是在数据块传输过程中，由于剩余数据不足以进行完整的突发传输时，DMA控制器切换到的模式。</li><li>单事务区的外部限制：<ul><li>在单事务区内，只使用单个数据事务（而非突发事务）。</li><li>在单事务区外，DMA控制器仅使用突发事务来传输数据。</li></ul></li></ul><h3 id="5-DMA控制器为流控制器时的行为"><a href="#5-DMA控制器为流控制器时的行为" class="headerlink" title="5. DMA控制器为流控制器时的行为"></a>5. <strong>DMA控制器为流控制器时的行为</strong></h3><ul><li>如果 <strong>DMA控制器是流控制器</strong>，则只有在源外设传输的数据量不足以完成一个完整的突发传输时，才会进入单事务区。</li><li><strong>源外设</strong>：如果剩余数据量小于 <code>src_burst_size_bytes</code>（即源块传输所需的突发数据量），则源外设进入单事务区。如果数据块的大小能够整除突发事务大小（例如，<code>blk_size_bytes / src_burst_size_bytes</code> 是整数），那么源外设将一直使用突发事务，而不会进入单事务区。例如：<ul><li>假设 <code>blk_size_bytes = 256</code> 字节，<code>src_burst_size_bytes = 64</code> 字节，那么 <code>256 / 64 = 4</code>，意味着整个数据块可以通过 4 次 64 字节的突发事务完成，这样源外设永远不会进入单事务区。</li></ul></li><li><strong>目的地外设</strong>：目的地外设则会在剩余数据量小于 <code>dst_burst_size_bytes</code> 时进入单事务区。与源外设类似，如果 <code>blk_size_bytes / dst_burst_size_bytes</code> 是整数，那么目的地外设也将一直使用突发事务，不会进入单事务区。</li></ul><h3 id="6-DMA控制器不是流控制器时的行为"><a href="#6-DMA控制器不是流控制器时的行为" class="headerlink" title="6. DMA控制器不是流控制器时的行为"></a>6. <strong>DMA控制器不是流控制器时的行为</strong></h3><ul><li><strong>如果源或目的地外设是流控制器</strong>（即外设负责数据传输控制），则当外设发送信号指示最后一次事务时（例如，表示数据块的最后一部分需要传输时），DMA控制器会进入单事务区，传输剩余的数据。</li><li>这时，进入单事务区的条件是<strong>外设发出“最后事务”的信号</strong>，并且剩余的数据量少于突发事务的大小（即小于 <code>src_burst_size_bytes</code> 或 <code>dst_burst_size_bytes</code>）。</li></ul><h2 id="硬件握手接口（外设不是流控制器）"><a href="#硬件握手接口（外设不是流控制器）" class="headerlink" title="硬件握手接口（外设不是流控制器）"></a><a>硬件握手接口（外设不是流控制器）</a></h2><h3 id="1-dma-ack（输出）"><a href="#1-dma-ack（输出）" class="headerlink" title="1. dma_ack（输出）"></a>1. <strong>dma_ack（输出）</strong></h3><ul><li><strong>描述</strong>：<code>dma_ack</code> 是来自DMA控制器到外设的确认信号。它在当前事务（单事务或突发事务）的数据传输完成后被激活。</li><li>工作原理：<ul><li>对于 <strong>单事务</strong>：<code>dma_ack</code> 在数据传输结束后保持激活，直到外设解除激活 <code>dma_single</code> 信号，然后 <code>dma_ack</code> 会在一个时钟周期后被取消。</li><li>对于 <strong>突发事务</strong>：<code>dma_ack</code> 在数据传输结束后保持激活，直到外设解除激活 <code>dma_req</code> 信号，然后 <code>dma_ack</code> 会在一个时钟周期后被取消。</li></ul></li></ul><h3 id="2-dma-finish（输出）"><a href="#2-dma-finish（输出）" class="headerlink" title="2. dma_finish（输出）"></a>2. <strong>dma_finish（输出）</strong></h3><ul><li><strong>描述</strong>：<code>dma_finish</code> 是由DMA控制器发出的信号，用于指示数据块的传输完成。它与 <code>dma_ack</code> 信号具有相同的时序。</li><li>工作原理：<ul><li>如果最后的事务是一个 <strong>突发事务</strong>，<code>dma_finish</code> 信号会与外设的 <code>dma_req</code> 信号形成一个握手。</li><li>如果最后的事务是一个 <strong>单事务</strong>，<code>dma_finish</code> 信号会与外设的 <code>dma_single</code> 信号形成一个握手。</li><li>在一些特殊情况下，如源外设和目的地外设角色不同时，<code>dma_finish</code> 信号与 <code>dma_req</code> 信号的时序定义可能会有所不同。</li></ul></li></ul><h3 id="3-dma-last（输入）"><a href="#3-dma-last（输入）" class="headerlink" title="3. dma_last（输入）"></a>3. <strong>dma_last（输入）</strong></h3><ul><li><strong>描述</strong>：<code>dma_last</code> 是一个输入信号，通常由外设提供，但在某些情况下被DMA控制器忽略。由于在DMA传输过程中，外设可能不是流控制器，因此DMA控制器不会采样这个信号。</li><li><strong>工作原理</strong>：当外设不是流控制器时，<code>dma_last</code> 信号被忽略，DMA控制器并不依赖于该信号来判断传输是否完成。</li></ul><h3 id="4-dma-req（输入）"><a href="#4-dma-req（输入）" class="headerlink" title="4. dma_req（输入）"></a>4. <strong>dma_req（输入）</strong></h3><ul><li><strong>描述</strong>：<code>dma_req</code> 是外设请求DMA突发事务的信号。无论 <code>dma_single</code> 信号的状态如何，DMA控制器始终将 <code>dma_req</code> 视为突发事务请求。</li><li>工作原理：<ul><li>这是一个<strong>电平敏感信号</strong>，也就是说外设一旦激活 <code>dma_req</code>，它必须保持激活状态，直到DMA控制器发出 <code>dma_ack</code> 信号。</li><li>当DMA控制器发出 <code>dma_ack</code> 信号表示突发事务完成时，外设应该解除激活 <code>dma_req</code> 信号。之后，DMA控制器才会解除激活 <code>dma_ack</code> 信号。</li><li>如果在 <strong>单事务区</strong>（Single Transaction Region）内检测到 <code>dma_req</code> 激活，DMA控制器会执行一个<strong>提前终止的突发事务</strong>（Early-Terminated Burst Transaction）。这意味着DMA控制器会在剩余数据量较少时提前终止当前的突发事务。</li></ul></li></ul><h3 id="5-dma-single（输入）"><a href="#5-dma-single（输入）" class="headerlink" title="5. dma_single（输入）"></a>5. <strong>dma_single（输入）</strong></h3><ul><li><strong>描述</strong>：<code>dma_single</code> 是一个状态信号，由外设提供，表示外设是否准备好进行单次数据传输。</li><li>工作原理：<ul><li>对于 <strong>目的地外设</strong>：当 <code>dma_single</code> 被激活时，表示目的地外设能够接收至少一个数据项；如果不能接收，则清除该信号。</li><li>对于 <strong>源外设</strong>：当 <code>dma_single</code> 被激活时，表示源外设能够传输至少一个数据项；如果不能传输，则清除该信号。</li><li>一旦 <code>dma_single</code> 信号被激活，它必须保持激活状态，直到DMA控制器发出 <code>dma_ack</code> 信号，之后外设才能解除激活 <code>dma_single</code> 信号。</li><li><code>dma_single</code> 信号只在 <strong>单事务区</strong> 中被采样。在该区外，DMA控制器会使用突发事务，因此 <code>dma_single</code> 信号会被忽略。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DMA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uMTL2-Data Bus Inversion(DBI)</title>
      <link href="/2024/11/27/DDR/uMTL2-Data%20Bus%20Inversion(DBI)/"/>
      <url>/2024/11/27/DDR/uMTL2-Data%20Bus%20Inversion(DBI)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>uMCTL2手册2.24，数据总线反转功能<a><span id="more"></span></a></p></blockquote><h2 id="1-DBI-功能介绍"><a href="#1-DBI-功能介绍" class="headerlink" title="1. DBI 功能介绍"></a><strong>1. DBI 功能介绍</strong></h2><ul><li>在 DDR4 中，逻辑 0 比逻辑 1 消耗更多的功耗，而在 LPDDR4 中，逻辑 1 比逻辑 0 消耗更多的功耗。</li><li>DBI 通过对每个数据字节进行反转来减少功耗。如果某个字节中 0 的数量（对于 DDR4）或 1 的数量（对于 LPDDR4）超过 4，那么该字节的数据将被反转。</li><li>使用一个 DBI 信号（每个数据字节 1 位）来指示是否进行了数据反转。</li></ul><h2 id="2-写操作和读操作中的DBI"><a href="#2-写操作和读操作中的DBI" class="headerlink" title="2. 写操作和读操作中的DBI"></a><strong>2. 写操作和读操作中的DBI</strong></h2><ul><li>对于写操作，DBI 信号与 DFI 接口的 <code>dfi_wrdata_mask</code> 信号共享。</li><li>对于读操作，有一个专用的信号 <code>dfi_rddata_dbi</code> 来指示数据是否需要反转。</li></ul><h3 id="支持的设备类型"><a href="#支持的设备类型" class="headerlink" title="支持的设备类型"></a><strong>支持的设备类型</strong></h3><ul><li>DBI 功能只支持 x8 和 x16 的设备，不支持 x4 设备。</li></ul><h2 id="3-DDR4-与-LPDDR4-的差异"><a href="#3-DDR4-与-LPDDR4-的差异" class="headerlink" title="3. DDR4 与 LPDDR4 的差异"></a><strong>3. DDR4 与 LPDDR4 的差异</strong></h2><ul><li>在 DDR4 中，写操作的 DBI 和数据掩码（Data Mask）不能同时启用。而在 LPDDR4 中，写操作的 DBI 和数据掩码是可以同时启用的。</li><li>在 DBI 模式下，DDR4 不允许带掩码的写操作，但 LPDDR4 允许带掩码的写操作。在这种情况下，uMCTL2（内存控制器）通过将 <code>dfi_wrdata</code> 字节设置为 0xFF，并将 <code>dfi_wrdata_mask</code> 设置为 0 来指示掩码字节。</li></ul><h2 id="4-DBI控制的实现"><a href="#4-DBI控制的实现" class="headerlink" title="4. DBI控制的实现"></a>4. <strong>DBI控制的实现</strong></h2><ul><li>DBI 的实现可以在控制器（uMCTL2）或 PHY（物理层）中进行。在 uMCTL2 中，DBI 的控制由 <code>DFIMISC.phy_dbi_mode</code>位控制。<ul><li>如果 <code>phy_dbi_mode</code> 设置为 1，则 DBI 的生成和数据反转在 PHY 中完成，DFI 接口上的读写数据与 DBI 禁用时一样，<code>dfi_rddata_dbi</code> 信号将被忽略。</li><li>如果 <code>phy_dbi_mode</code> 设置为 0，则 DBI 生成和数据反转在 uMCTL2 中完成。在写操作时，DBI 值会被放在 <code>dfi_wrdata_mask</code> 信号上；在读操作时，<code>dfi_rddata_dbi</code> 信号决定是否需要反转读数据的极性。</li></ul></li></ul><h2 id="5-DBI-控制寄存器"><a href="#5-DBI-控制寄存器" class="headerlink" title="5. DBI 控制寄存器"></a><strong>5. DBI 控制寄存器</strong></h2><ul><li><code>DBICTL</code> 寄存器包含三个字段：<ul><li><code>rd_dbi_en</code>：启用读 DBI。</li><li><code>wr_dbi_en</code>：启用写 DBI。</li><li><code>dm_en</code>：启用数据掩码。</li></ul></li><li>软件必须确保这些值与写入模式寄存器的值一致。</li></ul><h2 id="6-启用读-DBI时，延迟增加"><a href="#6-启用读-DBI时，延迟增加" class="headerlink" title="6. 启用读 DBI时，延迟增加"></a><strong>6. 启用读 DBI时，延迟增加</strong></h2><ul><li>如果启用读 DBI（<code>rd_dbi_en</code>），JEDEC规范要求 DDR4 的 CAS 延迟（CL）或 LPDDR4 的读取延迟（RL）必须增加。因此，在启用 DBI 时，必须根据增加的延迟调整相关的寄存器。</li></ul><h3 id="需要调整的寄存器"><a href="#需要调整的寄存器" class="headerlink" title="需要调整的寄存器"></a><strong>需要调整的寄存器</strong></h3><p>启用读 DBI时，以下寄存器需要根据 CL（或 RL）调整：</p><ul><li><code>DFITMG0.dfi_t_rddata_en</code></li><li><code>DRAMTMG2.read_latency</code></li><li><code>DRAMTMG2.rd2wr</code></li><li><code>DFITMG2.dfi_tphy_rdcslat</code></li><li><code>INIT4.emr2</code>（仅限 LPDDR4）</li><li><code>INIT6.mr5</code>（仅限 DDR4）</li></ul><h3 id="添加延迟（Additive-Latency，AL）与-DDR4"><a href="#添加延迟（Additive-Latency，AL）与-DDR4" class="headerlink" title="添加延迟（Additive Latency，AL）与 DDR4"></a><strong>添加延迟（Additive Latency，AL）与 DDR4</strong></h3><ul><li>如果选择了非零的添加延迟（AL）用于 DDR4，则也与 CL 相关。因此，以下寄存器也可能需要更新。在这种情况下，需要先进入自刷新模式，然后更新这些寄存器，因为 <code>DFITMG0.dfi_tphy_wrlat</code> 是一个“组 2”的准动态寄存器。</li><li>需要更新的寄存器包括：<ul><li><code>DFITMG0.dfi_tphy_wrlat</code></li><li><code>DRAMTMG0.wr2pre</code></li><li><code>DRAMTMG1.rd2pre</code></li><li><code>DRAMTMG2.write_latency</code></li><li><code>DRAMTMG4.t_rcd</code></li></ul></li></ul><h3 id="启用或禁用-DBI-的步骤"><a href="#启用或禁用-DBI-的步骤" class="headerlink" title="启用或禁用 DBI 的步骤"></a><strong>启用或禁用 DBI 的步骤</strong></h3><p>启用或禁用 DBI 时，必须按照以下顺序操作：</p><ol><li><strong>进入准动态寄存器写入模式</strong>：如果 DDR4 选择了非零的 AL，则需要进入自刷新模式。在没有非零 AL 的情况下，参照手册中的 “Group 1” 模式，禁用读写流量。</li><li>设置 <code>DBICTL.rd_dbi_en</code> 和 <code>DBICTL.wr_dbi_en</code>：根据需要启用或禁用读写DBI。</li><li><strong>设置 DRAM 模式寄存器</strong>：使其与先前的设置匹配。</li><li><strong>调整 DDR4 的 CL（在 MR0 中）</strong>：LPDDR4 不需要更改 CL。</li><li><strong>根据 CL（或 RL）和 AL 调整寄存器</strong>：根据需要调整上述相关寄存器。</li><li><strong>退出准动态模式</strong>：退出自刷新模式或重新启用读写流量。</li></ol><h2 id="7-准动态寄存器"><a href="#7-准动态寄存器" class="headerlink" title="7. 准动态寄存器"></a><strong>7. 准动态寄存器</strong></h2><ul><li>准动态寄存器是指那些在某些模式下（如自刷新、深度睡眠模式等）仍然可以写入的寄存器。在进入或退出这些模式时，需要特别注意寄存器的写入顺序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> uMCTL2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design For Test-DDL TEST</title>
      <link href="/2024/11/26/DDR/Design%20For%20Test-DDL%20TEST/"/>
      <url>/2024/11/26/DDR/Design%20For%20Test-DDL%20TEST/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pub手册6.3，关于DDL（Digital Delay Line，数字延迟线）的测试部分<a><span id="more"></span></a></p></blockquote><h2 id="1-DDL（数字延迟线）测试简介"><a href="#1-DDL（数字延迟线）测试简介" class="headerlink" title="1. DDL（数字延迟线）测试简介"></a><strong>1. DDL（数字延迟线）测试简介</strong></h2><h3 id="1-1-DDL的基本概念"><a href="#1-1-DDL的基本概念" class="headerlink" title="1.1 DDL的基本概念"></a><strong>1.1 DDL的基本概念</strong></h3><p>数字延迟线（DDL）是一个可调的延迟线，其基本作用是增加信号的延迟。DDL常被用于调整时序，使得信号的传输符合系统要求。每个DDL通常充当一个简单的缓冲器（buffer），但可以通过改变延迟值来改变信号到达目的地的时间。</p><h3 id="1-2-测试时的问题"><a href="#1-2-测试时的问题" class="headerlink" title="1.2 测试时的问题"></a><strong>1.2 测试时的问题</strong></h3><p>在进行逻辑扫描测试时，输入信号会通过DDL传输，并通过输出端传递到下一级电路，验证是否传递了正确的逻辑值（0或1）。然而，逻辑扫描并不能直接测量每个DDL设置的延迟，也不能确认这些延迟组合是否会形成特定的时序特性。因此，DDL的延迟特性不能仅仅通过逻辑扫描来准确评估。</p><hr><h3 id="1-3-DDL的类型"><a href="#1-3-DDL的类型" class="headerlink" title="1.3 DDL的类型"></a><strong>1.3 DDL的类型</strong></h3><h4 id="1-3-1-LCDL"><a href="#1-3-1-LCDL" class="headerlink" title="1.3.1 LCDL"></a><strong>1.3.1 LCDL</strong></h4><ul><li><strong>定义</strong>：LCDL是长延迟线，具有较大的最大延迟值。它通常用于需要较大时序调整的场景。例如，LCDL可用于调整数据总线（如DQ、DQS等）上的偏移。</li><li><strong>应用</strong>：通常用于调整数据传输的时序，特别是大范围的时序偏移（例如，数据&#x2F;时钟的同步）。</li></ul><h4 id="1-3-2-BDL"><a href="#1-3-2-BDL" class="headerlink" title="1.3.2 BDL"></a><strong>1.3.2 BDL</strong></h4><ul><li><strong>定义</strong>：BDL是短延迟线（相较于LCDL），具有较小的最大延迟值。它通常用于较小范围的时序调整。</li><li><strong>应用</strong>：例如，在DATX8和DATX4X2模块中，BDL主要用于写入和读取比特的去偏移。</li></ul><h4 id="1-3-3-NDL"><a href="#1-3-3-NDL" class="headerlink" title="1.3.3 NDL"></a><strong>1.3.3 NDL</strong></h4><ul><li><strong>定义</strong>：NDL是固定延迟线，它的延迟是一个固定值，通常用于与LCDL的零延迟对齐。</li><li><strong>应用</strong>：NDL通常用于某些特定的时序要求，以保证延迟线之间的一致性。</li></ul><hr><h3 id="1-4-DDL的可观察性"><a href="#1-4-DDL的可观察性" class="headerlink" title="1.4 DDL的可观察性"></a><strong>1.4 DDL的可观察性</strong></h3><h4 id="1-4-1-可观察DDL的情况"><a href="#1-4-1-可观察DDL的情况" class="headerlink" title="1.4.1 可观察DDL的情况"></a><strong>1.4.1 可观察DDL的情况</strong></h4><p>并不是所有的DDL都会影响主输出引脚（如DQ、DQS等），有些DDL只影响内部信号节点。对于某些DDL，可以通过测试来观察其延迟的效果。特别是在影响写入比特去偏移的DDL时，通过编程DDL的延迟值寄存器，可以在输出引脚（如DQ、DQS、DM）上观察到信号的时序变化。</p><h4 id="1-4-2-直接访问和测试的局限性"><a href="#1-4-2-直接访问和测试的局限性" class="headerlink" title="1.4.2 直接访问和测试的局限性"></a><strong>1.4.2 直接访问和测试的局限性</strong></h4><p>尽管一些DDL是可观察的，但并非所有DDL都直接影响主输出引脚。有些DDL只在内部起作用，因此无法通过主引脚直接测试它们。此外，DDL的最小延迟步长通常非常小，这使得常规的自动测试设备（ATE）难以精确测量这些微小的变化。通常，测试时只能在较大的步长范围内进行测量，因此这并不是一个完美的解决方案。</p><hr><h3 id="1-5-DDL环振荡器测试模式"><a href="#1-5-DDL环振荡器测试模式" class="headerlink" title="1.5 DDL环振荡器测试模式"></a><strong>1.5 DDL环振荡器测试模式</strong></h3><h4 id="1-5-1-环振荡器的基本原理"><a href="#1-5-1-环振荡器的基本原理" class="headerlink" title="1.5.1 环振荡器的基本原理"></a><strong>1.5.1 环振荡器的基本原理</strong></h4><p>为了能够全面测试DDL，DDR4设计了DDL环振荡器模式。在此模式下，所有的NDL、BDL和LCDL都会被连接成一个环形振荡器。这一环形振荡器是由多个延迟线组成的，通过将一个DDL的数字测试输出（DTO）连接到下一个DDL的数字测试输入（DTI），形成一个闭环。</p><h4 id="1-5-2-振荡器的具体连接方式"><a href="#1-5-2-振荡器的具体连接方式" class="headerlink" title="1.5.2 振荡器的具体连接方式"></a><strong>1.5.2 振荡器的具体连接方式</strong></h4><ul><li><strong>连接方式</strong>：环振荡器的结构是将DDL连接成一个环，其中每个延迟线的DTO连接到下一个DDL的DTI，最后一个DDL的DTO通过NAND门连接回第一个DDL的DTI，完成闭环。</li><li><strong>环路的控制</strong>：这个环振荡器的输出信号会通过一个可编程的分频器进行频率降低，以便在控制时钟域（如PUB时钟）中进行处理。</li></ul><p><img src="https://s2.loli.net/2024/11/26/cW42ezXyRi8LloM.png" alt="image-20241126235545585"></p><h4 id="1-5-3-独立测试"><a href="#1-5-3-独立测试" class="headerlink" title="1.5.3 独立测试"></a><strong>1.5.3 独立测试</strong></h4><p>每个PHY模块（如DATX8、DATX4X2、AC、ACX48）都具有独立的环振荡器，可以并行测试整个接口。这使得在测试过程中可以同时监测多个DDL的延迟行为，减少测试时间。</p><hr><h3 id="1-6-测试DDL的特性"><a href="#1-6-测试DDL的特性" class="headerlink" title="1.6 测试DDL的特性"></a><strong>1.6 测试DDL的特性</strong></h3><h4 id="1-6-1-延迟线的特性测试"><a href="#1-6-1-延迟线的特性测试" class="headerlink" title="1.6.1 延迟线的特性测试"></a><strong>1.6.1 延迟线的特性测试</strong></h4><p>通过调整DDL的选择输入，可以测试每个DDL的多个特性，包括：</p><ul><li><strong>存在性测试</strong>：确认每个DDL是否正常工作。</li><li><strong>线性度测试</strong>：测试DDL延迟的变化是否随着输入的调整而线性变化。</li><li><strong>延迟范围测试</strong>：确认每个DDL的延迟范围是否满足时序要求。</li></ul><h4 id="1-6-2-测量延迟变化"><a href="#1-6-2-测量延迟变化" class="headerlink" title="1.6.2 测量延迟变化"></a><strong>1.6.2 测量延迟变化</strong></h4><p>在测试过程中，可以通过调整DDL的选择输入，观察环振荡器输出的周期变化，进而了解DDL的延迟特性。为了提高测量精度，输出信号会通过一个可编程分频器降低频率，以便在较低速时钟下处理这些信号。</p><hr><h3 id="1-7-测量方法"><a href="#1-7-测量方法" class="headerlink" title="1.7 测量方法"></a><strong>1.7 测量方法</strong></h3><h4 id="1-7-1-分频器和测试分辨率"><a href="#1-7-1-分频器和测试分辨率" class="headerlink" title="1.7.1 分频器和测试分辨率"></a><strong>1.7.1 分频器和测试分辨率</strong></h4><p>通过环振荡器的输出，分频器将振荡器的频率降低。这个分频比率可以根据需要进行设置，通常范围从1到65536。选择合适的分频比率可以在测试时调整分辨率和测试时间。</p><ul><li><strong>分频比率的选择</strong>：通过调整分频比率，可以在不同的时间精度和测试分辨率之间进行平衡。例如，如果需要更高的测量精度，可以选择较大的分频比率，但这样可能需要更长的测试时间。</li></ul><h4 id="1-7-2-自动周期测量"><a href="#1-7-2-自动周期测量" class="headerlink" title="1.7.2 自动周期测量"></a><strong>1.7.2 自动周期测量</strong></h4><p>在测试过程中，PUB（控制单元）中的逻辑可以自动测量环振荡器输出信号的周期，并将结果存储在寄存器中。这个周期值相对于PUB的控制时钟（<code>ctl_clk</code>）来说，是一种相对的周期测量。</p><h2 id="2-DDL结构"><a href="#2-DDL结构" class="headerlink" title="2. DDL结构"></a><strong>2. DDL结构</strong></h2><h3 id="2-1-DDL的设计结构"><a href="#2-1-DDL的设计结构" class="headerlink" title="2.1 DDL的设计结构"></a><strong>2.1 DDL的设计结构</strong></h3><p>数字延迟线（DDL）是由一系列粗延迟单元（coarse delay elements）和一个精细延迟单元（fine delay element）组成的。其设计目的是通过控制延迟元素的数量，调节信号的延迟。</p><ul><li><strong>粗延迟单元（Coarse Delay Element）</strong>：这部分用于提供较大的延迟变化，它通常由多个相同类型的单元组成。对于不同类型的DDL（例如BDL和LCDL），粗延迟单元的数量会有所不同。具体来说，BDL包含4个粗延迟单元，而LCDL包含32个粗延迟单元。</li><li><strong>精细延迟单元（Fine Delay Element）</strong>：精细延迟单元用于提供非常小的延迟变化，它比粗延迟单元的调整更为细致。BDL和LCDL使用相同类型的精细延迟单元，精细延迟单元的调节步长为16个细节步骤。即，通过精细调节，可以实现非常精确的延迟控制。</li></ul><h3 id="2-2-DDL的延迟设置"><a href="#2-2-DDL的延迟设置" class="headerlink" title="2.2 DDL的延迟设置"></a><strong>2.2 DDL的延迟设置</strong></h3><p>在设置DDL的延迟时，首先会选择一个合适的粗延迟单元数量。粗延迟单元的数量决定了DDL的基本延迟范围。如果需要更精细的调整，可以启用精细延迟单元。精细延迟单元提供更细粒度的调节，以便在需要时精确地调整信号的延迟。</p><ul><li><strong>BDL</strong>：BDL包含16步精细延迟和4步粗延迟。这意味着BDL能够提供相对较小的延迟变化（精细调整）以及较大的延迟步长（粗调整）。</li><li><strong>LCDL</strong>：LCDL包含16步精细延迟和32步粗延迟。相比BDL，LCDL可以提供更大的延迟范围，因为它有更多的粗延迟步骤。</li></ul><h2 id="3-DDL测试观察"><a href="#3-DDL测试观察" class="headerlink" title="3. DDL测试观察"></a><strong>3. DDL测试观察</strong></h2><h3 id="3-1-测试方法概述"><a href="#3-1-测试方法概述" class="headerlink" title="3.1 测试方法概述"></a><strong>3.1 测试方法概述</strong></h3><p>测试DDL的效果主要有两种方式。它们都利用了环振荡器输出信号（即环振荡器生成的时钟信号），这个信号经过一定的处理后送到PUB（控制单元）进行进一步测试和观测。</p><h3 id="3-2-第一种测试方法：由PUB计算频率"><a href="#3-2-第一种测试方法：由PUB计算频率" class="headerlink" title="3.2 第一种测试方法：由PUB计算频率"></a><strong>3.2 第一种测试方法：由PUB计算频率</strong></h3><p>在这种测试方法中，环振荡器的输出信号（经过可编程分频器分频）被传送到PUB。PUB使用其内部的控制时钟（<code>ctl_clk</code>）对环振荡器的输出信号进行采样，并通过某种数学运算计算出一个代表环振荡器频率的值。</p><ul><li><strong>采样过程</strong>：由于PUB的控制时钟可能在较慢的速度下运行，因此可以通过设置适当的时钟分频比率（分频器的值）来确保测试的准确性和效率。</li><li><strong>测试的优点</strong>：这种方法通过自动计算频率，可以快速得到环振荡器频率的结果，并且能够并行测试多个PHY模块（如AC、ACX48、DATX8、DATX4X2）。这使得整体测试时间得以缩短。</li></ul><h3 id="3-3-第二种测试方法：直接观察分频后的时钟信号"><a href="#3-3-第二种测试方法：直接观察分频后的时钟信号" class="headerlink" title="3.3 第二种测试方法：直接观察分频后的时钟信号"></a><strong>3.3 第二种测试方法：直接观察分频后的时钟信号</strong></h3><p>另一种测试方法是将环振荡器输出信号通过分频器后，直接输出到数字测试输出（DTO）。通过这种方式，用户可以直接观察到环振荡器的时钟波形。</p><ul><li><strong>优点</strong>：这种方法适合在设备调试或表征时使用，能够让工程师直接看到时钟信号的波形，帮助调试和理解DDL的延迟行为。</li><li><strong>局限性</strong>：尽管这种方法在调试时有用，但它并不适合作为生产测试的标准方式。在生产测试中，如果每个PHY模块都需要单独观察时钟波形，测试时间会大大增加，因为只能同时测试一个PHY模块。</li></ul><h3 id="3-4-比较两种测试方法"><a href="#3-4-比较两种测试方法" class="headerlink" title="3.4 比较两种测试方法"></a><strong>3.4 比较两种测试方法</strong></h3><ul><li>方法一：PUB计算频率：<ul><li><strong>优点</strong>：可以并行测试多个PHY模块，测试时间较短。</li><li><strong>适用场景</strong>：生产测试，能够快速获取频率值。</li></ul></li><li>方法二：直接观察信号波形：<ul><li><strong>优点</strong>：可以直观地看到信号波形，适用于设备调试和表征。</li><li><strong>缺点</strong>：只能一次测试一个PHY模块，测试效率较低，不适合生产环境。</li></ul></li></ul><h2 id="4-测试方法"><a href="#4-测试方法" class="headerlink" title="4. 测试方法"></a><strong>4. 测试方法</strong></h2><h3 id="4-1-DDL测试的整体框架"><a href="#4-1-DDL测试的整体框架" class="headerlink" title="4.1 DDL测试的整体框架"></a><strong>4.1 DDL测试的整体框架</strong></h3><p>PHY模块与PUB控制单元共同提供DDL环振荡器模式测试功能。通过使用PUB的可编程寄存器控制测试过程，测试方法可以根据需求进行定制。例如，在生产测试中，可能会选择进行采样测试，以减少测试时间，而将详尽测试保留用于样本测试或质量保证（QA）环节。在这种方法中，测试的样本大小或类型可以根据产品的需求进行调整。</p><h3 id="4-2-测试方法概述"><a href="#4-2-测试方法概述" class="headerlink" title="4.2 测试方法概述"></a><strong>4.2 测试方法概述</strong></h3><p>建议的DDL测试方法包括两个主要步骤：设置测试环境和实际进行测试。具体步骤如下：</p><h4 id="步骤1：设置PUB和PHY宏进行DDL测试"><a href="#步骤1：设置PUB和PHY宏进行DDL测试" class="headerlink" title="步骤1：设置PUB和PHY宏进行DDL测试"></a><strong>步骤1：设置PUB和PHY宏进行DDL测试</strong></h4><p>在进行DDL测试之前，首先需要设置PUB和PHY宏的相关参数，确保测试环境配置正确。</p><p><strong>a. 如果计划观察DDL振荡器测试模式输出到DTO I&#x2F;O接口，启用DTO I&#x2F;O并确保其不处于电源关闭状态：</strong></p><ul><li><strong>DSGCR.DTOPDR</strong> &#x3D; <code>1&#39;b0</code>（不处于电源关闭）</li><li><strong>DSGCR.DTOOE</strong> &#x3D; <code>1&#39;b1</code>（启用DTO输出）</li></ul><p><strong>b. 可选择将PLL和I&#x2F;O设备置于电源关闭模式</strong>，通过写入其相应的电源控制寄存器来实现。</p><p><strong>c. 禁用VT计算并禁用VT漂移补偿</strong>，通过设置VT漂移限制为0：</p><ul><li><strong>PGCR6.INHVT</strong> &#x3D; <code>1&#39;b1</code>（禁止VT计算）</li><li><strong>PGCR6.DLDLMT</strong> &#x3D; <code>9&#39;h00</code>（将VT漂移限制设置为0）</li></ul><p><strong>d. 重置PHY宏，但不重置PUB逻辑，并禁用地址&#x2F;命令通道MDL校准：</strong></p><ul><li><strong>PGCR1.PHYHRST</strong> &#x3D; <code>1&#39;b0</code>（禁用PHY重置）</li><li><strong>PGCR1.MDLEN</strong> &#x3D; <code>1&#39;b0</code>（禁用MDL校准）</li></ul><blockquote><p><strong>注意：</strong> 在仿真中，PHY宏需要重置以防止读取数据被错误地反馈到DFI控制器中，但在正常测试中DFI控制器不活跃，因此FIFO是否处于重置状态不影响测试。</p></blockquote><p><strong>e. 禁用字节通道MDL校准和字节通道的占空比校正：</strong></p><ul><li><strong>DXCCR.MDLEN</strong> &#x3D; <code>1&#39;b0</code>（禁用字节通道MDL校准）</li><li><strong>DXCCR.DXDCCBYP</strong> &#x3D; <code>1&#39;b1</code>（跳过字节通道占空比校正）</li><li><strong>PGCR4.ACDCCBYP</strong> &#x3D; <code>1&#39;b1</code>（跳过地址&#x2F;命令占空比校正）</li></ul><p><strong>f. 解除PHY宏的重置（该重置不会自动清除）：</strong></p><ul><li><strong>PGCR1.PHYHRST</strong> &#x3D; <code>1&#39;b1</code>（解除PHY重置）</li></ul><p><strong>g. 启用延迟线振荡器测试模式：</strong></p><ul><li><strong>PGCR0.DLTMODE</strong> &#x3D; <code>1&#39;b1</code>（启用DDL测试模式）</li></ul><p><strong>h. 等待至少100ns。</strong></p><p><strong>i. 将PHY模块中的所有DDL设置为最小延迟（0x0）。</strong></p><hr><h4 id="步骤2：测试DDL"><a href="#步骤2：测试DDL" class="headerlink" title="步骤2：测试DDL"></a><strong>步骤2：测试DDL</strong></h4><p>在设置好测试环境后，开始测试每个DDL。测试过程按照以下步骤进行：</p><p><strong>a. 选择一个DDL进行测试。</strong></p><p><strong>b. 启用DDL振荡模式并设置所需的振荡器分频比：</strong></p><ul><li><strong>PGCR0.OSCEN</strong> &#x3D; <code>1&#39;b1</code>（启用振荡器）</li><li><strong>PGCR0.OSCDIV</strong> &#x3D; 所需的振荡器分频比</li><li><strong>PGCR0.DTOSEL</strong> &#x3D; 选择输出DTO的PHY实例</li></ul><p>如果选择的是LCDL（大范围延迟线），确保只选择该LCDL并通过设置以下寄存器选择正确的LCDL：</p><ul><li><strong>PGCR0.OSCWDL</strong>, <strong>PGCR0.OSCWDDL</strong>, <strong>PGCR0.OSCACDL</strong>：根据LCDL的选择设置为正确值。</li></ul><p><strong>c. 等待一个未确定的时间（TBD）。</strong></p><p><strong>d. 触发DDL测试输出周期测量：</strong></p><ul><li><strong>PGCR0.DLTST</strong> &#x3D; <code>1&#39;b1</code>（触发DDL测试）</li></ul><p><strong>e. 等待DDL测试输出周期测量完成，通过轮询PGSR1.DLTDONE来确认：</strong></p><ul><li>对于AC&#x2F;ACX48模块，检查 <strong>PGSR1.DLTDONE</strong> &#x3D; <code>1&#39;b1</code>。</li><li>对于DATX8&#x2F;DATX4X2模块，检查 <strong>DXnGSR1.DLTDONE</strong> &#x3D; <code>1&#39;b1</code>。</li></ul><p><strong>f. 读取测量的周期值：</strong></p><ul><li>对于AC&#x2F;ACX48模块，读取 <strong>PGSR1.DLTCODE</strong>。</li><li>对于DATX8&#x2F;DATX4X2模块，读取 <strong>DXnGSR1.DLTCODE</strong>。</li></ul><p><strong>g. 禁用DDL振荡和测量功能：</strong></p><ul><li><strong>PGCR0.OSCEN</strong> &#x3D; <code>1&#39;b0</code>（禁用振荡器）</li><li><strong>PGCR0.DLTST</strong> &#x3D; <code>1&#39;b0</code>（禁用DDL测试）</li></ul><p><strong>h. 增加精细延迟元素一步并重复步骤2b到2h。</strong></p><p><strong>i. 一旦完成所有精细步设置，将精细延迟设置回最小值（0x0），并增加粗延迟元素一步。重复步骤2b到2i，但跳过步骤2h（即保持精细延迟代码最小值）。</strong></p><p><strong>j. 完成所有粗延迟步骤后，你将获得每个精细和粗延迟步骤的测试结果记录。</strong></p><p><strong>k. 将DDL的延迟代码设置回最小值，并切换到PHY模块中的下一个DDL。重复测试直到所有DDL都完成。</strong></p><hr><h4 id="通过标准"><a href="#通过标准" class="headerlink" title="通过标准"></a><strong>通过标准</strong></h4><p>每个DDL的测试通过标准如下：</p><ul><li><strong>每个增量精细步的值必须大于上一个步的值。</strong></li><li><strong>第一个粗步的值必须等于或大于精细元素的最大值。</strong></li><li><strong>每个增量粗步的值必须大于上一个步的值。</strong></li></ul><p>为了减少测试时间，因为粗延迟的最小步长大于精细延迟步长，可以在测试粗延迟时使用较小的输出时钟分频比。</p><p><strong>并行测试：</strong></p><ul><li>AC&#x2F;ACX48和每个DATX8&#x2F;DATX4X2模块可以并行测试，因此需要为每个模块配置适当的寄存器并同时读取测试结果。</li><li><strong>AC&#x2F;ACX48与DATX8&#x2F;DATX4X2的测试有所不同</strong>，因为它们使用的BDL和LCDL数量不同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> PUB </tag>
            
            <tag> DDR DFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design For Test-PLL TEST</title>
      <link href="/2024/11/26/DDR/Design%20For%20Test-PLL%20TEST/"/>
      <url>/2024/11/26/DDR/Design%20For%20Test-PLL%20TEST/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pub手册6.4，关于PLL（Phase-Locked Loop，锁相环）的测试部分<a><span id="more"></span></a></p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a>介绍</a></h3><p>在每个<strong>PHY（物理层，Physical Layer）</strong>模块中，都有一个嵌入式的PLL。这个PLL有两个主要的任务：</p><ol><li><strong>时钟倍频（Clock Multiplication）</strong></li><li><strong>延时补偿（Delay Compensation）</strong></li></ol><h4 id="时钟倍频"><a href="#时钟倍频" class="headerlink" title="时钟倍频"></a>时钟倍频</h4><ul><li><strong>输入时钟（Reference Clock）</strong>：PLL接收一个参考时钟输入。</li><li><strong>输出时钟</strong>：PLL会产生两个输出时钟，一个是输入时钟的1倍频率（1X），另一个是输入时钟的4倍频率（4X）。这两个输出时钟需要保持在<strong>相位一致</strong>（within a specified parameter）。具体来说，它们的相位偏差必须在一个规定的范围内。</li></ul><h4 id="延时补偿"><a href="#延时补偿" class="headerlink" title="延时补偿"></a>延时补偿</h4><ul><li>在DDR系统中，由于信号的传输延时和电路的不同，时钟信号和数据传输的时序关系需要进行补偿，以保证数据的准确传输。PLL在这个过程中负责将输入时钟的相位与输出时钟进行对齐。</li><li><strong>相位对齐（Phase Alignment）</strong>：由于有时钟反馈路径的存在，PLL的1X输出时钟必须与输入的参考时钟<strong>相位对齐</strong>（phase-aligned），同样这也有一个规定的容差范围。</li></ul><h3 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h3><p>在进行PLL测试时，有几个关键的参数需要特别关注：</p><ol><li><strong>锁定范围（Lock Range）</strong>：<ul><li>PLL需要在一定范围内保持锁相，即它能够锁定输入时钟并稳定输出频率。如果输入时钟的频率偏离了PLL的锁定范围，PLL就不能正常工作。</li></ul></li><li><strong>输出时钟频率（Output Clock Frequency）</strong>：<ul><li>这是PLL输出时钟的频率。在测试时需要确保输出时钟的频率是正确的，符合系统的需求。</li></ul></li><li><strong>输出时钟抖动（Output Clock Jitter）</strong>：<ul><li>时钟信号在时间上的波动或不稳定性称为“抖动”。对于PLL来说，输出时钟的抖动越小，系统的时序稳定性越好。抖动过大会导致数据传输错误。</li></ul></li><li><strong>输出时钟占空比（Output Clock Duty Cycle）</strong>：<ul><li>这是指输出时钟信号中高电平（1）持续的时间占整个周期的比例。虽然这个参数在测试中不如上面的参数重要，但它仍然是一个需要注意的因素，特别是在高频工作时。</li></ul></li><li><strong>相位误差（Phase Error）</strong>：<ul><li>延时补偿的一个重要参数是相位误差。这指的是PLL输出时钟和输入参考时钟之间的相位偏差。在延时补偿过程中，PLL需要尽量减少这种误差，以保证数据的正确传输。</li></ul></li></ol><h3 id="测试目标"><a href="#测试目标" class="headerlink" title="测试目标"></a>测试目标</h3><p>在产品的<strong>表征（characterization）</strong>和<strong>质量控制（QA）</strong>过程中，需要确保PLL的这些参数符合规定的要求。在生产测试中，PLL的这些关键参数也是必须测试和验证的。</p><hr><h3 id="控制和观察部分"><a href="#控制和观察部分" class="headerlink" title="控制和观察部分"></a><a>控制和观察部分</a></h3><h4 id="模拟测试输出（Analog-Test-Output）"><a href="#模拟测试输出（Analog-Test-Output）" class="headerlink" title="模拟测试输出（Analog Test Output）"></a>模拟测试输出（Analog Test Output）</h4><p>PLL内部有一个<strong>模拟测试输出</strong>，通常是连接到AC&#x2F;ACX48和DATX8&#x2F;DATX4X2模块的<code>pll_ato</code>引脚。模拟输出的作用是提供内部电压信号的监控，可以观察PLL内部的不同电压节点。</p><ul><li><strong>模拟输出的控制</strong>：模拟测试输出有一个<strong>模拟多路选择器（analog mux）</strong>，它允许当不使用时将输出置为<strong>三态（tri-state）</strong>，这样可以把多个PLL的模拟输出连接到同一个信号I&#x2F;O上，减少引脚的占用。</li><li><strong>选择性输出</strong>：如果你需要监控某个特定的PLL，通常情况下，控制输入会将所有PLL的模拟输出置为三态，然后你可以启用特定的PLL来查看。</li><li><strong>控制寄存器</strong>：模拟测试输出的控制通过<code>PLLCR/PLLCR0.ATC</code>和<code>PLLCR/PLLCR0.ATOEN</code>寄存器来实现，这些寄存器允许选择哪一个PLL的模拟输出需要启用。</li></ul><h4 id="数字测试输出（Digital-Test-Output）"><a href="#数字测试输出（Digital-Test-Output）" class="headerlink" title="数字测试输出（Digital Test Output）"></a>数字测试输出（Digital Test Output）</h4><p>除了模拟测试输出，PLL还提供了<strong>两个数字测试输出</strong>。这两个数字测试输出是直接连接到PLL的，可以用来测试和观察PLL的信号。这些信号会通过<strong>数字多路选择器（mux）</strong>选择，允许你选择不同的信号进行监控。</p><ul><li><strong>限制</strong>：这些数字测试输出信号的测试能力有限，因为这些信号经过PHY模块（物理层）的数字逻辑进行选择，再通过数字逻辑传递到I&#x2F;O端口。数字逻辑的传递会引入一些噪声，例如电压与温度（VT）噪声，限制了信号的精度和可测量的抖动范围。另外，由于信号的传递经过一般的逻辑电路，频率限制和占空比的偏差也可能影响测量结果。</li><li><strong>可测量的参数</strong>：尽管数字测试输出有这些限制，它仍然可以提供一些有用的信息：<ul><li>输出频率</li><li>相位误差</li><li>锁定范围</li></ul></li><li><strong>控制寄存器</strong>：数字测试输出的控制由<code>PLLCR/PLLCR0.DTC</code>和<code>PGCR0.DTOSEL</code>寄存器来实现。这些寄存器允许选择要监控的信号和PHY块。</li><li><strong>测试输出信号</strong>：来自AC&#x2F;ACX48和DATX8&#x2F;DATX4X2的数字测试输出信号是<code>pll_dto[1:0]</code>和<code>dl_dto</code>，最终这些信号变成<code>phy_dto[1:0]</code>信号供上层PHY模块进行监控。</li></ul><h4 id="测量输出频率和相位误差"><a href="#测量输出频率和相位误差" class="headerlink" title="测量输出频率和相位误差"></a>测量输出频率和相位误差</h4><ul><li><strong>输出频率</strong>：通过数字测试输出可以直接测量PLL的输出频率，这是一项标准的测试。</li><li><strong>相位误差测量</strong>：为了测量PLL的相位误差，需要同时观察<strong>参考时钟</strong>和<strong>反馈时钟</strong>。你可以通过选择数字测试信号中的一个作为参考时钟输出，另一个作为PLL的输出时钟。这样，你可以测量它们之间的相位差，并计算出PLL的相位误差。</li><li><strong>锁定范围（Lock Range）</strong>：锁定范围的测试方法有两种：<ol><li><strong>输出频率和相位误差稳定时，PLL认为已经锁定</strong>。这是最常见的检查PLL是否正常工作的方法。</li><li><strong>锁定信号（Lock Signal）</strong>：PLL提供了一个锁定信号，可以通过查看<code>PGSR0.APLOCK</code>和<code>DXnGSR0.DPLOCK</code>寄存器来检查PLL是否处于锁定状态。</li></ol></li></ul><h4 id="间接测试方法（Indirect-Test-Method）"><a href="#间接测试方法（Indirect-Test-Method）" class="headerlink" title="间接测试方法（Indirect Test Method）"></a>间接测试方法（Indirect Test Method）</h4><p>除了直接从数字测试输出查看PLL信号，还可以通过测量<strong>主输出引脚</strong>来进行间接测试：</p><ul><li><strong>输出抖动</strong>：通过测量主输出引脚（如<code>CK</code>和<code>DQS</code>）的抖动，来间接评估PLL的性能。注意，这个测量不仅包括PLL的抖动，还包括PHY模块中的输出逻辑的影响，因此抖动值可能比PLL本身的规格更大。</li><li><strong>输出频率</strong>：也可以通过主输出引脚的频率测量来确认PLL的输出频率。</li></ul><h4 id="测试模式和操作"><a href="#测试模式和操作" class="headerlink" title="测试模式和操作"></a>测试模式和操作</h4><ul><li><strong>正常操作模式</strong>：PLL测试在正常操作模式下进行，前提是PLL已经正确配置、复位，并且经过足够时间来进行锁定。</li><li><strong>测试点的选择</strong>：用户可以根据需求选择测试点（即参考时钟频率），这可能是几个关键的工作点，或者如果产品有可变的频率范围，可能需要在多个点进行采样。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>模拟测试输出不是生产测试的一部分</strong>：模拟测试输出仅供调试使用，当怀疑PLL存在问题时，才使用该测试点进行调试。生产测试和质量控制通常不使用模拟测试输出。</li><li><strong>PLL抖动</strong>：测量主输出引脚的抖动时，除了PLL本身的抖动外，还会包括PHY模块的输出逻辑抖动。因此，PLL的输出抖动可能会比预期的更大。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> PUB </tag>
            
            <tag> DDR DFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Read Bit De-skew(2)</title>
      <link href="/2024/11/25/DDR/Data%20Training-Read%20Bit%20De-skew(2)/"/>
      <url>/2024/11/25/DDR/Data%20Training-Read%20Bit%20De-skew(2)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>详细算法步骤<a><span id="more"></span></a></p></blockquote><h2 id="1-初始写入和读取操作"><a href="#1-初始写入和读取操作" class="headerlink" title="1. 初始写入和读取操作"></a>1. <strong>初始写入和读取操作</strong></h2><p>首先，这一部分列出了向SDRAM发出的写入（write）和读取（read）命令的步骤。这些步骤用于测试DDR内存的读写稳定性，特别是在信号延迟（skew）方面。</p><h3 id="a-向-SDRAM-发出以下命令"><a href="#a-向-SDRAM-发出以下命令" class="headerlink" title="a. 向 SDRAM 发出以下命令"></a>a. 向 SDRAM 发出以下命令</h3><h4 id="写入命令（Write-Commands）"><a href="#写入命令（Write-Commands）" class="headerlink" title="写入命令（Write Commands）"></a><strong>写入命令（Write Commands）</strong></h4><p>这部分包含了多个“写突发”命令（write burst），每个命令会将一组数据写入到SDRAM的不同目标寄存器（DTAR，即Data Target Register）。以下是各个写入命令的具体描述：</p><ol><li><strong>Write burst of 8 to DTAR3 with data&#x3D;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00</strong><ul><li>向目标寄存器DTAR3写入8个数据单元（burst of 8），数据内容全为<code>x00</code>。</li></ul></li><li><strong>Write burst of 8 to DTAR0 with data&#x3D;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00</strong><ul><li>向目标寄存器DTAR0写入8个数据单元，数据也是<code>x00</code>。</li></ul></li><li><strong>Write burst of 8 to DTAR3 with data&#x3D;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00</strong><ul><li>再次向DTAR3写入8个数据单元，数据仍然是<code>x00</code>。</li></ul></li><li><strong>Write burst of 8 to DTAR3 with data&#x3D;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55</strong><ul><li>向DTAR3写入8个数据单元，数据改为<code>x55</code>。</li></ul></li><li><strong>Write burst of 8 to DTAR1 with data&#x3D;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55</strong><ul><li>向DTAR1写入8个数据单元，数据是<code>x55</code>。</li></ul></li><li><strong>Write burst of 8 to DTAR3 with data&#x3D;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA</strong><ul><li>向DTAR3写入8个数据单元，数据是<code>x55</code>和<code>xAA</code>交替。</li></ul></li><li><strong>Write burst of 8 to DTAR2 with data&#x3D;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA</strong><ul><li>向DTAR2写入8个数据单元，数据全为<code>xAA</code>。</li></ul></li><li><strong>Write burst of 8 to DTAR3 with data&#x3D;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA</strong><ul><li>再次向DTAR3写入8个数据单元，数据仍为<code>xAA</code>。</li></ul></li><li><strong>No-Operation (optional extended write DQS with DTCR.DTEXD)</strong><ul><li>执行一个不操作（No-Operation），这可能是为了扩展写操作中的DQS信号，用于调节时序。</li></ul></li><li><strong>No-Operation</strong><ul><li>另一个不操作（No-Operation），此步骤可能用于等待或调整时序。</li></ul></li></ol><h4 id="读取命令（Read-Commands）"><a href="#读取命令（Read-Commands）" class="headerlink" title="读取命令（Read Commands）"></a><strong>读取命令（Read Commands）</strong></h4><p>接下来的部分是读取命令（read burst）。这些命令用于读取前面写入的数据，并检查其是否正确。具体步骤如下：</p><ol><li><strong>Read burst of 8 from DTAR0 with expected data&#x3D;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00</strong><ul><li>从DTAR0读取8个数据单元，期望数据是<code>x00</code>。</li></ul></li><li><strong>Read burst of 8 from DTAR1 with expected data&#x3D;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55&#x2F;x55</strong><ul><li>从DTAR1读取8个数据单元，期望数据是<code>x55</code>。</li></ul></li><li><strong>Read burst of 8 from DTAR0 with expected data&#x3D;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00&#x2F;x00</strong><ul><li>再次从DTAR0读取8个数据单元，期望数据仍是<code>x00</code>。</li></ul></li><li><strong>Read burst of 8 from DTAR2 with expected data&#x3D;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA&#x2F;xAA</strong><ul><li>从DTAR2读取8个数据单元，期望数据是<code>xAA</code>。</li></ul></li><li><strong>Repeat read sequence n-times where n&#x3D;DTCR.DTRPTN</strong><ul><li>重复读取过程n次，n的值由DTCR寄存器中的<code>DTRPTN</code>字段指定。</li></ul></li></ol><h3 id="b-评估读取数据（Evaluate-the-read-data）"><a href="#b-评估读取数据（Evaluate-the-read-data）" class="headerlink" title="b. 评估读取数据（Evaluate the read data）"></a>b. <strong>评估读取数据（Evaluate the read data）</strong></h3><p>接下来，对读取的数据进行评估，以判断是否发生了数据偏移（data skew）或者时序错误（timing error）。</p><h4 id="如果读取数据的偏移超过三个数据周期："><a href="#如果读取数据的偏移超过三个数据周期：" class="headerlink" title="如果读取数据的偏移超过三个数据周期："></a><strong>如果读取数据的偏移超过三个数据周期：</strong></h4><ul><li><strong>设置错误标志</strong>：当读取的数据偏移（skew）超过三个数据周期时，会触发一个错误状态，通过设置<code>PGSR0.RDERR=1</code>、<code>DXnGSR2.RDERR=1</code>和<code>DXnGSR2.ESTAT=0000</code>来标记错误。</li><li><strong>标记读取完成</strong>：如果没有偏移错误，设置<code>PGSR0.RDDONE=1</code>，表示读取位对齐（read bit de-skew）已经完成。</li><li><strong>退出数据训练</strong>：数据训练结束，退出后续的步骤。</li></ul><h4 id="如果读取的DQS信号相对于数据太早："><a href="#如果读取的DQS信号相对于数据太早：" class="headerlink" title="如果读取的DQS信号相对于数据太早："></a><strong>如果读取的DQS信号相对于数据太早：</strong></h4><ul><li>如果读取的DQS信号（读取时钟）太早相对于数据，这意味着时序可能有问题（例如时钟提前了），需要调整并进入步骤2</li></ul><h4 id="如果没有读取错误，或者读取的DQS信号相对于数据太晚："><a href="#如果没有读取错误，或者读取的DQS信号相对于数据太晚：" class="headerlink" title="如果没有读取错误，或者读取的DQS信号相对于数据太晚："></a><strong>如果没有读取错误，或者读取的DQS信号相对于数据太晚：</strong></h4><ul><li>如果没有检测到任何读取错误，或者DQS信号晚于数据时，跳过时序调整步骤，直接进入步骤3</li></ul><h2 id="2-DQS-DQS-信号过早"><a href="#2-DQS-DQS-信号过早" class="headerlink" title="2. DQS&#x2F;DQS#信号过早"></a>2. <strong>DQS&#x2F;DQS#信号过早</strong></h2><p>这部分提到，读取时钟信号（DQS&#x2F;DQS#）比数据本身提前了，导致数据无法正确对齐。为了纠正这种情况，需要调整DQS&#x2F;DQS#信号，使它与数据同步。</p><ul><li>调整方法：<ul><li><strong>向后移动DQS&#x2F;DQS#信号</strong>，即将DQS&#x2F;DQS#信号延迟，或者</li><li><strong>提前数据眼（read data eye）</strong>，即提前数据本身，直到不再检测到数据不匹配（mis-compares），或者只在特定的“错误窗口”内（例如<strong>第6、7、22、23个周期</strong>）出现错误。</li></ul></li></ul><h3 id="a-读取命令（Read-commands）"><a href="#a-读取命令（Read-commands）" class="headerlink" title="a. 读取命令（Read commands）"></a>a. <strong>读取命令（Read commands）</strong></h3><p>在调整DQS信号之前，系统执行一系列读取命令。这些读取命令包括从不同的目标寄存器（DTAR0、DTAR1、DTAR2）读取数据并对比预期数据。这些数据预期为：</p><ul><li><strong>读取DTAR0的数据</strong>：期望是<code>x00/x00/x00/x00/x00/x00/x00/x00</code></li><li><strong>读取DTAR1的数据</strong>：期望是<code>x55/x55/x55/x55/x55/x55/x55/x55</code></li><li><strong>再次读取DTAR0的数据</strong>：期望是<code>x00/x00/x00/x00/x00/x00/x00/x00</code></li><li><strong>读取DTAR2的数据</strong>：期望是<code>xAA/xAA/xAA/xAA/xAA/xAA/xAA/xAA</code></li></ul><p><strong>重复读取</strong>：这些读取命令会根据<code>DTCR.DTRPTN</code>寄存器的值重复执行多次。</p><h3 id="b-评估读取数据（Evaluate-the-read-data）-1"><a href="#b-评估读取数据（Evaluate-the-read-data）-1" class="headerlink" title="b. 评估读取数据（Evaluate the read data）"></a>b. <strong>评估读取数据（Evaluate the read data）</strong></h3><p>评估读取数据是否存在错误，如果数据不匹配（mis-compare），系统会采取相应的措施。具体的评估步骤如下：</p><ul><li><strong>如果在8、9或24、25周期内检测到读取不匹配</strong>：<ol><li><strong>读取DQS信号的LCDL（Read DQS Delay）最大值</strong>：<ul><li>如果读取DQS信号的LCDL已在最大值，且任何读取数据（DQ信号）的BDL（Bit Delay）处于最小值，则表示时序已经达到极限，无法进一步减少DQS延迟。因此，系统会：<ul><li><strong>标记错误</strong>：通过设置<code>PGSR0.RDERR=1</code>和<code>DXnGSR2.RDERR=1</code>来标识错误，并将<code>DXnGSR2.ESTAT</code>设置为<code>0001</code>。</li><li><strong>设置标志</strong>：<code>PGSR0.RDDONE=1</code>，表示读取位去偏（read bit de-skew）已完成。</li><li><strong>退出数据训练</strong>：结束当前的时序调整过程。</li></ul></li></ul></li><li><strong>如果读取DQS的LCDL仍在最大值</strong>，则：<ul><li><strong>减少所有读取数据（DQ）的BDL值</strong>，即减少数据的延迟，尝试通过调整数据时序来修正错误。</li><li>然后重复步骤2</li></ul></li><li><strong>如果读取DQS的LCDL值未达到最大</strong>，则：<ul><li><strong>增加DQS&#x2F;DQS#的LCDL值</strong>，即延迟DQS&#x2F;DQS#信号，以进一步调整时序。</li><li>然后重复步骤2</li></ul></li></ol></li><li><strong>如果没有读取不匹配（mis-compares）</strong>，则可以继续进行下一步操作，跳过当前的时序调整过程，进入后续步骤3。</li></ul><h2 id="3-找到读取数据眼的左边缘"><a href="#3-找到读取数据眼的左边缘" class="headerlink" title="3. 找到读取数据眼的左边缘"></a>3. <strong>找到读取数据眼的左边缘</strong></h2><ul><li>在此过程中，系统需要找到<strong>读取数据眼的左边缘</strong>，即<strong>数据眼开始的最早时刻</strong>，直到在<strong>第8个和第24个周期内</strong>检测到一个或多个比特（bit）失败。</li></ul><h3 id="a-执行读取命令"><a href="#a-执行读取命令" class="headerlink" title="a. 执行读取命令"></a>a. <strong>执行读取命令</strong></h3><p>这里列出了具体的读取命令。这些命令将从不同的目标地址寄存器（DTAR0、DTAR1、DTAR2）读取数据，并且每次读取的数据与预期值进行对比。预期数据分别是：</p><ul><li><strong>DTAR0</strong>：期望数据为 <code>x00/x00/x00/x00/x00/x00/x00/x00</code></li><li><strong>DTAR1</strong>：期望数据为 <code>x55/x55/x55/x55/x55/x55/x55/x55</code></li><li><strong>DTAR0</strong>：期望数据为 <code>x00/x00/x00/x00/x00/x00/x00/x00</code></li><li><strong>DTAR2</strong>：期望数据为 <code>xAA/xAA/xAA/xAA/xAA/xAA/xAA/xAA</code></li></ul><p>这些命令会根据 <code>DTCR.DTRPTN</code>（数据训练计数器）指定的重复次数进行多次执行。</p><h3 id="b-评估读取数据"><a href="#b-评估读取数据" class="headerlink" title="b. 评估读取数据"></a>b. <strong>评估读取数据</strong></h3><p>在读取数据之后，系统将评估是否有数据不匹配（mis-compare），特别是在<strong>第8个周期和第24个周期</strong>。如果检测到比特错误，系统会根据以下步骤进行处理：</p><ul><li><p><strong>如果第8周期和第24周期的读取数据发生了不匹配（mis-compare）</strong>，系统需要：</p><ul><li><strong>存储读取DQS&#x2F;DQS#的LCDL值</strong>，即存储当前读取时钟的延迟值。这个值表示DQS信号相对于数据的时序偏差。</li><li><strong>存储所有读取DQ（数据位）的BDL增量</strong>，即记录每个数据位的延迟值的增量（位延迟）。这些值存储在寄存器 <code>DTEDR1.DTRLMN</code> 和 <code>DTEDR2.DTRLMN</code> 中。</li></ul><p>接下来，系统将进入步骤4。</p></li><li><p><strong>如果没有检测到不匹配（mis-compare）</strong>，即读取数据正常，系统会继续检查并调整时序：</p><ol><li>如果读取DQS&#x2F;DQS#信号的LCDL值已经是最小值（即DQS信号无法再提前），并且任何读取DQ信号的BDL值已经是最大值（即数据位已经延迟到最大），则认为时序已经无法进一步优化，系统会：<ul><li><strong>标记错误</strong>：通过设置 <code>PGSR0.RDERR=1</code> 和 <code>DXnGSR2.RDERR=1</code> 来标识错误，并将 <code>DXnGSR2.ESTAT</code> 设置为 <code>0010</code>，表明错误的类型是时序错误。</li><li><strong>设置完成标志</strong>：<code>PGSR0.RDDONE=1</code>，表示读取位去偏（read bit de-skew）已经完成。</li><li><strong>退出数据训练</strong>：结束当前data training</li></ul></li><li>如果读取DQS&#x2F;DQS#的LCDL值仍在最小值，但其他条件符合，系统将：<ul><li><strong>增加所有读取DQ信号的BDL值</strong>（即将数据延迟调整增大）。</li><li>然后重新执行步骤3，继续评估数据。</li></ul></li><li>如果DQS信号的LCDL值未达到最小值，则可以通过：<ul><li><strong>减少DQS&#x2F;DQS#信号的LCDL值</strong>（即进一步延迟DQS信号）。</li><li>然后重复执行步骤3，再次评估数据。</li></ul></li></ol></li></ul><h2 id="4-去除所有读取DQ位的时序偏差"><a href="#4-去除所有读取DQ位的时序偏差" class="headerlink" title="4. 去除所有读取DQ位的时序偏差"></a>4. <strong>去除所有读取DQ位的时序偏差</strong></h2><h3 id="a-执行读取命令-1"><a href="#a-执行读取命令-1" class="headerlink" title="a. 执行读取命令"></a>a. <strong>执行读取命令</strong></h3><ul><li>如同前面的步骤，这里依然需要执行一系列的读取命令，通过从不同的目标地址寄存器（DTAR0、DTAR1、DTAR2）进行读取。</li><li>这些读取操作会验证数据是否符合预期，确保没有时序错误发生。</li></ul><p><strong>读取命令</strong>如下：</p><ul><li>从<strong>DTAR0</strong>读取，预期数据是 <code>x00/x00/x00/x00/x00/x00/x00/x00</code></li><li>从<strong>DTAR1</strong>读取，预期数据是 <code>x55/x55/x55/x55/x55/x55/x55/x55</code></li><li>从<strong>DTAR0</strong>读取，预期数据是 <code>x00/x00/x00/x00/x00/x00/x00/x00</code></li><li>从<strong>DTAR2</strong>读取，预期数据是 <code>xAA/xAA/xAA/xAA/xAA/xAA/xAA/xAA</code></li></ul><p>每个读取操作会根据 <code>DTCR.DTRPTN</code> 设定的重复次数（n-times）执行多次。</p><h3 id="b-评估读取数据-1"><a href="#b-评估读取数据-1" class="headerlink" title="b. 评估读取数据"></a>b. <strong>评估读取数据</strong></h3><p>执行完这些读取命令后，接下来对读取的数据进行评估。</p><ul><li><strong>如果检测到所有读取DQ位在第8个周期和第24个周期内发生不匹配（mis-compare）</strong>，系统将继续执行<strong>步骤5</strong>，进入下一阶段的处理。</li><li><strong>否则，如果检测到任何读取DQ的BDL（位延迟）已达到最大值</strong>，这意味着某些数据位已经调整到最大延迟，无法再进行进一步调整，系统会：<ul><li><strong>标记一个警告</strong>：通过设置 <code>DXnGSR2.RDWN=1</code> 来标记警告状态。</li><li>然后继续执行<strong>步骤5</strong>，即进入下一阶段。</li></ul></li><li><strong>否则，如果没有不匹配</strong>，并且没有达到最大BDL值，系统将继续执行调整操作：<ul><li>对于每一个读取的DQ位，如果在所有的读取中，第8周期和第24周期没有发生不匹配，则将：<ul><li><strong>增加该DQ位的BDL值</strong>。这意味着系统会延迟这些数据位的时序，以使它们与其他位对齐。</li></ul></li></ul></li></ul><h2 id="5-对齐RDBI（读取数据总线反转）"><a href="#5-对齐RDBI（读取数据总线反转）" class="headerlink" title="5. 对齐RDBI（读取数据总线反转）"></a><strong>5. 对齐RDBI（读取数据总线反转）</strong></h2><h3 id="a-启用读取DBI功能"><a href="#a-启用读取DBI功能" class="headerlink" title="a. 启用读取DBI功能"></a>a. 启用读取DBI功能</h3><p>首先，需要在<strong>SDRAM</strong>中启用DBI（Data Bus Inversion）功能。通过将控制寄存器<code>MR5</code>的第12位（bit 12）设置为1来启用该功能。这一步骤将允许SDRAM在读取数据时应用DBI。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable read DBI functionality at the SDRAM by writing “1” to MR5 bit 12.</span><br></pre></td></tr></table></figure><h3 id="b-发出读取命令"><a href="#b-发出读取命令" class="headerlink" title="b. 发出读取命令"></a>b. <strong>发出读取命令</strong></h3><p>接下来，发出一系列的读取命令，以便测试和调整RDBI的位置。这些命令的目的是检查数据总线反转（DBI）的效果，并确定它是否与数据总线（DQ）上的数据位对齐。</p><p>每个命令中包含了<strong>数据掩码（dm）</strong>，这决定了哪些数据位需要反转。</p><h4 id="第一个读取命令："><a href="#第一个读取命令：" class="headerlink" title="第一个读取命令："></a>第一个读取命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read burst of 8 from DTAR0 with expected data=xXX/x00/x00/x00/x00/x00/x00/x00 (post-DBI) / x55/xFF/xFF/xFF/xFF/xFF/xFF/xFF, dm=0x1/0x0/0x0/0x0/0x0/0x0/0x0/0x0</span><br></pre></td></tr></table></figure><ul><li><strong>DTAR0</strong>：表示从地址<code>DTAR0</code>开始读取数据。</li><li>**xXX&#x2F;x00&#x2F;x00&#x2F;…**：期望的初始数据。<code>xXX</code>表示需要反转的部分，其他<code>x00</code>表示没有反转的数据。</li><li>**x55&#x2F;xFF&#x2F;xFF&#x2F;…**：这些是反转后期望的结果。<code>x55</code>表示数据反转后的值，<code>xFF</code>表示RDBI引起的反转数据。</li><li>**dm&#x3D;0x1&#x2F;0x0&#x2F;…**：数据掩码，<code>0x1</code>表示第一个数据位需要反转，而后续的<code>0x0</code>表示没有反转。</li></ul><h4 id="第二个读取命令："><a href="#第二个读取命令：" class="headerlink" title="第二个读取命令："></a>第二个读取命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read burst of 8 from DTAR2 with expected data=x00/xAA/xAA/xAA/xAA/xAA/xAA/xAA (post-DBI) / xFF/xAA/xAA/xAA/xAA/xAA/xAA/xAA, dm=0x0/0x1/0x1/0x1/0x1/0x1/0x1/0x1</span><br></pre></td></tr></table></figure><ul><li><strong>DTAR2</strong>：从地址<code>DTAR2</code>读取。</li><li><strong>期望数据</strong>：这里的数据模式与第一个命令不同。<code>x00/xAA/...</code>表示后面的数据位发生反转。</li><li>**dm&#x3D;0x0&#x2F;0x1&#x2F;…**：数据掩码指示从第二位开始反转。</li></ul><h4 id="第三个读取命令："><a href="#第三个读取命令：" class="headerlink" title="第三个读取命令："></a>第三个读取命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read burst of 8 from DTAR0 with expected data=xAA/x00/x00/x00/x00/x00/x00/x00 (post-DBI) / xAA/xFF/xFF/xFF/xFF/xFF/xFF/xFF, dm=0x1/0x0/0x0/0x0/0x0/0x0/0x0/0x0</span><br></pre></td></tr></table></figure><ul><li><strong>DTAR0</strong>：再次从<code>DTAR0</code>地址读取数据。</li><li><strong>期望数据</strong>：数据反转后的结果。<code>xAA/xFF/xFF/...</code>表示所有数据位在RDBI作用下反转。</li></ul><h4 id="第四个读取命令："><a href="#第四个读取命令：" class="headerlink" title="第四个读取命令："></a>第四个读取命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read burst of 8 from DTAR1 with expected data=x00/x55/x55/x55/x55/x55/x55/x55 (post-DBI) / xFF/x55/x55/x55/x55/x55/x55/x55, dm=0x0/0x1/0x1/0x1/0x1/0x1/0x1/0x1</span><br></pre></td></tr></table></figure><ul><li><strong>DTAR1</strong>：从地址<code>DTAR1</code>读取。</li><li><strong>期望数据</strong>：这里也有反转的部分，如<code>x00/x55/...</code>表示部分数据进行反转。</li><li>**dm&#x3D;0x0&#x2F;0x1&#x2F;…**：表示从第二个数据位开始反转。</li></ul><h3 id="3-重复读取命令"><a href="#3-重复读取命令" class="headerlink" title="3. 重复读取命令"></a>3. <strong>重复读取命令</strong></h3><ul><li>命令将根据<code>DTCR.DTRPTN</code>寄存器的值重复执行这些读取命令。这些命令会被执行<code>n</code>次，以便验证RDBI的稳定性和一致性。</li></ul><h3 id="4-评估读取数据"><a href="#4-评估读取数据" class="headerlink" title="4. 评估读取数据"></a>4. <strong>评估读取数据</strong></h3><p>在执行完这些读取命令后，评估返回的数据，并根据以下情况判断RDBI的对齐位置：</p><h4 id="情况-1：dm-0在第8个周期和第24个周期"><a href="#情况-1：dm-0在第8个周期和第24个周期" class="headerlink" title="情况 1：dm=0在第8个周期和第24个周期"></a>情况 1：<code>dm=0</code>在第8个周期和第24个周期</h4><ul><li>如果在周期8和24的<code>dm</code>值都为<code>0</code>，那么RDBI要么与数据总线（DQ）完全对齐，或者它相对于DQ稍晚。</li><li><strong>操作</strong>：将追踪方向设置为<code>1</code>，并继续执行步骤6。</li></ul><h4 id="情况-2：dm-1在第8个周期和第24个周期"><a href="#情况-2：dm-1在第8个周期和第24个周期" class="headerlink" title="情况 2：dm=1在第8个周期和第24个周期"></a>情况 2：<code>dm=1</code>在第8个周期和第24个周期</h4><ul><li>如果在周期8和24的<code>dm</code>值都为<code>1</code>，那么RDBI要么与数据总线对齐，要么在数据总线之前。</li><li><strong>操作</strong>：将追踪方向设置为<code>0</code>，并继续执行步骤6。</li></ul><h4 id="情况-3：dm在两次周期中不同"><a href="#情况-3：dm在两次周期中不同" class="headerlink" title="情况 3：dm在两次周期中不同"></a>情况 3：<code>dm</code>在两次周期中不同</h4><ul><li>如果在周期8和24中<code>dm</code>的值不同，则表示RDBI与数据总线对齐，即它与所有的DQ位对齐。</li><li><strong>操作</strong>：继续执行步骤7。</li></ul><h2 id="6-对齐RDBI（读数据总线反转）位"><a href="#6-对齐RDBI（读数据总线反转）位" class="headerlink" title="6. 对齐RDBI（读数据总线反转）位"></a>6. 对齐RDBI（读数据总线反转）位</h2><h3 id="a-发出读取命令"><a href="#a-发出读取命令" class="headerlink" title="a. 发出读取命令"></a><strong>a. 发出读取命令</strong></h3><p>首先，需要发出一系列读取命令来测试RDBI位的对齐性。这些命令是从<strong>SDRAM</strong>中发出的，分别从不同的<strong>DTAR</strong>（数据传输地址寄存器）地址读取数据：</p><h4 id="1-DTAR0地址的读取命令："><a href="#1-DTAR0地址的读取命令：" class="headerlink" title="1. DTAR0地址的读取命令："></a>1. <strong>DTAR0地址的读取命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read burst of 8 from DTAR0 with expected data=xXX/x00/x00/x00/x00/x00/x00/x00 (post-DBI) / x55/xFF/xFF/xFF/xFF/xFF/xFF/xFF, dm=0x1/0x0/0x0/0x0/0x0/0x0/0x0/0x0 (on the bus).</span><br></pre></td></tr></table></figure><ul><li><strong>DTAR0</strong>：数据传输地址寄存器0。</li><li><strong>期望数据</strong>：<code>xXX/x00/x00/...</code>表示原始数据，<code>x55/xFF/xFF/...</code>表示反转后的数据。数据的反转是通过RDBI控制的。</li><li><strong>dm</strong>：数据掩码，表示哪些数据位需要反转。在这个例子中，<code>dm=0x1</code>表示第一位需要反转，其他位不反转。</li></ul><h4 id="2-DTAR2地址的读取命令："><a href="#2-DTAR2地址的读取命令：" class="headerlink" title="2. DTAR2地址的读取命令："></a>2. <strong>DTAR2地址的读取命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read burst of 8 from DTAR2 with expected data=x00/xAA/xAA/xAA/xAA/xAA/xAA/xAA (post-DBI) / xFF/xAA/xAA/xAA/xAA/xAA/xAA/xAA, dm=0x0/0x1/0x1/0x1/0x1/0x1/0x1/0x1 (on the bus).</span><br></pre></td></tr></table></figure><ul><li><strong>DTAR2</strong>：从地址DTAR2读取数据。</li><li><strong>期望数据</strong>：<code>x00/xAA/...</code>表示数据中有部分位将进行反转。</li><li><strong>dm</strong>：数据掩码指示哪些位需要反转，依次从第二位开始反转。</li></ul><h4 id="3-DTAR0的另一次读取命令："><a href="#3-DTAR0的另一次读取命令：" class="headerlink" title="3. DTAR0的另一次读取命令："></a>3. <strong>DTAR0的另一次读取命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read burst of 8 from DTAR0 with expected data=xAA/x00/x00/x00/x00/x00/x00/x00 (post-DBI) / xAA/xFF/xFF/xFF/xFF/xFF/xFF/xFF, dm=0x1/0x0/0x0/0x0/0x0/0x0/0x0/0x0 (on the bus).</span><br></pre></td></tr></table></figure><ul><li><strong>DTAR0</strong>：再次从DTAR0读取数据。</li><li><strong>期望数据</strong>：数据的反转方式与前一次不同。</li></ul><h4 id="4-DTAR1地址的读取命令："><a href="#4-DTAR1地址的读取命令：" class="headerlink" title="4. DTAR1地址的读取命令："></a>4. <strong>DTAR1地址的读取命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read burst of 8 from DTAR1 with expected data=x00/x55/x55/x55/x55/x55/x55/x55 (post-DBI) / xFF/x55/x55/x55/x55/x55/x55/x55, dm=0x0/0x1/0x1/0x1/0x1/0x1/0x1/0x1 (on the bus).</span><br></pre></td></tr></table></figure><ul><li><strong>DTAR1</strong>：从DTAR1读取数据。</li><li><strong>期望数据</strong>：数据有一些位进行反转。</li></ul><h4 id="5-重复读取命令："><a href="#5-重复读取命令：" class="headerlink" title="5. 重复读取命令："></a>5. <strong>重复读取命令：</strong></h4><ul><li><strong>重复命令</strong>：将这些读取命令重复执行<code>n</code>次，<code>n</code>的值由<code>DTCR.DTRPTN</code>寄存器指定，确保多次验证RDBI的对齐情况。</li></ul><h3 id="b-评估读取数据-2"><a href="#b-评估读取数据-2" class="headerlink" title="b. 评估读取数据"></a><strong>b. 评估读取数据</strong></h3><p>接下来，评估从SDRAM读取的数据，并根据<strong>追踪方向</strong>来确定RDBI的对齐位置。</p><h4 id="追踪方向为0（RDBI在所有DQ位之后）："><a href="#追踪方向为0（RDBI在所有DQ位之后）：" class="headerlink" title="追踪方向为0（RDBI在所有DQ位之后）："></a><strong>追踪方向为0（RDBI在所有DQ位之后）：</strong></h4><ol><li><p><strong>dm捕获值为0，在第8个和第24个周期</strong>：</p><ul><li><p>如果RDBI的BDL（比特延迟线，Bit Delay Line）值在最小值时，并且任何DQ或DQS的BDL在最大值时，表示可能存在问题：</p><ul><li><strong>设置警告条件</strong>：通过设置<code>DXnGSR2.RDWN=1</code>来发出警告。</li><li><strong>继续步骤7</strong>。</li></ul></li><li><p>如果RDBI的<strong>BDL</strong>值在最小值时，<strong>增大</strong>所有DQ和DQS的BDL值。</p></li><li><p>如果上述条件都不满足，<strong>减少</strong>RDBI的BDL值。</p></li></ul></li><li><p><strong>重复步骤1</strong>直到在DTAR0读取命令的第一次周期中<code>dm=1</code>。</p></li></ol><h4 id="追踪方向为1（RDBI在所有DQ位之前）："><a href="#追踪方向为1（RDBI在所有DQ位之前）：" class="headerlink" title="追踪方向为1（RDBI在所有DQ位之前）："></a><strong>追踪方向为1（RDBI在所有DQ位之前）：</strong></h4><ol><li><p><strong>dm捕获值为1，在第8个和第24个周期</strong>：</p><ul><li><p>如果RDBI的BDL值在最大值时，并且任何DQ或DQS的BDL在最小值时，表示可能存在问题：</p><ul><li><strong>设置警告条件</strong>：通过设置<code>DXnGSR2.RDWN=1</code>来发出警告。</li></ul></li></ul></li></ol><ul><li><p><strong>继续步骤6</strong>。</p></li><li><p>如果RDBI的<strong>BDL</strong>值在最大值时，<strong>减小</strong>所有DQ和DQS的BDL值。</p><ul><li>如果上述条件都不满足，<strong>增大</strong>RDBI的BDL值。</li></ul></li></ul><ol start="2"><li><strong>重复步骤1</strong>直到在DTAR0读取命令的第一次周期中<code>dm=0</code>。</li></ol><h3 id="c-禁用RDBI功能"><a href="#c-禁用RDBI功能" class="headerlink" title="c. 禁用RDBI功能"></a><strong>c. 禁用RDBI功能</strong></h3><p>在完成RDBI对齐的调整之后，最后一步是<strong>禁用RDBI功能</strong>，通过将<code>MR5</code>寄存器的第12位写为<code>0</code>来禁用RDBI。</p><h2 id="7-去除延时"><a href="#7-去除延时" class="headerlink" title="7. 去除延时"></a>7. 去除延时</h2><h3 id="恢复RDQS-RDQS-位置："><a href="#恢复RDQS-RDQS-位置：" class="headerlink" title="恢复RDQS&#x2F;RDQS#位置："></a><strong>恢复RDQS&#x2F;RDQS#位置</strong>：</h3><ul><li>这一步是为了确保读选通信号与数据总线的正确对齐，将其移回到最初通过步骤1或步骤2找到的合适位置。</li></ul><h3 id="去除BDL延迟："><a href="#去除BDL延迟：" class="headerlink" title="去除BDL延迟："></a><strong>去除BDL延迟</strong>：</h3><ul><li>步骤3中可能添加的任何延迟都应该被清除，恢复到正常的信号传输延迟。</li></ul><h3 id="进入步骤8"><a href="#进入步骤8" class="headerlink" title="进入步骤8"></a>进入步骤8</h3><h2 id="8-找到适当的时序点（右边缘）"><a href="#8-找到适当的时序点（右边缘）" class="headerlink" title="8. 找到适当的时序点（右边缘）"></a>8. 找到适当的时序点（右边缘）</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>目的是在<strong>读取数据时序</strong>中找到适当的时序点（右边缘），并进行调整，直到在特定的读取周期（周期8和周期24）中发现一个或多个比特错误（bit failures）。</p><h3 id="a-发出读取命令-1"><a href="#a-发出读取命令-1" class="headerlink" title="a. 发出读取命令"></a><strong>a. 发出读取命令</strong></h3><p>你将从SDRAM发出一系列读取命令，以触发和评估读数据的时序。</p><h4 id="命令列表："><a href="#命令列表：" class="headerlink" title="命令列表："></a><strong>命令列表</strong>：</h4><ol><li>读取从<strong>DTAR0</strong>的8个数据位，期望的数据是<code>x00/x00/x00/x00/x00/x00/x00/x00</code>。</li><li>接着读取从<strong>DTAR1</strong>的8个数据位，期望的数据是<code>x55/x55/x55/x55/x55/x55/x55/x55</code>。</li><li>再次读取从<strong>DTAR0</strong>的8个数据位，期望的数据为<code>x00/x00/x00/x00/x00/x00/x00/x00</code>。</li><li>读取从<strong>DTAR2</strong>的8个数据位，期望的数据为<code>xAA/xAA/xAA/xAA/xAA/xAA/xAA/xAA</code>。</li><li><strong>重复读取序列</strong><br>根据<code>DTCR.DTRPTN</code>的值重复执行上述步骤<code>n</code>次，这样可以确保多次验证数据在不同读取周期下的表现。</li></ol><h3 id="b-评估读取数据-3"><a href="#b-评估读取数据-3" class="headerlink" title="b. 评估读取数据"></a><strong>b. 评估读取数据</strong></h3><p>完成读取命令后，你需要评估数据的正确性，并采取相应的操作：</p><h4 id="1-如果DTCR-DTBDC-0"><a href="#1-如果DTCR-DTBDC-0" class="headerlink" title="1. 如果DTCR.DTBDC = 0"></a><strong>1. 如果<code>DTCR.DTBDC = 0</code></strong></h4><ul><li>如果<strong>数据位检测控制</strong>（DTBDC）为0，表示没有检测到错误或比特失配（mis-compare），则<strong>直接进入步骤7</strong>，即继续执行后续操作。</li></ul><h4 id="2-如果检测到比特错误"><a href="#2-如果检测到比特错误" class="headerlink" title="2. 如果检测到比特错误"></a><strong>2. 如果检测到比特错误</strong></h4><ul><li><p>如果在<strong>周期4-11</strong>和<strong>周期20-27</strong>的读取中，存在任何比特错误（mis-compare），则会采取以下措施：</p><p>a. <strong>存储右边缘位置</strong></p><ul><li><strong>存储DQS&#x2F;DQS# LCDL值</strong>：将<strong>DQS&#x2F;DQS#信号的LCDL（读时钟延迟）值</strong>存储在<code>DTEDR1.DTRBMX</code>和<code>DTEDR2.DTRLMX</code>寄存器中，表示检测到的时序位置。</li><li><strong>存储增量值</strong>：将所有读取数据位（DQ）的<strong>BDL增量值</strong>存储在<code>DTEDR1.DTRNMX</code>和<code>DTEDR2.DTRNMX</code>寄存器中。</li></ul><p>b. <strong>进入步骤7</strong></p></li></ul><h4 id="3-否则，进行时序调整"><a href="#3-否则，进行时序调整" class="headerlink" title="3. 否则，进行时序调整"></a><strong>3. 否则，进行时序调整</strong></h4><p>如果没有检测到比特错误，则需要检查并调整时序：</p><ul><li><strong>如果<code>read DQS/DQS# LCDL</code>在最大值，且任何读取DQ的BDL在最小值</strong>：<ul><li>标记错误条件：如果DQS&#x2F;DQS#信号的LCDL在最大值时，且任何数据位DQ的BDL在最小值时，表示时序错误，需要标记错误条件：<ul><li>通过设置<code>PGSR0.RDERR=1&#39;b1</code>和<code>DXnGSR2.RDERR=1&#39;b1</code>标记读取错误。</li><li>通过设置<code>DXnGSR2.ESTAT=4&#39;b0101</code>设置错误状态。</li></ul></li><li><strong>设置读取完成标志</strong>：设置<code>PGSR0.RDDONE=1&#39;b1</code>，表示读数据去偏移（bit de-skew）已经完成。</li><li><strong>退出数据训练</strong>：由于时序错误，退出训练过程。</li></ul></li><li><strong>如果<code>read DQS/DQS# LCDL</code>不在最大值</strong>：<ul><li>调整时序：<ul><li>如果**<code>read DQS/DQS# LCDL</code>在最大值<strong>，则需要将所有</strong>读取数据位的BDL值**递减（即减少延迟），以调整时序。</li><li>如果**<code>read DQS/DQS# LCDL</code>不在最大值<strong>，则需要</strong>递增&#96;read DQS&#x2F;DQS# LCDL的值**，即增加时序延迟。</li></ul></li><li><strong>重复步骤6</strong>：完成时序调整后，重新进行步骤6以再次评估数据并进行调整，直到时序正确。</li></ul></li></ul><h2 id="9-找到数据眼的中心位"><a href="#9-找到数据眼的中心位" class="headerlink" title="9. 找到数据眼的中心位"></a>9. 找到数据眼的中心位</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>目的是通过计算<strong>读数据时钟（RDQS）</strong>的理想位置，使得数据眼的中心位于最佳的时序位置，从而保证读数据的时序对齐。该过程的关键是计算中心位置并调整读数据时钟（DQS&#x2F;DQS#）的位置。</p><h3 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a><strong>步骤解析</strong></h3><ol><li><p><strong>条件检查：<code>DTCR.DTBDC=0</code></strong></p><ul><li>如果DTCR.DTBDC的值为0，表示数据位检测控制（Data Bit Detection Control）没有启用，或者当前没有比特错误需要处理。在这种情况下：<ul><li>直接<strong>进入步骤8</strong>，跳过进一步的时序调整。</li></ul></li></ul></li><li><p><strong>计算DQS&#x2F;DQS#中心位置：</strong></p><ul><li>如果**<code>DTCR.DTBDC≠0</code><strong>（即启用了数据位检测控制，并且需要调整时序），则需要根据左边缘（Step 3）和右边缘（Step 6）的位置来计算理想的</strong>DQS&#x2F;DQS#的中心位置**。计算公式如下：</li></ul><p>$$<br>\text { RDQS center position }&#x3D;(D T R L M X+D T R B M X)+\frac{(D T R L M N-D T R B M N)}{2}<br>$$</p><p>这里涉及到4个寄存器的值：</p><ul><li><strong>DTRLMX</strong>：左边缘的最大位置（来自Step 6的计算结果）。</li><li><strong>DTRBMX</strong>：右边缘的最大位置（来自Step 3的计算结果）。</li><li><strong>DTRLMN</strong>：左边缘的最小位置（Step 3计算结果的一部分）。</li><li><strong>DTRBMN</strong>：右边缘的最小位置（Step 6计算结果的一部分）。</li></ul><p>通过计算公式，你可以得到<strong>DQS&#x2F;DQS#的理想位置</strong>，即数据眼的中心位置。</p></li><li><p><strong>调整DQS&#x2F;DQS#位置：</strong></p><ul><li>将计算得到的中心位置应用到读时钟：<ul><li>将**DQS&#x2F;DQS#**时钟信号移动到上面计算的理想中心位置。</li><li><strong>去除任何在Step 6中应用的BDL延迟</strong>，确保所有的数据位延迟（BDL）和时钟信号都调整到正确的中心位置。</li></ul></li></ul></li><li><p><strong>进入步骤8：</strong></p><ul><li>在完成DQS&#x2F;DQS#位置的调整后，继续执行<strong>步骤8</strong></li></ul></li></ol><h2 id="10-验证读操作是否能够正确进行"><a href="#10-验证读操作是否能够正确进行" class="headerlink" title="10. 验证读操作是否能够正确进行"></a>10. 验证读操作是否能够正确进行</h2><h4 id="a-发起一系列的读操作"><a href="#a-发起一系列的读操作" class="headerlink" title="a. 发起一系列的读操作"></a><strong>a. 发起一系列的读操作</strong></h4><p>首先，发起一系列的读取命令，从SDRAM中读取数据，并确认预期数据：</p><ul><li><strong>读取8个数据字节</strong>：<ul><li>从 <strong>DTAR0</strong> 开始读取，预期数据为：<code>x00/x00/x00/x00/x00/x00/x00/x00</code>。</li><li>从 <strong>DTAR1</strong> 读取，预期数据为：<code>x55/x55/x55/x55/x55/x55/x55/x55</code>。</li><li>再次从 <strong>DTAR0</strong> 读取，预期数据为：<code>x00/x00/x00/x00/x00/x00/x00/x00</code>。</li><li>从 <strong>DTAR2</strong> 读取，预期数据为：<code>xAA/xAA/xAA/xAA/xAA/xAA/xAA/xAA</code>。</li></ul></li><li><strong>重复此读操作</strong>，根据 <strong>DTCR.DTRPTN</strong> 设置的次数来执行。这意味着你会根据配置，重复上述操作多个周期，以确保数据稳定性。</li></ul><h4 id="b-评估读取的数据"><a href="#b-评估读取的数据" class="headerlink" title="b. 评估读取的数据"></a><strong>b. 评估读取的数据</strong></h4><p>读取操作之后，需要对读取的数据进行评估，以确定是否有时序错误（即数据是否准确，是否发生了比对错误）：</p><ul><li><strong>检测读取错误</strong>：<ul><li>如果在beats 4到11之间或20到27之间出现数据比对错误（mis-compare），这意味着在这些数据时隙内的读取结果与预期不匹配，可能是由于时序偏移或其他原因导致的错误。此时：<ul><li>标记错误条件：通过设置以下寄存器标志来标记错误：<ul><li><strong>PGSR0.RDERR</strong> 设置为 <code>1&#39;b1</code>，表示读取发生错误。</li><li><strong>DXnGSR2.RDERR</strong> 设置为 <code>1&#39;b1</code>，表示对应通道的读取错误。</li><li><strong>DXnGSR2.ESTAT</strong> 设置为 <code>4&#39;b0111</code>，表示错误的状态码，指示发生了读取比对错误。</li></ul></li><li><strong>标记数据训练完成</strong>：设置 <strong>PGSR0.RDDONE</strong> 为 <code>1&#39;b1</code>，表示数据位去偏移（de-skew）已经完成。</li><li><strong>退出数据训练</strong>：由于发生了错误，训练过程需要结束，退出数据训练流程。</li></ul></li></ul></li><li><strong>没有检测到比对错误</strong>：<ul><li>如果在读取的过程中没有检测到比对错误，则：<ul><li>仅设置 <strong>PGSR0.RDDONE</strong> 为 <code>1&#39;b1</code>，表示数据位去偏移（de-skew）已经完成，且没有发现错误。</li><li>此时可以<strong>继续进入后续步骤</strong>，因为数据读取已经正常。</li></ul></li></ul></li></ul><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><p><strong>最小读DQS&#x2F;DQS# LCDL延迟（x00）</strong></p><p><strong>最大读DQS&#x2F;DQS# LCDL延迟（x1FF）</strong></p><p><strong>最小读DQ BDL延迟（x00）</strong></p><p><strong>最大读DQ BDL延迟（x3F）</strong></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR科普-SSO噪声</title>
      <link href="/2024/11/25/DDR/DDR%E7%A7%91%E6%99%AE-SSO%E5%99%AA%E5%A3%B0/"/>
      <url>/2024/11/25/DDR/DDR%E7%A7%91%E6%99%AE-SSO%E5%99%AA%E5%A3%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>SSO</strong>（Simultaneous Switching Output）噪声，是指在数字电路中，多个信号（通常是输出信号）在同一时刻发生状态转换时，产生的电气干扰或噪声。它是由多个信号同时切换引起的瞬时电流波动，尤其是在高速时钟和数据系统中，SSO噪声可能对系统的稳定性和时序产生不利影响。<a><span id="more"></span></a></p></blockquote><h3 id="1-电流突变"><a href="#1-电流突变" class="headerlink" title="1. 电流突变"></a>1. <strong>电流突变</strong></h3><p>当多个信号（例如数据线）在同一时刻从一个逻辑状态（比如低电平）切换到另一个状态（比如高电平）时，它们会瞬间吸引电流。这个电流是由芯片内部的驱动电路提供的，在短时间内多个信号的转换会导致电流的剧烈波动。这些电流波动会传导到电源系统或其他电路中，造成噪声。</p><h3 id="2-电源和地线的反应"><a href="#2-电源和地线的反应" class="headerlink" title="2. 电源和地线的反应"></a>2. <strong>电源和地线的反应</strong></h3><p>当多个信号同时切换时，电流波动会引发电源和地线的电压波动。这些波动会影响整个电路的稳定性，特别是在电源供电质量较差或电源&#x2F;地线布局不合理时，可能导致系统无法维持预期的电压水平，进而引发时序问题或数据错误。</p><h3 id="3-跨谈干扰-Crosstalk"><a href="#3-跨谈干扰-Crosstalk" class="headerlink" title="3. 跨谈干扰 (Crosstalk)"></a>3. <strong>跨谈干扰 (Crosstalk)</strong></h3><p>同一时刻切换的信号可能会通过电路的互连线产生干扰（跨谈干扰），这种干扰会导致相邻信号之间的误解码或误触发。尤其在高速信号传输中，信号的相互干扰更加明显。SSO噪声是跨谈干扰的一个重要原因。</p><h3 id="4-电磁干扰-EMI"><a href="#4-电磁干扰-EMI" class="headerlink" title="4. 电磁干扰 (EMI)"></a>4. <strong>电磁干扰 (EMI)</strong></h3><p>SSO产生的快速电流变化，尤其是在高频操作中，会辐射到周围的电磁场中，进而影响其他敏感电路。电磁干扰不仅会影响芯片内部的操作，也可能影响其他设备或电路。</p><h3 id="5-时钟信号的干扰"><a href="#5-时钟信号的干扰" class="headerlink" title="5. 时钟信号的干扰"></a>5. <strong>时钟信号的干扰</strong></h3><p>时钟信号在数字电路中起着至关重要的作用。如果SSO噪声发生在时钟信号切换的瞬间，可能导致时钟信号出现抖动或偏移，从而影响时序的精度和稳定性。这种噪声还可能引发时钟同步问题，导致数据错误或处理延迟。</p><h3 id="6-信号反射与回波效应"><a href="#6-信号反射与回波效应" class="headerlink" title="6. 信号反射与回波效应"></a>6. <strong>信号反射与回波效应</strong></h3><p>当高速信号在PCB或芯片引脚之间传播时，由于不匹配的阻抗和信号反射效应，多个信号同时切换可能会引发信号的反射和回波，进一步增强SSO噪声。这些反射信号可能与原始信号相干扰，从而引起数据错误。</p><h3 id="降低SSO噪声的方式："><a href="#降低SSO噪声的方式：" class="headerlink" title="降低SSO噪声的方式："></a>降低SSO噪声的方式：</h3><p>为了减少SSO噪声的影响，常采取一些措施，如：</p><ul><li><strong>降低同时切换的信号数量</strong>：通过合理安排时序，避免过多信号同时切换，尤其是在高速传输中。</li><li><strong>优化电源和地线设计</strong>：通过增强电源去耦和改进地线设计，减少电压波动和噪声的传播。</li><li><strong>信号屏蔽和隔离</strong>：采用差分信号或增加信号线间的隔离，减少信号干扰。</li><li><strong>降低电流峰值</strong>：使用适当的驱动电路和时序控制，减少电流变化的速度，从而减小瞬时电流对电路的影响。</li></ul><p>简而言之，SSO噪声是由于多个信号同时切换时所引起的电流波动和电磁干扰，它可能导致系统的稳定性下降和时序问题，降低SSO噪声有助于提高系统的可靠性和时序准确性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Read Bit De-skew</title>
      <link href="/2024/11/25/DDR/Data%20Training-Read%20Bit%20De-skew/"/>
      <url>/2024/11/25/DDR/Data%20Training-Read%20Bit%20De-skew/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pub手册4.4.5.3.2,<strong>读取位去偏移（Read Bit De-skew）算法</strong>，该算法用于调整和校准 DDR 内存中数据位（DQ）之间的时序差异，确保所有的数据位在时序上对齐，以减少由于时序偏移（skew）造成的读写错误。<a><span id="more"></span></a></p></blockquote><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. <strong>概述</strong></h3><p><code>Read Bit De-skew</code> 是为了 <strong>调整所有字节通道（byte lanes）中的数据位的时序偏差</strong>，使得各个数据位（例如 DQ 信号）在物理层上的传输时序得到对齐，防止由于时序误差导致<code>读取数据</code>出错。</p><h3 id="2-所需的条件"><a href="#2-所需的条件" class="headerlink" title="2. 所需的条件"></a>2. <strong>所需的条件</strong></h3><ul><li><strong>单个 Rank（内存通道）访问</strong>：这个算法仅对一个 Rank 进行操作，而不是多个 Rank。Rank 可以通过 <code>DTCR.DTRANK</code> 寄存器来定义。</li><li><strong>使用可编程地址进行内存访问</strong>：该算法使用了最多四个可编程寄存器（<code>DTAR0</code> 到 <code>DTAR3</code>）来定义内存访问的起始地址。每个地址包含 <strong>bank、row、column</strong> 的信息，这些地址将用于进行内存的读取和写入操作。</li></ul><h3 id="3-DTAR-寄存器"><a href="#3-DTAR-寄存器" class="headerlink" title="3. DTAR 寄存器"></a>3. <strong>DTAR 寄存器</strong></h3><ul><li><code>DTAR0-3</code>：这些寄存器定义了四个内存起始地址，用于执行数据位去偏移算法。<ul><li><strong>Bank和行（Row）地址</strong>：所有的 <code>DTARn</code> 寄存器必须使用相同的 <strong>bank和行地址</strong>。</li><li><strong>列地址（Column Address）</strong>：在每个地址中，列地址的低三位（[2:0]）推荐设置为 <code>3&#39;b000</code>，这样可以确保对 8 个连续的内存地址进行访问。</li></ul></li></ul><h3 id="4-写入操作（Write-Operation）"><a href="#4-写入操作（Write-Operation）" class="headerlink" title="4. 写入操作（Write Operation）"></a>4. <strong>写入操作（Write Operation）</strong></h3><ul><li>顺序的写入操作：算法使用一系列固定连续的写操作，这有助于产生一个降低了同频串扰（SSO，Simultaneous Switching Output）的数据模式。SSO 是由于多个信号同时切换状态时引发的噪声，降低 SSO 可以提高时序的稳定性。<ul><li><strong>0 到 1 的过渡</strong>：对于奇数位和偶数位的写操作，分别在不同的内存地址之间进行 0 到 1 的过渡，以产生 <strong>0-1 过渡的模式</strong>。</li><li>写入操作包括 <strong>8 次 BL8（或者 16 次 BL4）写入</strong>。BL8 和 BL4 指的是 <strong>突发长度</strong>（Burst Length），分别表示每次写入 8 个或 4 个连续的数据单元。</li></ul></li></ul><h3 id="5-读取操作（Read-Operation）"><a href="#5-读取操作（Read-Operation）" class="headerlink" title="5. 读取操作（Read Operation）"></a>5. <strong>读取操作（Read Operation）</strong></h3><ul><li>顺序的读取操作：读取操作与写入操作类似，也是按顺序执行的，且同样用于生成降低了 SSO 的数据模式。<ul><li><strong>0 到 1 的过渡</strong>：类似写入操作，读取操作也会通过在不同的内存地址之间对奇数位和偶数位进行 <strong>0 到 1 的过渡</strong>，以保证数据位时序的一致性。</li><li><strong>读取操作包括 4 次 BL8（或者 8 次 BL4）读取</strong>，每次读取都会返回 32 个数据单元（通常称为“数据节拍（beat）”），这些数据将返回给 PHY（物理层）进行进一步处理。</li></ul></li></ul><h3 id="6-读取时序的比较（Comparison-of-Data-Beats）"><a href="#6-读取时序的比较（Comparison-of-Data-Beats）" class="headerlink" title="6. 读取时序的比较（Comparison of Data Beats）"></a>6. <strong>读取时序的比较（Comparison of Data Beats）</strong></h3><p>在执行读取操作时，返回的 32 个数据节拍（beat）中，只有 <strong>特定范围的数据</strong> 会被用来进行比较和对齐：</p><ul><li>假设数据节拍的编号为 <strong>0 到 31</strong>，那么只有 <strong>节拍 4 到 11 和 20 到 27</strong> 会被比较。</li><li>这意味着，读取的 32 个数据节拍中，只有一部分会被用来检查数据位的时序，帮助进行去偏移调整。</li></ul><h3 id="7-写入和读取的示意图"><a href="#7-写入和读取的示意图" class="headerlink" title="7. 写入和读取的示意图"></a>7. <strong>写入和读取的示意图</strong></h3><p><img src="https://s2.loli.net/2024/11/25/pU5JmHga4cIsYAr.png" alt="image-20241125223715118"></p><hr><blockquote><p>Read Bit De-skew 算法的目标是对齐每个数据位（DQ）在读取路径中的 <strong>0 到 1 的过渡</strong>，也就是消除数据位在时序上的偏差（skew），确保数据的正确读取。</p></blockquote><h3 id="主要步骤和目标："><a href="#主要步骤和目标：" class="headerlink" title="主要步骤和目标："></a>主要步骤和目标：</h3><p>1.<strong>目标</strong>：</p><ul><li>该算法的目标是 <strong>对齐数据位的 0 到 1 过渡</strong>，即保证每个数据位的读取时序正确，不偏离目标时序。</li><li>主要通过检测 <strong>数据眼</strong>（Data Eye）的边缘位置，确保所有数据位的读取时序对齐。</li></ul><p>2.<strong>写入序列（Write Sequence）</strong>：</p><ul><li>在开始读取位去偏移之前，算法首先执行一个 <strong>写入序列</strong>，将数据写入内存的三个预定地址：<code>DTAR0(x0000)</code>、<code>DTAR1(x0008)</code> 和 <code>DTAR2(x0010)</code>。</li><li>写入序列的作用是 <strong>确保数据正确写入</strong>，并为后续的读取操作提供正确的参考数据。</li><li>需要注意的是，这个写入序列 <strong>可选</strong> 地在写时序调整（Write Leveling Adjustment）之前执行。如果需要，可以通过 <strong><code>DTCR.DTEXD</code> 寄存器</strong> 增加额外的一个时钟周期（Cycle），以延长写时钟 DQS。</li></ul><p>3.<strong>读取位去偏移算法（Read Bit De-skew）</strong>：</p><ul><li><p><strong>写入完成后</strong>，接下来的操作都为 <strong>读取操作</strong>，这些读取操作用于执行去偏移（De-skew）调整。</p></li><li><p>检测数据眼的左边缘：算法首先需要检测数据眼的左边缘。左边缘指的是 DQS&#x2F;DQS# 的时序位置，算法检测到至少有一个数据位出现读取失败时，就定位到这个位置。</p><ul><li>读取失败意味着数据位与时钟的对齐出现了偏差，导致无法正确读取数据。</li></ul></li><li><p>右移数据位：在检测到左边缘后，算法将每个位右移，直到在读取过程中检测到失败（即数据读取不成功）。检测失败的次数由寄存器 <code>DTCR.DTRPT</code>中的值定义，表示读取失败的次数阈值。</p><ul><li>这一步是通过不断调整数据位的位置，找出在每个数据位上造成失败的时序点，从而进行校准。</li></ul></li></ul><p>4.<strong>定位数据眼右边缘</strong>：</p><ul><li>在每个数据位去偏移后，算法还会进一步“扫描”读取数据眼（read data eye），定位 <strong>数据眼的右边缘</strong>，即数据读取过程中成功接收数据的最右边界。</li><li>一旦检测到右边缘的位置，算法就会计算出 <strong>数据眼的中心</strong>。数据眼的中心是指 DQS&#x2F;DQS# 信号应该对齐的位置。</li></ul><p>5.<strong>确定 DQS 的位置</strong>：</p><ul><li>当数据眼的中心位置计算完成后，<strong>DQS 信号会被放置在数据眼的中心位置</strong>，确保所有的数据位在读取时能正确对齐到 DQS。</li></ul><h3 id="关键寄存器和概念："><a href="#关键寄存器和概念：" class="headerlink" title="关键寄存器和概念："></a>关键寄存器和概念：</h3><ul><li>**<code>DTCR.DTRPT</code>**：该寄存器定义了读取位去偏移算法中，必须进行多少次读取失败检测才能结束偏移校准。也就是说，如果一个数据位的读取在连续 <code>n</code> 次尝试中都失败，则认为该数据位的时序存在问题。</li><li>**<code>DTCR.DTEXD</code>**：该寄存器控制是否在写时序调整之前延长 DQS 信号的一个周期，用于微调写时序。</li><li><strong>数据眼（Data Eye）</strong>：是指在读取过程中，数据位与时钟信号（DQS）之间的有效时序窗口。在这个窗口内，数据可以被正确地读取。如果数据位在窗口外，就会导致读取失败。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Data Eye Trainging (2)</title>
      <link href="/2024/11/25/DDR/Data%20Training-Data%20Eye%20Trainging%20(2)/"/>
      <url>/2024/11/25/DDR/Data%20Training-Data%20Eye%20Trainging%20(2)/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>数据眼训练（Data Eye Training）</strong> 过程中，如何在进行数据训练的同时插入 <strong>刷新（Refresh）</strong> 操作，以及训练结果的处理。<a><span id="more"></span></a></p></blockquote><h3 id="1-在数据眼训练中插入刷新（Refresh-Insertion-during-Data-Eye-Training）"><a href="#1-在数据眼训练中插入刷新（Refresh-Insertion-during-Data-Eye-Training）" class="headerlink" title="1. 在数据眼训练中插入刷新（Refresh Insertion during Data Eye Training）"></a>1. <strong>在数据眼训练中插入刷新（Refresh Insertion during Data Eye Training）</strong></h3><p>DDR 内存中，<strong>刷新操作（Refresh）</strong> 是用来保持存储单元中的数据不丢失的。当内存中的数据位长时间未被访问时，必须定期执行刷新操作。在数据眼训练过程中，为了避免影响训练的准确性，通常会暂停刷新操作，直到数据眼训练的相关步骤执行完成。然而，在一些情况下，可以插入刷新操作，以保证数据不会因为长时间没有访问而丢失。</p><ul><li><strong>数据眼训练算法支持刷新插入</strong>：这意味着在进行数据训练时，可以在写入和读取操作的某些点之间插入刷新操作。特别是当数据训练算法中的写入或读取操作序列重复时，刷新操作可以插入这些重复序列之间，或者在读取数据结果的评估过程中插入。</li><li><strong>相关寄存器</strong>：<ul><li><strong>PGCR2.tREFPRD</strong>：这个寄存器定义了刷新周期（即多长时间插入一次刷新）。</li><li><strong>DTCR.RFSHDT</strong>：这个寄存器定义了在刷新周期内插入的刷新次数。</li></ul></li></ul><p>通过这些寄存器配置，系统可以在数据训练过程中合理地插入刷新操作，而不会干扰训练的过程。</p><h3 id="2-数据训练结果（Data-Training-Results）"><a href="#2-数据训练结果（Data-Training-Results）" class="headerlink" title="2. 数据训练结果（Data Training Results）"></a>2. <strong>数据训练结果（Data Training Results）</strong></h3><p>在数据眼训练的过程中，系统会为每个字节通道（byte lane）维护一个状态寄存器，记录训练过程中是否发生了错误或警告。</p><ul><li><strong>DXnGSR2寄存器</strong>：每个字节通道都有一个 <code>DXnGSR2</code> 寄存器，其中包含了当前数据眼训练的错误和警告状态标志。<ul><li><strong>ESTAT位域</strong>：这个位域包含了错误状态代码，用来标识在训练过程中失败发生的位置。每种错误状态代码都对应一个特定的子步骤，手册会描述发生错误的条件及相应的错误状态代码。</li></ul></li><li><strong>错误条件（Error Conditions）</strong>：错误是致命的，一旦发生错误，PUB（处理单元）会立即终止数据训练。错误通常表示在数据眼训练的某个子步骤中发生了问题。</li><li><strong>警告状态（Warning Status）</strong>：警告状态一般表明数据眼的左右边缘无法被正确检测到，尤其是在写入位偏移（write bit de-skew）或写眼图中心化（write eye centering）过程中。这可能是由于以下原因：<ul><li>当算法尝试定位数据眼的边缘时，可能会遇到资源的限制（例如，延迟线资源用尽），导致算法假设数据眼边缘已经被检测到，尽管实际上边缘可能并未准确对齐。这样会导致数据眼中心的位置偏移，从而影响数据时序。</li></ul></li><li><strong>处理警告的方法</strong>：一种常见的解决方法是对所有的 <strong>位延迟线（BDL）</strong> 进行“初始化（seeding）”，尤其是写入路径和读取路径中的 BDL。初始化的目的是为了解决由于 DQS 和 DQ 之间存在偏差时，可能导致眼图中心化不准确的问题。</li></ul><h3 id="3-BDL的初始化（Seeding-BDLs）"><a href="#3-BDL的初始化（Seeding-BDLs）" class="headerlink" title="3. BDL的初始化（Seeding BDLs）"></a>3. <strong>BDL的初始化（Seeding BDLs）</strong></h3><p>BDL（Bit Delay Line）是用来调整数据位的延迟的，它在写入和读取路径中都起到至关重要的作用。初始化（seeding）BDL的目的是通过为延迟线设置初始值，减少由于信号偏移引起的问题。</p><ul><li><strong>写路径中的 BDL 初始化</strong>：列举了一些寄存器（如 <code>DXnBDLR0.DQ0WBD</code>, <code>DXnBDLR0.DQ1WBD</code> 等），这些寄存器是用来控制写操作中的各个数据位的延迟线。</li><li><strong>读路径中的 BDL 初始化</strong>：列举了类似的寄存器（如 <code>DXnBDLR3.DQ0RBD</code>, <code>DXnBDLR3.DQ1RBD</code> 等），它们用于控制读取操作中的延迟线。</li></ul><p>这些寄存器的初始化值应根据 DQS 和 DQ 之间的偏移量来设置。通常建议将这些延迟线初始化为一个较大的值（例如 <code>x4</code> 或 <code>x8</code>），以便在执行数据训练之前对延迟进行适当的调整。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h3><p>这段内容主要讨论了两个方面：</p><ol><li><strong>刷新操作的插入</strong>：在进行数据眼训练时，为了保证内存的数据不丢失，可以在不干扰训练过程的情况下插入刷新操作。通过配置相关寄存器，可以控制刷新操作的频率和插入时机。</li><li><strong>训练结果的错误和警告处理</strong>：数据眼训练的过程中，如果检测到错误，训练会立即终止。警告通常是因为数据眼的边缘未能准确检测到，可能导致眼图中心位置的偏移。为了解决这个问题，可以通过初始化所有的 BDL 来对齐 DQS 和 DQ 之间的偏差，确保数据训练的准确性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Data Eye Trainging</title>
      <link href="/2024/11/25/DDR/Data%20Training-Data%20Eye%20Trainging/"/>
      <url>/2024/11/25/DDR/Data%20Training-Data%20Eye%20Trainging/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pub手册4.4.5， <strong>数据眼训练（Data Eye Training）</strong>，它是 DDR 内存中的一种自动校准过程，旨在优化时序，特别是在数据传输速率较高时（例如 2133Mbps 及以上），由于信号传输过程中的延迟和偏差，可能导致数据的传输质量下降。这里主要介绍了如何通过 <strong>延迟线</strong> 和 <strong>眼图中心化</strong> 来校正和优化 DDR4 的数据传输。<a><span id="more"></span></a></p></blockquote><h3 id="1-背景和挑战"><a href="#1-背景和挑战" class="headerlink" title="1. 背景和挑战"></a>1. <strong>背景和挑战</strong></h3><p>随着数据传输速率的提高，DDR4 接口的时序裕度变得更加困难。特别是在更高的比特率（如 2133Mbps 或更高）下，信号的延迟和时序偏差可能更难以控制。造成延迟和偏差的因素包括：</p><ul><li><strong>PHY 到 IO 路由的偏差</strong>：信号从PHY到IO的传输过程中，可能存在不均匀的延迟。</li><li><strong>封装（Package）和 PCB 布局偏差</strong>：内存封装和 PCB 布局也可能引入延迟差异。</li></ul><p>为了补偿这些问题，<strong>DDR4 mPHY 解决方案</strong>中使用了 <strong>延迟线（Delay Line）</strong> 来补偿由于各种因素（如路由偏差、封装偏差等）引起的每个数据位的时序偏差。</p><h3 id="2-数据眼训练的目的和过程"><a href="#2-数据眼训练的目的和过程" class="headerlink" title="2. 数据眼训练的目的和过程"></a>2. <strong>数据眼训练的目的和过程</strong></h3><p><strong>数据眼训练</strong>的主要目的是对 <strong>数据位</strong> 和 <strong>数据时钟（DQS）</strong> 之间的偏差进行校准，使其对齐并满足时序要求。数据眼训练包括两个主要步骤：</p><ol><li><strong>位偏移（Bit Deskew）</strong>：这个过程会通过 <strong>位延迟线（BDL）</strong> 对各个数据位进行调整，确保时序最迟的位（即延迟最长的位）与其他数据位同步。通过这种调整，使得所有的数据位的时序都被对齐。</li><li><strong>眼图居中（Eye Centering）</strong>：调整完成位偏移后，接下来的步骤是将数据时钟（DQS）调整到“数据眼”中心的位置。数据眼是指在一个周期内，数据传输可以稳定进行的时域范围。<strong>眼图中心化</strong>的目的是确保 DQS 信号位于每个字节的数据位的中间位置，确保数据的采样是准确的。</li></ol><h3 id="3-数据眼训练的执行步骤"><a href="#3-数据眼训练的执行步骤" class="headerlink" title="3. 数据眼训练的执行步骤"></a>3. <strong>数据眼训练的执行步骤</strong></h3><p>数据眼训练通过一系列的 <strong>读</strong> 和 <strong>写</strong> 访问操作来执行，具体包括：</p><ul><li><strong>写偏移（Write Deskewing）</strong>：对写操作中的数据进行时序偏差的校正。</li><li><strong>读偏移（Read Deskewing）</strong>：对读操作中的数据进行时序偏差的校正。</li></ul><p>训练过程中会使用 <strong>32-beat 数据传输</strong>，并多次重复。在每个 32-beat 的传输中，只对第 4-11 和第 20-27 的数据进行比较。通过这种方式，系统会确定哪些数据位的时序需要调整，并利用 <strong>位延迟线（BDL）</strong> 来补偿延迟。</p><h3 id="4-数据眼训练的算法流程"><a href="#4-数据眼训练的算法流程" class="headerlink" title="4. 数据眼训练的算法流程"></a>4. <strong>数据眼训练的算法流程</strong></h3><p>在数据眼训练过程中，首先会执行 <strong>读偏移校正</strong>，然后是 <strong>写偏移校正</strong>，接下来是 <strong>读眼图中心化</strong>，最后是 <strong>写眼图中心化</strong>。这些步骤会依次进行，但也可以根据需要调整顺序，尤其是在多通道的情况下：</p><ul><li>如果启用了每通道的眼图中心化（per-rank centering），那么会对每个通道分别进行眼图中心化。</li><li>如果禁用了每通道眼图中心化，眼图中心化只会在一个通道上执行。</li></ul><h3 id="5-眼图训练的注意事项"><a href="#5-眼图训练的注意事项" class="headerlink" title="5. 眼图训练的注意事项"></a>5. <strong>眼图训练的注意事项</strong></h3><ul><li><strong>眼图训练中的位校准和中心化</strong>：如果 DQS 与数据位之间的偏差非常大，DQS 很难保持在校准位置（即 1&#x2F;4 tCK）。这会导致后续的写入&#x2F;读取操作失败，进而导致数据错误。因此，<strong>位校准（Deskew）</strong> 和 <strong>眼图中心化（Centering）</strong> 必须一起执行，以确保数据的稳定传输。</li><li><strong>训练步骤的执行顺序</strong>：如果启用了每通道眼图中心化，建议不要在中心化之后重新执行偏移校正算法，因为这可能会导致不一致的结果。</li></ul><h3 id="6-训练过程中的地址配置"><a href="#6-训练过程中的地址配置" class="headerlink" title="6. 训练过程中的地址配置"></a>6. <strong>训练过程中的地址配置</strong></h3><p>数据眼训练使用 <strong>可编程地址</strong> 进行内存访问，要求必须满足以下条件：</p><ul><li>每次训练只能访问 <strong>单一通道（Rank）</strong>，而这个通道是在 <strong>DTCR.DTRANK</strong> 寄存器中指定的。</li><li>数据眼训练使用 <strong>DTAR0-3</strong> 寄存器来定义四个内存地址（分别对应不同的银行、行和列），这些地址用于执行 <strong>BL8（Burst Length 8）</strong> 或 <strong>两个连续的 BL4</strong> 写读操作。训练过程中需要访问 <strong>32 个内存单元</strong>。</li></ul><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h3><ul><li><strong>数据眼训练</strong> 主要目的是通过 <strong>位校准</strong> 和 <strong>眼图中心化</strong> 来确保数据时序准确，解决高比特率下信号传输的偏差问题。</li><li>训练过程包括多个步骤，首先校正数据的位偏差（Deskew），然后调整数据时钟的位置（Centering）。</li><li>地址配置非常关键，数据眼训练只能在特定的内存通道上进行，并需要确保使用的地址满足内存访问的要求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Write Leveling</title>
      <link href="/2024/11/25/DDR/Data%20Training-Write%20Leveling/"/>
      <url>/2024/11/25/DDR/Data%20Training-Write%20Leveling/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pub手册4.4.2，涉及的是 <strong>Write Leveling（写时序校准）</strong>，它是用于解决 <strong>DDR3&#x2F;DDR4 系统中的时序问题</strong> 的一种技术。具体来说，<strong>Write Leveling</strong> 通过调整时钟（CK）和数据采样时钟（DQS）之间的延迟，确保它们在每个 SDRAM 芯片中正确对齐。<a><span id="more"></span></a></p></blockquote><h3 id="1-问题背景：Fly-By-拓扑和信号偏移"><a href="#1-问题背景：Fly-By-拓扑和信号偏移" class="headerlink" title="1. 问题背景：Fly-By 拓扑和信号偏移"></a>1. <strong>问题背景：Fly-By 拓扑和信号偏移</strong></h3><p>在多 SDRAM DDR3&#x2F;DDR4 系统中，信号（如时钟、地址、控制信号）通常采用 <strong>Fly-By 拓扑</strong> 进行布线。该拓扑有以下优点：</p><ul><li><strong>减少了 stub（支路）的数量和长度</strong>，有助于改善信号完整性。</li><li><strong>写数据和时钟信号可以等延迟地传递到每个 SDRAM</strong>，但是这种布局可能导致时钟和数据采样信号（DQS）之间的偏移（skew），从而影响到时序要求，尤其是 <strong>tDQSS</strong>、<strong>tDSS</strong> 和 <strong>tDSH</strong> 这些时序参数。</li></ul><p><strong>Write Leveling</strong> 就是用来补偿这种偏移，确保每个 SDRAM 上的时钟（CK）与数据采样时钟（DQS）对齐。</p><h3 id="2-Write-Leveling-的工作原理"><a href="#2-Write-Leveling-的工作原理" class="headerlink" title="2. Write Leveling 的工作原理"></a>2. <strong>Write Leveling 的工作原理</strong></h3><p>在 <strong>Write Leveling</strong> 过程中，<strong>PUB（PHY Unit Block）</strong> 使用 <strong>SDRAM 的写时序校准功能</strong>，通过以下方式进行操作：</p><ul><li><strong>CK_t &#x2F; CK_c 和 DQS_t &#x2F; DQS_c 信号</strong> 由 SDRAM 同时采样，并通过数据总线（DQ）反馈给 PUB。</li><li><strong>DQS_t &#x2F; DQS_c 脉冲</strong> 会发送到 DRAM（内存芯片），同时增加（或者减少）DQS 信号的延迟，直到检测到 <strong>0 到 1 的过渡（transition）</strong>。</li><li>这个 <strong>0 到 1 的过渡</strong> 表示时钟的上升沿成功地采样到了 DQS 的上升沿，确保时序要求 <strong>tDQSS</strong> 被满足。</li></ul><h3 id="3-内建算法（Built-in-Algorithm）"><a href="#3-内建算法（Built-in-Algorithm）" class="headerlink" title="3. 内建算法（Built-in Algorithm）"></a>3. <strong>内建算法（Built-in Algorithm）</strong></h3><p>PUB 的 <strong>写时序校准算法</strong> 通过以下步骤训练每个 rank（内存通道）：</p><ol><li><strong>逐个训练 rank</strong>：每次只训练一个 rank，所有字节（bytes）同时训练。</li><li>将每个 rank 的所有 SDRAM 设置为 <strong>写时序校准模式</strong>，然后开始扫 DQS 脉冲，寻找 <strong>0 到 1 的过渡</strong>。</li><li><strong>过渡点</strong> 表示 CK 上升沿采样了 DQS 脉冲的上升沿。</li><li><strong>稳定性检查</strong>：为了确保这个结果是稳定的，算法要求采样值连续为 <strong>1</strong> 达到 <strong>8 次 LCDL 延迟（tap）</strong> 或 <strong>0.52 次 DXnGSR0.WLPRD</strong>，以过滤掉抖动和瞬时不稳定的信号。</li><li><strong>步进延迟</strong>：默认情况下，DQS 脉冲的延迟按 <strong>32 LCDL taps</strong> 进行步进（由 PGCR1.WLSTEP 控制）。当检测到 0 到 1 的过渡后，算法会回到之前的延迟值并重新进行扫延迟。</li><li>在找到有效过渡点之后，继续扫 DQS 脉冲，直到满足稳定值的条件（连续的 8 次有效 1 或 0.52 次 WLPRD）。</li><li>如果延迟步进设置为 <strong>单步 LCDL 延迟</strong>（由 PGCR1.WLSTEP 控制），则每次只有 <strong>1 LCDL tap</strong> 的延迟增量。</li></ol><h3 id="4-延迟补偿："><a href="#4-延迟补偿：" class="headerlink" title="4. 延迟补偿："></a>4. <strong>延迟补偿：</strong></h3><ul><li><strong>写时序校准</strong> 只会补偿 <strong>DQS 上升沿与下一次 CK 上升沿之间的相对延迟</strong>，这个相对延迟始终小于 1 个 tCK 周期。</li><li>如果 <strong>绝对延迟</strong> 大于 1 个 tCK，通常需要通过 <strong>Write Leveling Adjustment（写时序调整）</strong> 进一步补偿，这通常是在 <strong>PIR.WLADJ</strong> 步骤中完成。</li></ul><h3 id="5-Write-Leveling-Adjustment（写时序调整）"><a href="#5-Write-Leveling-Adjustment（写时序调整）" class="headerlink" title="5. Write Leveling Adjustment（写时序调整）"></a>5. <strong>Write Leveling Adjustment（写时序调整）</strong></h3><ul><li><strong>Write Leveling Adjustment</strong> 是用来在 <strong>Write Leveling</strong> 之后进一步调整延迟的，尤其是在时钟和数据之间已经大致对齐，但由于 <strong>抖动（jitter）</strong> 或 <strong>元稳定性（metastability）</strong>，可能仍然需要一些细微的调整。</li></ul><h3 id="6-软件支持的-Write-Leveling（软件驱动）"><a href="#6-软件支持的-Write-Leveling（软件驱动）" class="headerlink" title="6. 软件支持的 Write-Leveling（软件驱动）"></a>6. <strong>软件支持的 Write-Leveling（软件驱动）</strong></h3><p>PUB 还支持软件驱动的写时序校准算法，用户可以通过以下步骤执行该算法：</p><ul><li><strong>启用软件模式</strong>：通过设置 <code>PGCR1.WLMODE</code> 来启用软件写时序校准模式。</li><li><strong>设置 DQS 输出使能</strong>：设置 <code>DXnGCR3.DSOEMODE</code> 为 “始终开启”。</li><li><strong>设置延迟</strong>：使用 <code>DXnLCDLR0.WLD</code> 来设置 DQS 脉冲的延迟。</li><li><strong>触发 DQS 脉冲</strong>：通过设置 <code>PIR.WL = 0x1</code> 来触发 DQS 脉冲。</li><li><strong>监控结果</strong>：读取 <code>DXnGSR0.WLDQ</code> 来捕获 DRAM 的反馈结果。</li></ul><p>软件通过这些步骤可以精确地执行写时序校准，确保系统时序要求得到满足。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h3><ul><li><strong>Write Leveling</strong> 主要通过调整时钟（CK）和数据采样时钟（DQS）之间的相对延迟，确保它们的同步对齐，补偿 <strong>Fly-By 拓扑</strong> 带来的时序偏差。</li><li>在进行时序校准时，通过发送一系列 DQS 脉冲并逐步调整延迟，检测时钟和数据采样信号的对齐点。</li><li>如果需要进一步精细调整，<strong>Write Leveling Adjustment</strong> 步骤会进一步补偿大的延迟差异。</li><li>软件支持的写时序校准提供了更灵活的控制，允许用户根据需要调整训练过程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Write Leveling Adjustment</title>
      <link href="/2024/11/19/DDR/Data%20Training-Write%20Leveling%20Adjustment/"/>
      <url>/2024/11/19/DDR/Data%20Training-Write%20Leveling%20Adjustment/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.4.3.3，<strong>Write Leveling Adjustment（写入时序校准）</strong> 的训练过程，主要目的是调整 <strong>写入延迟（Write Latency, WL）</strong>，确保 <strong>写操作</strong> 和 <strong>数据采样</strong> 的时序一致，避免由于时序偏差导致的写入错误。<a><span id="more"></span></a></p></blockquote><h3 id="1-背景：写时序校准（Write-Leveling）"><a href="#1-背景：写时序校准（Write-Leveling）" class="headerlink" title="1. 背景：写时序校准（Write Leveling）"></a>1. <strong>背景：写时序校准（Write Leveling）</strong></h3><p>在之前的 <strong>Write Leveling（写时序校准）</strong> 训练阶段，系统已经将 <strong>时钟（CK）</strong> 边缘和 <strong>数据采样时钟（DQS）</strong> 边缘对齐了，但由于信号的延迟差异，写入时的时序（<code>Write Latency (WL)</code>）可能仍然不完全满足要求。<strong>Write Leveling Adjustment</strong> 的任务就是通过进一步调整时序，确保写入操作能够准确地同步，避免写入延迟过长或过短。</p><h3 id="2-调整的方式：增量调整"><a href="#2-调整的方式：增量调整" class="headerlink" title="2. 调整的方式：增量调整"></a>2. <strong>调整的方式：增量调整</strong></h3><p>在 <strong>Write Leveling Adjustment</strong> 阶段，时序调整的方式非常精确：</p><ul><li>时延调整：此过程中的延迟调整是 ½ 个 tCK 周期的增量或减量，意味着每次调整时，延迟只会变化一个小的单位，确保非常精确的时序控制。<ul><li><strong>减少写入延迟</strong>：通过在 <strong>命令路径</strong> 上加入延迟，而 <strong>数据路径</strong> 保持不变。</li><li><strong>增加写入延迟</strong>：通过在 <strong>数据路径</strong> 上加入延迟，而 <strong>命令路径</strong> 保持不变。</li></ul></li></ul><h3 id="3-训练过程：写操作（WR）与读操作（RD）的交替"><a href="#3-训练过程：写操作（WR）与读操作（RD）的交替" class="headerlink" title="3. 训练过程：写操作（WR）与读操作（RD）的交替"></a>3. <strong>训练过程：写操作（WR）与读操作（RD）的交替</strong></h3><ul><li><strong>写操作</strong>：为了正确校准时序，系统会发出一系列的 <strong>连续写操作（WR Transactions）</strong>，并且这些写操作使用一个特定的 <strong>数据模式</strong>，以帮助计算出实际的写入延迟。为了确保写入数据被正确地捕获，写操作包含了一个 <strong>扩展后的 DQS 后序脉冲序列</strong>，特别是当命令信号的延迟较大时。</li><li><strong>读操作</strong>：在写操作之后，会进行 <strong>读操作（RD Transactions）</strong>，读取刚刚写入的地址，检查数据是否正确地写入。这样可以验证写操作的结果。</li></ul><p><img src="https://s2.loli.net/2024/11/19/SsjuwckNnylg8Ra.png" alt="image-20241119232802878"></p><h3 id="4-数据分析：计算写入延迟"><a href="#4-数据分析：计算写入延迟" class="headerlink" title="4. 数据分析：计算写入延迟"></a>4. <strong>数据分析：计算写入延迟</strong></h3><ul><li>读数据之后，系统会分析每一位的数据，特别是在每条数据通道（lane）上逐位分析。通过计算每一位的 1 和 0 的个数，可以推测出写入延迟的正确调整值。<ul><li>如果某些位在上升沿和下降沿的数据不一致（例如 01 和 10），系统会认为这些位的 <strong>数据眼（Data Eye）</strong> 不可靠，因此会把这些位的数据从校准过程中排除。</li><li>只有那些在上升沿和下降沿都返回相同值的位才会被用于计算，这些位被认为是 <strong>数据眼良好</strong> 的，因此可以用于可靠的数据校验。</li></ul></li><li>如果 <strong>所有位都不一致</strong> 或者 <strong>数据眼不良</strong>，系统就会 <strong>丢弃这些比特</strong> 并标记为警告。如果无法正确计算 WL 调整值，算法会失败并发出错误信号。</li></ul><h3 id="5-训练结果的验证"><a href="#5-训练结果的验证" class="headerlink" title="5. 训练结果的验证"></a>5. <strong>训练结果的验证</strong></h3><ul><li>在 <strong>WL 调整值计算完毕之后</strong>，会再次发出一组新的写操作和读操作，以验证调整结果是否有效。如果没有错误发生，训练就被视为成功。</li><li>如果在这一步出现问题，系统会根据 <strong>PGSR0.WLAERR</strong> 和 <strong>DXnRSR3.WLAERR</strong> 错误标志，指出出错的通道（rank）和数据通道（lane）。</li></ul><h3 id="6-训练方式"><a href="#6-训练方式" class="headerlink" title="6. 训练方式"></a>6. <strong>训练方式</strong></h3><ul><li><strong>单通道模式</strong>：每次只训练一个 rank（内存通道），确保每个通道都经过独立训练。</li><li><strong>双通道共享 AC 模式</strong>：在这种模式下，两个 rank 会同时进行训练，确保所有数据通道在同一时间被训练。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Read Leveling</title>
      <link href="/2024/11/19/DDR/Data%20Training-Read%20Leveling/"/>
      <url>/2024/11/19/DDR/Data%20Training-Read%20Leveling/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.4.3.2，<strong>Read-Leveling</strong>（读偏移校准）过程，它是DDR中用来确保DQS（数据时钟信号） 的门控时序与读数据同步的一个技术，尤其是在DDR4模式下。它确保数据的读取过程能够在正确的时刻捕捉到数据。<a><span id="more"></span></a></p></blockquote><h3 id="关键概念："><a href="#关键概念：" class="headerlink" title="关键概念："></a>关键概念：</h3><ul><li><strong>DQS 信号</strong>：DDR 内存的数据时钟信号，在数据读取过程中用于同步数据。</li><li><strong>Gate</strong>：即门控信号，用来开启和关闭 DQS 信号的有效性，确保正确的读取时序。</li></ul><h3 id="训练过程概述："><a href="#训练过程概述：" class="headerlink" title="训练过程概述："></a>训练过程概述：</h3><ol><li><strong>使用两种不同版本的 DQS 门控信号</strong>：一个是 <strong>延迟版本（delayed）</strong>，另一个是 <strong>非延迟版本（nondelayed）</strong>。</li><li><strong>通过扫过这两个版本的门控信号</strong>，发起读操作，检测 <strong>第一个有效的 DQS 上升沿</strong>，也就是 DQS 信号从低到高的跳变，标志着有效数据的开始。</li><li><strong>一旦找到上升沿</strong>，最终的门控位置就通过将门控信号回退一个特定的值来确定，这个值是通过 <code>DTCR1.RDLVLGS</code> 寄存器编程的。</li></ol><h3 id="训练的步骤："><a href="#训练的步骤：" class="headerlink" title="训练的步骤："></a>训练的步骤：</h3><ol><li><strong>两个版本的 DQS 门控信号</strong>：<ul><li><strong>延迟版本和非延迟版本</strong>的 DQS 门控信号是用来采样 DQS 信号的。延迟版本意味着它稍微滞后于非延迟版本。</li><li>这两种版本的门控信号会同时工作，通过发起 <strong>RD（读）事务</strong> 来检测 <strong>DQS 上升沿</strong>，即数据开始的标志。</li></ul></li><li><strong>算法的工作原理</strong>：<ul><li><strong>扫过两个版本的门控信号</strong>，算法会不断地调整这两个门控信号的延迟，直到能够检测到 <strong>有效的 DQS 上升沿</strong>，这个上升沿标志着数据的有效开始。</li><li>找到上升沿后，系统会将门控信号 <strong>回退一个特定的值</strong>，这个回退的量是通过 <code>DTCR1.RDLVLGS</code> 寄存器编程的。</li></ul></li><li><strong>通过步进延迟来调整</strong>：<ul><li>训练过程中，系统会 <strong>逐步调整门控信号的延迟</strong>，每次调整一个 <strong>LCDL tap</strong>（一个细微的延迟步进），直到找到最佳的位置。</li></ul></li><li><strong>与基本门控训练的关系</strong>：<ul><li>如果已经运行过 <strong>基本门控训练（Basic Gate Training）</strong>，那么 <strong>读偏移校准</strong> 的过程会很快结束，因为门控信号已经接近有效的 DQS 上升沿位置。</li></ul></li><li><strong>只能在 DDR4 模式下运行</strong>：<ul><li>需要注意的是，<strong>Read-leveling</strong> 只能在 <strong>DDR4 模式</strong> 下运行，因为它依赖于 <strong>读前导训练模式</strong>，即确保 <strong>DQS 信号在事务之间不会被三态化</strong>（tristated），并且在读事务期间是清晰的，没有前导脉冲。</li></ul></li></ol><h3 id="训练的参数："><a href="#训练的参数：" class="headerlink" title="训练的参数："></a>训练的参数：</h3><ul><li><strong>DTCR1.RDLVLGS</strong>：这个寄存器控制 <strong>回退的量</strong>，即找到 DQS 上升沿之后，门控信号回退的延迟量。</li><li><strong>DTCR1.RDLVLGDIFF</strong>：通过这个寄存器可以设置两个门控信号版本之间的 <strong>延迟差异</strong>。</li><li><strong>DXnGTR.DGSL</strong> 和 <strong>DXnLCDLR2.DQSGD</strong>：这些寄存器控制门控信号的基本延迟值，为 <strong>read-leveling</strong> 提供起始位置。</li><li><strong>LCDL tap</strong>：用于精细调整门控延迟的位置步进。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Basic Gate training</title>
      <link href="/2024/11/19/DDR/Data%20Training-Basic%20Gate%20training/"/>
      <url>/2024/11/19/DDR/Data%20Training-Basic%20Gate%20training/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.4.3.1，<strong>Basic Gate Training（基本门控训练）</strong>是用来校准 <strong>DQS信号的门控位置</strong>，以确保读操作的正确性。DQS信号是用来同步数据传输的时钟信号，而这个门控信号需要精确地与数据同步，以避免数据错误。<a><span id="more"></span></a></p></blockquote><h3 id="训练目标："><a href="#训练目标：" class="headerlink" title="训练目标："></a>训练目标：</h3><p>基本门控训练的目标是找出 <strong>DQS门控信号</strong> 的最佳时序位置，使得内存控制器能够在正确的时刻捕捉到数据。</p><h3 id="训练过程概述："><a href="#训练过程概述：" class="headerlink" title="训练过程概述："></a>训练过程概述：</h3><ol><li><strong>训练从最小延迟的门控位置开始</strong>，即最早的位置。</li><li><strong>首先找到有效的左边位置</strong>，然后找到有效的右边位置。</li><li><strong>最终的门控位置是左边位置和右边位置的中位数</strong>，这是理论上最接近正确时序的位置。</li></ol><h3 id="训练的步骤："><a href="#训练的步骤：" class="headerlink" title="训练的步骤："></a>训练的步骤：</h3><ol><li><strong>从最小延迟位置开始：</strong><ul><li>训练从最小的延迟开始，也就是门控信号尽可能早地开启。这个位置是最“左边”的门控位置。</li><li>内存控制器会进行读操作，检查这个位置是否能成功地读取数据。如果不能读取，则意味着门控信号的时序还需要调整。</li></ul></li><li><strong>找到左边有效的门控位置：</strong><ul><li>从最小延迟位置开始，逐渐向右（增加延迟）调整，直到能成功读取数据为止。</li><li>一旦找到第一个有效位置，即读取成功的位置，它就成为 <strong>左边的有效门控位置</strong>。</li><li>然后，系统继续进行调整，在找到的有效位置和失败位置之间使用 <strong>二分查找</strong> 来更精确地定位。</li></ul></li><li><strong>避免跳过不稳定区域：</strong><ul><li>一旦找到左边的有效位置，系统会稍微“跳过”不稳定的区域（可能是由于抖动或不精确的时序），然后继续向右移动门控信号。这个“跳过”是为了避免一些由于时序不稳定导致的读取错误。</li><li>系统通过 1&#x2F;4 个 DDR 时钟周期的步进来调整门控位置。</li></ul></li><li><strong>找到右边有效的门控位置：</strong><ul><li>接着，训练系统会找到 <strong>右边的有效门控位置</strong>。这个位置是信号稍微延迟的地方，直到读操作失败。</li><li>和左边的位置一样，右边的位置通过调整来确定，使用二分查找来加速过程。</li></ul></li><li><strong>最终结果：</strong><ul><li>经过上面的步骤，系统最终确定了 <strong>最小延迟位置（左边位置）</strong> 和 <strong>最大延迟位置（右边位置）</strong>，这两个位置之间的中点就是理想的门控位置。</li></ul></li></ol><h3 id="训练参数："><a href="#训练参数：" class="headerlink" title="训练参数："></a>训练参数：</h3><ul><li><strong>DTCR.DTRPTN</strong>：控制每个门控位置的评估读操作次数。为了避免由于读取数据抖动产生误差，系统在评估时会进行多次读取。</li><li><strong>DTCR.DTCMPD</strong>：控制是否在评估门控位置时进行数据比较，确保数据是否正确。</li><li><strong>DXnGTR.DGSL</strong> 和 <strong>DXnLCDLR2.DQSGD</strong>：这些寄存器用于编程门控延迟，以精确控制DQS门控信号的延迟。</li></ul><h3 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a>特别注意：</h3><ol><li><strong>门控延迟的范围</strong>：<ul><li>在正常情况下，最终的门控位置应该离理想位置不超过1个延迟线（delay-line taps），最多2个延迟线。</li><li>如果路径的延迟很大，或者使用了扩展的门控（比如通过 <strong>DSGCR.DQSGX</strong> 控制的扩展门控），门控可能无法在对称的位置校准。</li></ul></li><li><strong>Jitter和错误读数的避免</strong>：<ul><li>在训练过程中，读取DQS信号时可能会遇到抖动（jitter），这会导致每次读取结果不一致。为了避免这种情况，系统会通过多次读取来确保该位置的稳定性。</li></ul></li><li><strong>训练的重置</strong>：<ul><li>每次触发基本门控训练时，<strong>所有当前的门控训练结果都会被清除</strong>，即重新从头开始训练。</li><li>训练时只会对启用的 <strong>rank</strong> 和 <strong>lane</strong> 进行训练，未启用的部分会被跳过。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-DQS Gate Training</title>
      <link href="/2024/11/19/DDR/Data%20Training-DQS%20Gate%20Training/"/>
      <url>/2024/11/19/DDR/Data%20Training-DQS%20Gate%20Training/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.4.3，<strong>DQS Gate Training</strong>（DQS门控训练），即DDR4内存控制器在读取数据时对DQS（数据传输时钟）信号的门控调整。门控是通过PHY（物理层）控制，目的是为了减少噪声并确保正确地捕获读取的数据。<a><span id="more"></span></a></p></blockquote><h3 id="1-DQS门控的重要性"><a href="#1-DQS门控的重要性" class="headerlink" title="1. DQS门控的重要性"></a>1. <strong>DQS门控的重要性</strong></h3><p>在DDR内存中，<strong>DQS</strong>（数据传输时钟）是与数据一起传输的时钟信号。在读取数据时，DQS信号需要与数据精确对齐，以便正确地捕获数据。然而，由于许多因素，比如<strong>电路板布局</strong>和信号传输路径的长度，DQS信号与数据之间的时延可能并不完全知道，因此需要对<strong>DQS门控</strong>进行训练，以确保它能够精确地与数据对齐。</p><h3 id="2-DQS门控训练的目的"><a href="#2-DQS门控训练的目的" class="headerlink" title="2. DQS门控训练的目的"></a>2. <strong>DQS门控训练的目的</strong></h3><ul><li><strong>门控对齐</strong>：训练的目的是找出DQS信号的门控位置，使其精确对齐读取的数据。这个门控必须在正确的时钟周期内开启，以避免误捕数据。</li><li><strong>训练过程</strong>：由于读取路径上的延迟因素（例如PCB板的信号线长度）通常不完全知道，因此必须进行训练来适应系统的特定情况。</li></ul><h3 id="3-训练机制"><a href="#3-训练机制" class="headerlink" title="3. 训练机制"></a>3. <strong>训练机制</strong></h3><p>DDR4内存控制器提供了一个内置的<strong>DQS门控训练单元</strong>，可以通过初始化过程、软件控制或内存控制器通过PIR寄存器触发。</p><ul><li><strong>基本门控训练（Basic Gate Training）</strong>：这是最基本的训练模式，用于调整门控的位置。</li><li><strong>读取对齐（Read-Leveling）</strong>：这是一个更高级的训练模式，通过对读取DQS信号的上升沿进行采样来识别正确的门控位置。</li></ul><h3 id="4-训练的步骤"><a href="#4-训练的步骤" class="headerlink" title="4. 训练的步骤"></a>4. <strong>训练的步骤</strong></h3><ul><li><strong>基本门控训练</strong>：<ul><li>该训练执行一系列读取操作，通过不断地<strong>调整DQS门控的延迟</strong>，找到一个合适的门控位置，使得读取操作可以成功执行。</li><li>由于可能的门控位置非常多（最多可能有9个tCK时钟周期的延迟），使用了<strong>二分查找算法</strong>来加速训练过程。这种算法可以在较短的时间内找到最合适的门控位置。</li></ul></li><li><strong>读取对齐（Read-Leveling）</strong>：<ul><li>该训练方式使用<strong>采样窗口技术</strong>，它并不关心读取数据是否正确，而是通过捕获<strong>DQS信号的上升沿</strong>来确定门控位置。</li><li>这个过程可以更快速地找到DQS门控的正确位置，避免浪费时间去验证数据的正确性。</li></ul></li></ul><h3 id="5-并行训练和排序"><a href="#5-并行训练和排序" class="headerlink" title="5. 并行训练和排序"></a>5. <strong>并行训练和排序</strong></h3><ul><li><strong>并行训练</strong>：这两种训练算法会对所有的字节线同时进行训练。也就是说，DDR的所有数据通道（byte lanes）会在同一时刻进行门控训练。</li><li><strong>逐个Rank训练</strong>：每次训练会对一个内存rank进行处理。即使在共享AC双通道模式下，也会依次对每个rank的字节线进行训练。</li></ul><h3 id="6-BIST环回模式中的DQS门控"><a href="#6-BIST环回模式中的DQS门控" class="headerlink" title="6. BIST环回模式中的DQS门控"></a>6. <strong>BIST环回模式中的DQS门控</strong></h3><ul><li><strong>BIST（内建自测试）环回模式</strong>：在这个模式下，DQS门控会一直处于开启状态。这是因为环回模式本身是为了测试读取操作，在该模式下不需要进行门控训练。</li><li><strong>环回模式中的DQS门控</strong>：即使门控被自动开启，仍然可以通过PGCR1.LBGDQS寄存器手动触发门控训练，用于测试环回模式中的门控机制。</li><li>环回模式与正常操作的差异<ul><li>在BIST模式中，由于读路径较短，训练得到的门控位置与正常操作的门控位置是不同的。</li><li>BIST模式下只有一个rank会进行训练，并且训练结果会应用到所有rank。</li><li>在环回模式中，<strong>写命令</strong>而不是读命令会被发出，因为是<strong>写入的数据</strong>被环回并当作读取的数据进行测试。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-读取配置文件</title>
      <link href="/2024/11/19/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2024/11/19/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>利用c语言加载配置文件到数组当中。<a><span id="more"></span></a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_REGISTERS 6</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> default_arr[NUM_REGISTERS];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_default_values</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span>&#123;</span><br><span class="line">  FILE* file = fopen(<span class="string">&quot;config.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == file)&#123;</span><br><span class="line">    <span class="comment">// simulation()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_REGISTERS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%x&quot;</span>, &amp;default_arr[i]) != <span class="number">1</span>) &#123;</span><br><span class="line">      fclose(file);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(file);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="config-txt"><a href="#config-txt" class="headerlink" title="config.txt"></a>config.txt</h4><ul><li><p>%x：这个格式说明符会自动处理带有 0x 前缀的十六进制数，并将它们转换为整数。因此，不需要做额外的处理，只要数据格式正确，fscanf 会自动解析 0x 后面的十六进制值。</p></li><li><p>输出：在打印数组值时，我们使用 %X 来以大写的十六进制形式显示数值。</p></li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x13</span><br><span class="line">0x33</span><br><span class="line">0x4a</span><br><span class="line">0x6f</span><br><span class="line">0x6</span><br><span class="line">0x3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Training-Static Read Training</title>
      <link href="/2024/11/18/DDR/Data%20Training-Static%20Read%20Training/"/>
      <url>/2024/11/18/DDR/Data%20Training-Static%20Read%20Training/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.4.4，DDR静态读训练 (Static Read Training) 是通过训练来确定读取命令和FIFO（First In, First Out）数据之间的延迟。<a><span id="more"></span></a></p></blockquote><h3 id="1-FIFO-和输入阶段"><a href="#1-FIFO-和输入阶段" class="headerlink" title="1. FIFO 和输入阶段"></a>1. <strong>FIFO 和输入阶段</strong></h3><p>在DDR控制器的PHY（物理层）读取路径中，存在一个FIFO缓冲区。这个FIFO的作用是将DDR内存中的数据传输到控制时钟域，也就是将从DDR中读取的数据传输到控制器中进行后续处理。</p><h3 id="2-静态读取训练的目标"><a href="#2-静态读取训练的目标" class="headerlink" title="2. 静态读取训练的目标"></a>2. <strong>静态读取训练的目标</strong></h3><p>静态读训练的目的是<strong>确定从发出读取命令到FIFO中第一字（数据）准备好的时间延迟</strong>。换句话说，这项训练帮助控制器计算出读命令开始和数据准备好之间的时延，以便精确控制读操作的时序。</p><h3 id="3-静态读训练的并行性"><a href="#3-静态读训练的并行性" class="headerlink" title="3. 静态读训练的并行性"></a>3. <strong>静态读训练的并行性</strong></h3><p>静态读取训练在多个字节上<strong>并行执行</strong>，并且需要进行写入和读取内存的操作。静态读训练会使用可编程的地址来进行内存访问。具体来说，它使用的地址满足以下要求：</p><ul><li><strong>DTAR寄存器：</strong> 静态读训练使用最多四个可编程寄存器（DTAR0 到 DTAR3）。这些寄存器定义了内存中的<strong>四个不同的起始地址</strong>（行、列、bank等），用于执行 <strong>BL8（Burst Length 8）</strong> 或 <strong>BL4（Burst Length 4）</strong> 的写入和读取操作。</li><li><strong>内存访问的要求：</strong><ul><li>每个地址对应的列地址是一个 <strong>BL8</strong> 或 <strong>两个相邻的BL4</strong> 操作。</li><li>所有DTAR寄存器的行和bank地址必须相同。</li><li>列地址的最低3位（[2:0]）建议为 <code>000</code>，以确保可以访问8个连续的突发地址。</li></ul></li></ul><h3 id="4-静态读训练中的写入操作"><a href="#4-静态读训练中的写入操作" class="headerlink" title="4. 静态读训练中的写入操作"></a>4. <strong>静态读训练中的写入操作</strong></h3><p>在进行静态读训练时，会通过<strong>写入全1和全0的数据</strong>来进行训练：</p><ul><li>全1数据会写入到地址 <strong>DTAR2</strong>。</li><li>全0数据会写入到地址 DTAR0 和 DTAR1<ul><li>为了确保训练的效果，写入操作使用 <strong>8个BL8</strong> 或 <strong>16个BL4</strong> 写入操作。</li></ul></li></ul><h3 id="5-静态读训练中的读取操作"><a href="#5-静态读训练中的读取操作" class="headerlink" title="5. 静态读训练中的读取操作"></a>5. <strong>静态读训练中的读取操作</strong></h3><p>在静态读训练的读取部分，数据的读取顺序是特定的，确保只有编号24到31的”beats”（字节）是全1的（假设”beats”编号从0到47）。静态读训练会进行 <strong>6个BL8</strong> 或 <strong>12个BL4</strong> 的读取操作。</p><p>每次读取操作会返回 <strong>48个数据beats</strong>，这些数据将被传输到PHY。</p><h3 id="6-延迟调整"><a href="#6-延迟调整" class="headerlink" title="6. 延迟调整"></a>6. <strong>延迟调整</strong></h3><p>静态读训练的核心任务是调整读取命令和FIFO中数据之间的延迟。它会尝试不同的延迟值，通过反复的读写操作，直到接收到预期的数据为止。最终会确定一个最小延迟，并在此基础上加一个时钟周期作为<strong>余量</strong>。</p><h3 id="7-静态读训练的范围"><a href="#7-静态读训练的范围" class="headerlink" title="7. 静态读训练的范围"></a>7. <strong>静态读训练的范围</strong></h3><p>静态读训练仅对特定的内存 <strong>rank</strong>（内存通道）进行。如果多个rank使用同一个路径（即同一个数据总线），那么需要保证所有rank在每个字节的读取路径延迟都在1个时钟周期内。如果不同的rank之间的延迟差异较大，用户需要对每个rank分别进行训练，并选择最大的延迟值进行后续操作。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>静态读训练的目的是通过对内存访问地址的精确控制，调整读取命令到FIFO中数据准备的延迟。这种训练能够帮助确定最优的延迟设置，确保在内存的读取操作中，数据可以按照预定的时序准确返回。同时，训练操作是通过并行执行多个字节的读写操作，并在每次读写时调整延迟，直到找到最佳的延迟配置。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
            <tag> PUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AXI总线协议的深入解析：从Burst传输到Outstanding, Out-of-Order与Interleaving</title>
      <link href="/2024/11/17/AMBA/AXI%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BB%8EBurst%E4%BC%A0%E8%BE%93%E5%88%B0Outstanding-Out-of-Order%E4%B8%8EInterleaving/"/>
      <url>/2024/11/17/AMBA/AXI%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BB%8EBurst%E4%BC%A0%E8%BE%93%E5%88%B0Outstanding-Out-of-Order%E4%B8%8EInterleaving/</url>
      
        <content type="html"><![CDATA[<blockquote><p>AXI协议中的几个关键特性，包括Burst传输、Outstanding、Out-of-Order以及Interleaving，并解释它们如何在系统中协同工作，以提升数据传输效率。<a><span id="more"></span></a></p></blockquote><h4 id="1-AXI总线上的正常Burst传输"><a href="#1-AXI总线上的正常Burst传输" class="headerlink" title="1. AXI总线上的正常Burst传输"></a><a>1. AXI总线上的正常Burst传输</a></h4><p>AXI协议是基于事务（Transaction）的，其中事务传输通常采用Burst模式。一个正常的Burst传输过程如下图所示：</p><ul><li><strong>读操作</strong>：主机（Master）向从机（Slave）发送读地址，并等待从机返回数据，之后主机继续发送下一个读地址，依此类推。</li><li><strong>写操作</strong>：主机发送写地址和数据，从机返回响应信号，完成当前事务，主机继续发送下一个写地址和数据。</li></ul><p>在这个过程中，AXI总线采用了较为简单的顺序传输方式，即数据的传输和地址的发送是紧密绑定的，主机必须等待上一次的传输完成后，才能开始下一次的传输。</p><h4 id="2-Outstanding（超前传输）"><a href="#2-Outstanding（超前传输）" class="headerlink" title="2. Outstanding（超前传输）"></a><a>2. Outstanding（超前传输）</a></h4><p><strong>Outstanding</strong>是AXI协议中非常重要的特性，它允许主机在等待上一笔事务完成之前，发起下一笔事务的请求，从而实现“超前传输”或“并行处理”。这一机制大大提高了系统的吞吐量，减少了总线空闲时间。</p><h5 id="2-1-Outstanding的含义"><a href="#2-1-Outstanding的含义" class="headerlink" title="2.1 Outstanding的含义"></a>2.1 Outstanding的含义</h5><p>从字面上理解，Outstanding指的是“在途”的事务。即使上一笔事务尚未完成，主机也可以继续发起新的请求，这为系统提供了更高的并行性和效率。这样，多个事务可以并行处理，从而提升数据传输的速度。</p><h5 id="2-2-如果Slave不支持Outstanding，如何响应？"><a href="#2-2-如果Slave不支持Outstanding，如何响应？" class="headerlink" title="2.2 如果Slave不支持Outstanding，如何响应？"></a>2.2 如果Slave不支持Outstanding，如何响应？</h5><p>在AXI协议中，若从机（Slave）不支持Outstanding，它会通过在接收到事务后，设置AxREADY信号为低，来阻止主机进行超前传输。只有等到当前事务的数据返回并将AxREADY信号设置为高时，主机才能发起下一个事务。</p><h5 id="2-3-Outstanding的实现"><a href="#2-3-Outstanding的实现" class="headerlink" title="2.3 Outstanding的实现"></a>2.3 Outstanding的实现</h5><p>AXI协议通过读写通道（AR&#x2F;AW channel）和响应通道（response channel）上的信号来管理Outstanding的实现。每个事务通过这些通道的信号来标识其是否完成，主机可以根据这些信号来判断是否继续发起新事务。</p><p>如图所示，当地址A11发出后，主机并未等待数据D11~D14的传输完成，便继续发出了A21地址请求。这就是Outstanding的典型应用场景。</p><h5 id="2-4-Outstanding能力"><a href="#2-4-Outstanding能力" class="headerlink" title="2.4 Outstanding能力"></a>2.4 Outstanding能力</h5><p>当AXI的Outstanding能力为1时，主机必须等待每一笔事务的完成才能发起下一个事务，这样的系统吞吐量较低。而当Outstanding能力大于1时，主机可以并行发起多个事务，提高了系统的整体性能。</p><p>例如，当Outstanding能力为2时，主机可以连续发送2个读地址命令，并等待数据返回后，再继续发起更多的请求。此时，如果数据返回较慢，系统可能需要等待，但在其他事务的数据传输进行时，系统的整体效率仍然能够得到提升。</p><h4 id="3-Out-of-Order（乱序）"><a href="#3-Out-of-Order（乱序）" class="headerlink" title="3. Out-of-Order（乱序）"></a><a>3. Out-of-Order（乱序）</a></h4><p><strong>Out-of-Order</strong>（乱序）是AXI协议中的另一个重要特性，它允许不同事务的响应数据在顺序上有所不同。换句话说，主机发出的请求可能并不会按照请求顺序依次返回数据，而是根据数据准备情况“乱序”返回。</p><h5 id="3-1-Out-of-Order的含义"><a href="#3-1-Out-of-Order的含义" class="headerlink" title="3.1 Out-of-Order的含义"></a>3.1 Out-of-Order的含义</h5><p>当多个事务在途时，它们的返回数据并不一定按发送顺序返回。例如，在数据传输过程中，较慢的事务可能会被更快的事务超越，这就是乱序操作。AXI通过事务ID（AWID、ARID、WID、RID）来标识和区分不同的事务，从而使得主机能够正确地将返回的数据匹配到对应的请求。</p><h5 id="3-2-Out-of-Order的应用"><a href="#3-2-Out-of-Order的应用" class="headerlink" title="3.2 Out-of-Order的应用"></a>3.2 Out-of-Order的应用</h5><p>乱序操作通常用于提高系统的吞吐量。例如，如果多个存储区域的访问速度不同，可以让较快的存储区域优先返回数据，而不必等待慢速区域的数据传输完成，这样就减少了延迟，提升了整体性能。</p><h4 id="4-Interleaving（交织）"><a href="#4-Interleaving（交织）" class="headerlink" title="4. Interleaving（交织）"></a><a>4. Interleaving（交织）</a></h4><p><strong>Interleaving</strong>（交织）指的是在多个事务的数据传输中，不同事务的数据可以交替进行。例如，主机可以同时发出两个事务的不同数据，并将这些数据交织在一起进行传输。</p><h5 id="4-1-交织的定义"><a href="#4-1-交织的定义" class="headerlink" title="4.1 交织的定义"></a>4.1 交织的定义</h5><p>交织指的是不同事务的数据能够“交错”传输。例如，事务1的数据是0a和0b，事务2的数据是1a和1b。如果支持交织，数据的传输顺序可能是0a、1a、0b、1b，而不是按事务顺序依次传输0a、0b、1a、1b。</p><h5 id="4-2-交织的实现"><a href="#4-2-交织的实现" class="headerlink" title="4.2 交织的实现"></a>4.2 交织的实现</h5><p>交织操作通过读数据和写数据的ID（RID和WID）来区分不同事务的数据。对于写交织来说，WID提供了标识不同事务的数据传输顺序；对于读交织，RID起到了类似的作用。通过这些标识，AXI协议能够在数据传输时保持正确的顺序。</p><h4 id="5-Outstanding、Out-of-Order与Interleaving的区别与联系"><a href="#5-Outstanding、Out-of-Order与Interleaving的区别与联系" class="headerlink" title="5. Outstanding、Out-of-Order与Interleaving的区别与联系"></a>5. Outstanding、Out-of-Order与Interleaving的区别与联系</h4><p>这三者是AXI协议中重要的特性，它们之间既有区别也有联系：</p><ul><li><strong>Outstanding</strong>：允许主机在等待数据返回之前发起新的事务，提升了系统的并行性。</li><li><strong>Out-of-Order</strong>：事务的响应顺序不一定与发送顺序一致，提高了系统的吞吐量。</li><li><strong>Interleaving</strong>：同一时刻可以交替传输来自不同事务的数据，减少了传输延迟。</li></ul><p>虽然这三者都能提升系统性能，但它们的实现机制有所不同。Outstanding关注的是地址的传输，而Out-of-Order和Interleaving则侧重于事务的响应顺序和数据的交织传输。通过合理的设计和配置，可以大幅提升AXI总线的带宽利用率和系统吞吐量。</p>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> AMBA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VCS常用编译和仿真选项</title>
      <link href="/2024/11/17/IC/VCS%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E5%92%8C%E4%BB%BF%E7%9C%9F%E9%80%89%E9%A1%B9/"/>
      <url>/2024/11/17/IC/VCS%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E5%92%8C%E4%BB%BF%E7%9C%9F%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>VCS编译和仿真过程中的常用参数 <a><span id="more"></span></a></p></blockquote><h2 id="编译选项-Compile"><a href="#编译选项-Compile" class="headerlink" title="编译选项 (Compile)"></a>编译选项 (Compile)</h2><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>-full64</code></td><td>在64bit模式下编译、仿真，用于64位操作系统</td></tr><tr><td><code>-j8</code></td><td>指定编译器可以并行编译的进程数为8</td></tr><tr><td><code>-timescale=1ns/1ps</code></td><td>指定仿真时间和精度</td></tr><tr><td><code>-y &lt;dir_pathname&gt;</code></td><td>指定Verilog库路径</td></tr><tr><td><code>+libext+.v+.V+.sv+.svh</code></td><td>识别多种格式文件，如 <code>.v</code>, <code>.sv</code>, <code>.svh</code> 等</td></tr><tr><td><code>-sverilog</code></td><td>支持SystemVerilog语法的编译选项</td></tr><tr><td><code>-f xxx.lisf</code></td><td>指定包含所有设计文件列表的文件名</td></tr><tr><td><code>-top test</code></td><td>设置顶层模块为 <code>test</code></td></tr><tr><td><code>-l xx.log</code></td><td>编译log输出到指定的文件 <code>xx.log</code></td></tr><tr><td><code>+define+XX_MACRO</code></td><td>定义一个宏变量 <code>XX_MACRO</code>，也可以定义具体的值，如 <code>+define+XX_MACRO=9</code></td></tr><tr><td><code>+incdir+/xx/xx/</code></td><td>指定 <code>include</code> 指令使用的包含文件的目录，可以指定多个</td></tr><tr><td><code>-M</code></td><td>启用增量编译，只编译修改过的文件</td></tr><tr><td><code>-Mdir=&lt;directory&gt;</code></td><td>指定目录存储编译产生的文件，默认是 <code>csrc</code></td></tr><tr><td><code>-Mlib=&lt;directory&gt;</code></td><td>指定目录让VCS搜索某个模块是否需要重新编译，配合 <code>-Mdir</code> 实现不同模块的增量编译</td></tr><tr><td><code>-Mupdate[=0]</code></td><td>保留上次的makefile，避免覆盖，默认为覆盖上次的makefile</td></tr><tr><td><code>-noIncrComp</code></td><td>关闭增量编译</td></tr><tr><td><code>-notice</code></td><td>显示更多的编译过程警告信息，有助于调试和优化设计</td></tr><tr><td><code>-R</code></td><td>编译完成后立即执行 <code>simv</code> 命令进行仿真</td></tr><tr><td><code>+memcbk</code></td><td>启用多维数组变量的回调，便于查看波形中的多维数组或memory型变量</td></tr><tr><td><code>+warn=none</code></td><td>忽略所有警告信息</td></tr><tr><td><code>+warn=all</code></td><td>显示所有警告信息</td></tr><tr><td><code>-debug_access+all</code></td><td>启用所有debug信息，保留波形文件等</td></tr><tr><td><code>-debug_all</code></td><td>启用UCLI命令行调试</td></tr><tr><td><code>-kdb</code></td><td>启动KDB调试模式，支持命令行交互式调试操作</td></tr><tr><td><code>-cm &lt;options&gt;</code></td><td>指定覆盖率类型，支持：行覆盖（line）、条件覆盖（cond）、状态机覆盖（fsm）等</td></tr><tr><td><code>-cm_assert_hier &lt;filename&gt;</code></td><td>限定SVA覆盖率统计在指定的module层次</td></tr><tr><td><code>-cm_cond &lt;arguments&gt;</code></td><td>进一步细化条件覆盖率的统计方式</td></tr><tr><td><code>-cm_count</code></td><td>统计覆盖次数</td></tr><tr><td><code>-cm_dir &lt;directory_path_name&gt;</code></td><td>指定覆盖率统计结果存放路径，默认为 <code>simv.cm</code></td></tr><tr><td><code>-cm_hier &lt;filename&gt;</code></td><td>指定覆盖率统计的范围，可以指定模块名、层次名等</td></tr><tr><td><code>-cm_log &lt;filename&gt;</code></td><td>指定覆盖率日志文件名</td></tr><tr><td><code>-cm_name &lt;filename&gt;</code></td><td>指定保存覆盖率结果的文本文件名</td></tr><tr><td><code>-o &lt;name&gt;</code></td><td>指定编译生成的可执行文件的名称，默认是 <code>simv</code></td></tr><tr><td><code>+v2k</code></td><td>支持Verilog-2001标准</td></tr><tr><td><code>+vcs+initmem+0/1/x/z</code></td><td>初始化设计中所有存储器的值</td></tr><tr><td><code>+vcs+initreg+0/1/x/z</code></td><td>初始化设计中所有寄存器的值</td></tr><tr><td><code>+vcs+lic+wait</code></td><td>等待license</td></tr><tr><td><code>+nospecify</code></td><td>忽略 <code>specify</code> 块，仿真时只关注设计逻辑行为，不执行时序约束</td></tr><tr><td><code>+notimecheck</code></td><td>跳过时序约束检查，加快仿真速度，重点仿真设计逻辑</td></tr></tbody></table><h2 id="仿真选项-Simulation"><a href="#仿真选项-Simulation" class="headerlink" title="仿真选项 (Simulation)"></a>仿真选项 (Simulation)</h2><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>+ntb_random_seed</code></td><td>设置NTB（Native TestBench）随机种子</td></tr><tr><td><code>-line</code></td><td>启用VriSim单步运行</td></tr><tr><td><code>-ntb</code></td><td>启用NTB，支持OpenVera验证平台语言结构</td></tr><tr><td><code>-timescale=&lt;time_unit&gt;/&lt;time_precision&gt;</code></td><td>设置源文件中的timescale选项，如果文件没有定义timescale时使用此选项</td></tr><tr><td><code>-override_timescale=&lt;time_unit&gt;/&lt;time_precision&gt;</code></td><td>统一源文件的timescale设置</td></tr><tr><td><code>-pvalues+&lt;parameter_name&gt;=&lt;value&gt;</code></td><td>改变指定参数的值</td></tr><tr><td><code>-parameters &lt;filename&gt;</code></td><td>通过文件改变参数的值，文件中指定了参数路径和新值</td></tr><tr><td><code>+error+&lt;n&gt;</code></td><td>将编译时运行的NTB错误增加到N</td></tr><tr><td><code>-vcd &lt;filename&gt;</code></td><td>指定VCD波形文件名，默认为 <code>verilog.dump</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> VCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DV </tag>
            
            <tag> VCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uvm_sequence_item类的identification方法总结</title>
      <link href="/2024/11/17/UVM/uvm-sequence-item%E7%B1%BB%E7%9A%84identification%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2024/11/17/UVM/uvm-sequence-item%E7%B1%BB%E7%9A%84identification%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>UVM中uvm_sequence_item类的identification方法总结 <a><span id="more"></span></a></p></blockquote><table><thead><tr><th>identification</th><th>description</th></tr></thead><tbody><tr><td>get_sequence_id</td><td>私有</td></tr><tr><td>set_item_context</td><td>对 sequence item 设置 sequence 和 sequencer 的执行上下文</td></tr><tr><td>set_use_sequence_info&#x2F;get_use_sequence_info</td><td>这些方法用于 set 和 get use_sequence_info 位的状态</td></tr><tr><td>set_id_info</td><td>将 sequence_id 和 transaction_id 从被引用的项复制到调用项</td></tr><tr><td>set_sequencer</td><td>设置 sequence 默认的 sequencer 为 sequencer</td></tr><tr><td>get_sequencer</td><td>返回这个 sequence 默认使用的 sequencer 的引用</td></tr><tr><td>set_parent_sequence</td><td>设置这个 sequence_item 的父 sequence</td></tr><tr><td>get_parent_sequence</td><td>返回对调用此方法的任何 sequence 的父 sequence 的引用</td></tr><tr><td>set_depth</td><td>任何 sequence 的深度都是自动计算出来的</td></tr><tr><td>get_depth</td><td>返回从它的父 sequence 到这个 sequence 的深度</td></tr><tr><td>is_item</td><td>这个函数可以在任何 sequence_item 或 sequence 上调用</td></tr><tr><td>get_root_sequence_name</td><td>提供根 sequence 的名字 (最上层的父 sequence)</td></tr><tr><td>get_root_sequence</td><td>提供根 sequence 的应用 (最上层的父 sequence)</td></tr><tr><td>get_sequence_path</td><td>在完整层次路径中，提供每个 sequence 的名称字符串</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> UVM </tag>
            
            <tag> DV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uvm cmdline processor类</title>
      <link href="/2024/11/16/UVM/uvm-cmdline-processor%E7%B1%BB/"/>
      <url>/2024/11/16/UVM/uvm-cmdline-processor%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>uvm_cmdline_processor，用以处理uvm命令行参数，这些参数用于仿真阶段，而非编译阶段。<a><span id="more"></span></a></p></blockquote><h1 id="UVM-参数总结"><a href="#UVM-参数总结" class="headerlink" title="UVM 参数总结"></a>UVM 参数总结</h1><table><thead><tr><th><strong>命令参数</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>+UVM_DUMP_CMDLINE_ARGS</strong></td><td>打印所有命令行参数到报告机制中，输出格式为树形。</td><td><code>+UVM_DUMP_CMDLINE_ARGS</code></td></tr><tr><td><strong>+UVM_TESTNAME</strong></td><td>指定要通过工厂创建并在 UVM 阶段中执行的 test（或 uvm_component）。如果多个设置出现，则使用第一个并发出警告。</td><td><code>+UVM_TESTNAME=read_modify_write_test</code></td></tr><tr><td><strong>+UVM_VERBOSITY</strong></td><td>设置所有组件的初始打印级别。如果多个设置出现，则使用第一个并发出警告。</td><td><code>+UVM_VERBOSITY=UVM_HIGH</code></td></tr><tr><td><strong>+uvm_set_verbosity</strong></td><td>设置特定组件在特定阶段（和仿真过程中的特定时间）上的打印级别。</td><td><code>+uvm_set_verbosity=uvm_test_top.env0.agent1.,ALL,UVM_FULL,time,800</code></td></tr><tr><td><strong>+uvm_set_action</strong></td><td>提供与 <code>uvm_report_object</code> 相等的报告行为设置。可使用 <code>ALL</code> 设置 ID 或严重性，指定的行为可以是 <code>UVM_NO_ACTION</code> 或其他 UVM 消息行为。</td><td><code>+uvm_set_action=uvm_test_top.env0.*,ALL,UVM_ERROR,UVM_NO_ACTION</code></td></tr><tr><td><strong>+uvm_set_severity</strong></td><td>设置报告的严重性级别。<code>ALL</code> 可用于 ID 或当前严重性参数。</td><td><code>+uvm_set_severity=uvm_test_top.env0.,BAD_CRC,UVM_ERROR,UVM_WARNING</code></td></tr><tr><td><strong>+UVM_TIMEOUT</strong></td><td>设置 UVM 框架的全局超时时间。<code>YES</code> 或 <code>NO</code> 指定是否允许用户代码改变此值。</td><td><code>+UVM_TIMEOUT=200000,NO</code></td></tr><tr><td><strong>+UVM_MAX_QUIT_COUNT</strong></td><td>设置报告服务器的最大退出计数。<code>YES</code> 或 <code>NO</code> 指定是否允许用户代码改变此值。</td><td><code>+UVM_MAX_QUIT_COUNT=5,NO</code></td></tr><tr><td><strong>+UVM_PHASE_TRACE</strong></td><td>开启阶段执行信息的追踪。用户只需要将该参数放在命令行中。</td><td><code>+UVM_PHASE_TRACE</code></td></tr><tr><td><strong>+UVM_OBJECTION_TRACE</strong></td><td>开启对 objection 活动的追踪。用户只需要将该参数放在命令行中。</td><td><code>+UVM_OBJECTION_TRACE</code></td></tr><tr><td><strong>+UVM_RESOURCE_DB_TRACE</strong></td><td>开启对资源 DB 访问的追踪。用户只需要将该参数放在命令行中。</td><td><code>+UVM_RESOURCE_DB_TRACE</code></td></tr><tr><td><strong>+UVM_CONFIG_DB_TRACE</strong></td><td>开启对配置 DB 访问的追踪。用户只需要将该参数放在命令行中。</td><td><code>+UVM_CONFIG_DB_TRACE</code></td></tr><tr><td><strong>+uvm_set_inst_override</strong></td><td>设置组件实例的重载。</td><td><code>+uvm_set_inst_override=eth_packet,short_eth_packet, full_path</code></td></tr><tr><td><strong>+uvm_set_type_override</strong></td><td>设置组件类型的重载。第三个参数指定是否替换先前的类型重载，默认为 1，若设置为 0，则不替换。</td><td><code>+uvm_set_type_override=eth_packet,short_eth_packet,0</code></td></tr><tr><td><strong>+uvm_set_config_int</strong></td><td>设置整数类型的配置项。</td><td><code>+uvm_set_config_int=uvm_test_top.soc_env,mode,5</code></td></tr><tr><td><strong>+uvm_set_config_string</strong></td><td>设置字符串类型的配置项。</td><td><code>+uvm_set_config_string=uvm_test_top.soc_env,mode,&quot;high&quot;</code></td></tr><tr><td><strong>+uvm_set_default_sequence</strong></td><td>设置默认序列。可以使用序列类型名称来定义默认的序列。</td><td><code>+uvm_set_default_sequence=path.to.sequencer,main_phase,seq_type</code></td></tr></tbody></table><p>这些命令行参数在 UVM 仿真中非常重要，可以控制仿真过程中的许多方面，例如打印级别、超时设置、报告行为、组件类型重载等。通过这些参数，可以灵活地调整仿真行为，帮助优化和调试 UVM 环境。</p><ul><li>后面如果是有好几个参数的要跟一个引号括起来。如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`+uvm_set_inst_override=<span class="string">&quot;m_monitor, new_monitor, env.agt.monitor&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a><a>Source Code</a></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">UVM仿真命令行参数（直接上代码里的注释吧，写得挺全了）：</span><br><span class="line">// Variable: +UVM_DUMP_CMDLINE_ARGS</span><br><span class="line">// ~+UVM_DUMP_CMDLINE_ARGS~ allows the user to dump all command line arguments to the</span><br><span class="line">// reporting mechanism. The output in is tree format.</span><br><span class="line">// The implementation of this is in uvm_root.</span><br><span class="line">// Group: Built-in UVM Aware Command Line Arguments</span><br><span class="line">//</span><br><span class="line">// Variable: +UVM_TESTNAME</span><br><span class="line">//</span><br><span class="line">// ~+UVM_TESTNAME=~ allows the user to specify which uvm_test (or</span><br><span class="line">// uvm_component) should be created via the factory and cycled through the UVM phases.</span><br><span class="line">// If multiple of these settings are provided, the first occurrence is used and a warning</span><br><span class="line">// is issued for subsequent settings. For example:</span><br><span class="line">//</span><br><span class="line">//| +UVM_TESTNAME=read_modify_write_test</span><br><span class="line">//</span><br><span class="line">// The implementation of this is in uvm_root since this is procedurally invoked via</span><br><span class="line">// ovm_root::run_test().</span><br><span class="line">// Variable: +UVM_VERBOSITY</span><br><span class="line">//</span><br><span class="line">// ~+UVM_VERBOSITY=~ allows the user to specify the initial verbosity</span><br><span class="line">// for all components. If multiple of these settings are provided, the first occurrence</span><br><span class="line">// is used and a warning is issued for subsequent settings. For example:</span><br><span class="line">//</span><br><span class="line">//| +UVM_VERBOSITY=UVM_HIGH</span><br><span class="line">//</span><br><span class="line">// The implementation of this is in uvm_root since this is procedurally invoked via</span><br><span class="line">// ovm_root::new().</span><br><span class="line">// Variable: +uvm_set_verbosity</span><br><span class="line">//</span><br><span class="line">// ~+uvm_set_verbosity=,,,~ and</span><br><span class="line">// ~+uvm_set_verbosity=,,,time,~ allow the users to manipulate the</span><br><span class="line">// verbosity of specific components at specific phases (and times during the “run” phases)</span><br><span class="line">// of the simulation. The ~id~ argument can be either ~ALL~ for all IDs or a</span><br><span class="line">// specific message id. Wildcarding is not supported for id due to performance concerns.</span><br><span class="line">// Settings for non-“run” phases are executed in order of occurrence on the command line.</span><br><span class="line">// Settings for “run” phases (times) are sorted by time and then executed in order of</span><br><span class="line">// occurrence for settings of the same time. For example:</span><br><span class="line">//</span><br><span class="line">//| +uvm_set_verbosity=uvm_test_top.env0.agent1.,ALL,UVM_FULL,time,800</span><br><span class="line">//</span><br><span class="line">// Variable: +uvm_set_action</span><br><span class="line">//</span><br><span class="line">// ~+uvm_set_action=&lt;comp&gt;,&lt;id&gt;,&lt;severity&gt;,&lt;action&gt;~ provides the equivalent of</span><br><span class="line">// various uvm_report_object’s set_report_action APIs. The special keyword,</span><br><span class="line">// _ALL_, can be provided for both/either the id and/or severity arguments. The</span><br><span class="line">// action can be UVM_NO_ACTION or a | separated list of the other UVM message</span><br><span class="line">// actions. For example:</span><br><span class="line">//</span><br><span class="line">//| +uvm_set_action=uvm_test_top.env0.*,ALL,UVM_ERROR,UVM_NO_ACTION</span><br><span class="line">//</span><br><span class="line">// Variable:+uvm_set_severity</span><br><span class="line">//</span><br><span class="line">// ~+uvm_set_severity=,,,~ provides the</span><br><span class="line">// equivalent of the various uvm_report_object’s set_report_severity_override APIs. The</span><br><span class="line">// special keyword, _ALL_, can be provided for both/either the id and/or</span><br><span class="line">// ~current severity~ arguments. For example:</span><br><span class="line">//</span><br><span class="line">//| +uvm_set_severity=uvm_test_top.env0.,BAD_CRC,UVM_ERROR,UVM_WARNING</span><br><span class="line">//</span><br><span class="line">// Variable:+UVM_TIMEOUT</span><br><span class="line">//</span><br><span class="line">// ~+UVM_TIMEOUT=&lt;timeout&gt;,&lt;overridable&gt;~ allows users to change the global timeout of the UVM</span><br><span class="line">// framework. The argument (‘YES’ or ‘NO’) specifies whether user code can subsequently</span><br><span class="line">// change this value. If set to ‘NO’ and the user code tries to change the global timeout value, an</span><br><span class="line">// warning message will be generated.</span><br><span class="line">//</span><br><span class="line">//| +UVM_TIMEOUT=200000,NO</span><br><span class="line">//</span><br><span class="line">// The implementation of this is in uvm_root.</span><br><span class="line">// Variable: +UVM_MAX_QUIT_COUNT</span><br><span class="line">//</span><br><span class="line">// +UVM_MAX_QUIT_COUNT=&lt;count&gt;,&lt;overridable&gt; allows users to change max quit count for the report</span><br><span class="line">// server. The argument (‘YES’ or ‘NO’) specifies whether user code can subsequently</span><br><span class="line">// change this value. If set to ‘NO’ and the user code tries to change the max quit count value, an</span><br><span class="line">// warning message will be generated.</span><br><span class="line">//</span><br><span class="line">//| +UVM_MAX_QUIT_COUNT=5,NO</span><br><span class="line">//</span><br><span class="line">// Variable: +UVM_PHASE_TRACE</span><br><span class="line">//</span><br><span class="line">// +UVM_PHASE_TRACE turns on tracing of phase executions. Users simply need to put the</span><br><span class="line">// argument on the command line.</span><br><span class="line">// Variable: +UVM_OBJECTION_TRACE</span><br><span class="line">//</span><br><span class="line">// +UVM_OBJECTION_TRACE turns on tracing of objection activity. Users simply need to put the</span><br><span class="line">// argument on the command line.</span><br><span class="line">// Variable: +UVM_RESOURCE_DB_TRACE</span><br><span class="line">//</span><br><span class="line">// +UVM_RESOURCE_DB_TRACE turns on tracing of resource DB access.</span><br><span class="line">// Users simply need to put the argument on the command line.</span><br><span class="line">// Variable: +UVM_CONFIG_DB_TRACE</span><br><span class="line">//</span><br><span class="line">// +UVM_CONFIG_DB_TRACE turns on tracing of configuration DB access.</span><br><span class="line">// Users simply need to put the argument on the command line.</span><br><span class="line">// Variable: +uvm_set_inst_override</span><br><span class="line">// Variable: +uvm_set_type_override</span><br><span class="line">//</span><br><span class="line">// +uvm_set_inst_override=&lt;req_type&gt;,&lt;override_type&gt;,&lt;full_inst_path&gt; and</span><br><span class="line">// +uvm_set_type_override=&lt;req_type&gt;,&lt;override_type&gt;[,&lt;replace&gt;] work</span><br><span class="line">// like the name based overrides in the factory–factory.set_inst_override_by_name()</span><br><span class="line">// and factory.set_type_override_by_name().</span><br><span class="line">// For uvm_set_type_override, the third argument is 0 or 1 (the default is</span><br><span class="line">// 1 if this argument is left off); this argument specifies whether previous</span><br><span class="line">// type overrides for the type should be replaced. For example:</span><br><span class="line">//</span><br><span class="line">//| +uvm_set_type_override=eth_packet,short_eth_packet</span><br><span class="line">//</span><br><span class="line">// The implementation of this is in uvm_root.</span><br><span class="line">// Variable: +uvm_set_config_int</span><br><span class="line">// Variable: +uvm_set_config_string</span><br><span class="line">//</span><br><span class="line">// +uvm_set_config_int=&lt;comp&gt;,&lt;field&gt;,&lt;value&gt; and</span><br><span class="line">// +uvm_set_config_string=&lt;comp&gt;,&lt;field&gt;,&lt;value&gt; work like their</span><br><span class="line">// procedural counterparts: set_config_int() and set_config_string(). For</span><br><span class="line">// the value of int config settings, &#x27;b (0b), &#x27;o, &#x27;d, &#x27;h (&#x27;x or 0x)</span><br><span class="line">// as the first two characters of the value are treated as base specifiers</span><br><span class="line">// for interpreting the base of the number. Size specifiers are not used</span><br><span class="line">// since SystemVerilog does not allow size specifiers in string to</span><br><span class="line">// value conversions. For example:</span><br><span class="line">//</span><br><span class="line">//| +uvm_set_config_int=uvm_test_top.soc_env,mode,5</span><br><span class="line">//</span><br><span class="line">// No equivalent of set_config_object() exists since no way exists to pass a</span><br><span class="line">// uvm_object into the simulation via the command line.</span><br><span class="line">//</span><br><span class="line">// The implementation of this is in uvm_root.</span><br><span class="line">// Variable: +uvm_set_default_sequence</span><br><span class="line">//</span><br><span class="line">// The +uvm_set_default_sequence=&lt;seqr&gt;,&lt;phase&gt;,&lt;type&gt; plusarg allows</span><br><span class="line">// the user to define a default sequence from the command line, using the</span><br><span class="line">// typename of that sequence. For example:</span><br><span class="line">//</span><br><span class="line">//| +uvm_set_default_sequence=path.to.sequencer,main_phase,seq_type</span><br><span class="line">//</span><br><span class="line">// This is functionally equivalent to calling the following in your</span><br><span class="line">// test:</span><br><span class="line">//</span><br><span class="line">//| uvm_coreservice_t cs = uvm_coreservice_t::get();</span><br><span class="line">//| uvm_factory f = cs.get_factory();</span><br><span class="line">//| uvm_config_db#(uvm_object_wrapper)::set(this,</span><br><span class="line">//| “path.to.sequencer.main_phase”,</span><br><span class="line">//| “default_sequence”,</span><br><span class="line">//| f.find_wrapper_by_name(“seq_type”));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> UVM </tag>
            
            <tag> DV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python脚本-bit_pattern_generator</title>
      <link href="/2024/11/16/Programming/Python%E8%84%9A%E6%9C%AC-bit-pattern-generator/"/>
      <url>/2024/11/16/Programming/Python%E8%84%9A%E6%9C%AC-bit-pattern-generator/</url>
      
        <content type="html"><![CDATA[<blockquote><p>bit_pattern_generator.py包含两个主要功能：1. 生成 <strong>10,000 个随机的 32 位无符号整数</strong>，并将其以二进制格式写入指定的输出文件。2. 处理 <strong>44 位二进制数字</strong>，对其进行 <strong>1 位翻转</strong> 和 <strong>2 位翻转</strong> 操作，并将结果保存到指定文件中。这个脚本适用于需要批量生成、处理或反转二进制数字的场景，尤其在硬件仿真和测试中非常有用。<a><span id="more"></span></a></p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h2><h4 id="1-生成随机的-32-位二进制数"><a href="#1-生成随机的-32-位二进制数" class="headerlink" title="1. 生成随机的 32 位二进制数"></a>1. <strong>生成随机的 32 位二进制数</strong></h4><ul><li>生成 10,000 个随机的无符号 32 位整数。</li><li>每个整数的二进制表示会保存到一个输出文件中。</li></ul><h4 id="2-44-位数字的翻转处理"><a href="#2-44-位数字的翻转处理" class="headerlink" title="2. 44 位数字的翻转处理"></a>2. <strong>44 位数字的翻转处理</strong></h4><ul><li>通过指定的模式（<code>F</code>、<code>0</code>、<code>5</code>、<code>A</code>）生成初始的 44 位数字。</li><li>执行 <strong>1 位翻转</strong>：逐位反转每个比特。</li><li>执行 <strong>2 位翻转</strong>：对所有可能的两位比特组合进行反转操作。</li></ul><h4 id="3-文件输出"><a href="#3-文件输出" class="headerlink" title="3. 文件输出"></a>3. <strong>文件输出</strong></h4><ul><li>生成的 32 位随机数以及翻转后的 44 位数字会被写入到不同的文件中。</li></ul><h4 id="4-通过命令行配置"><a href="#4-通过命令行配置" class="headerlink" title="4. 通过命令行配置"></a>4. <strong>通过命令行配置</strong></h4><ul><li>支持通过命令行参数来指定文件路径、生成的数字个数以及要使用的 44 位模式。</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><h5 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a><strong>命令行参数</strong></h5><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td><code>-f</code> 或 <code>--file</code></td><td>生成的 32 位随机数的输出文件路径</td><td><code>random_numbers.txt</code></td></tr><tr><td><code>-c</code> 或 <code>--count</code></td><td>要生成的随机数个数</td><td><code>10000</code></td></tr><tr><td><code>-n</code> 或 <code>--pattern</code></td><td>用于生成 44 位数字的模式（<code>F</code>：全 1，<code>0</code>：全 0，<code>5</code>：交替 0 和 1，<code>A</code>：交替 1 和 0）</td><td><strong>必需参数</strong></td></tr><tr><td><code>-o</code> 或 <code>--output_file</code></td><td>输出 44 位数字及其翻转结果的文件路径</td><td><code>44bit_numbers.txt</code></td></tr></tbody></table><h2 id="示例命令"><a href="#示例命令" class="headerlink" title="示例命令"></a><strong>示例命令</strong></h2><h4 id="1-生成随机的-32-位二进制数并保存到-random-numbers-txt-文件中"><a href="#1-生成随机的-32-位二进制数并保存到-random-numbers-txt-文件中" class="headerlink" title="1. 生成随机的 32 位二进制数并保存到 random_numbers.txt 文件中"></a>1. 生成随机的 32 位二进制数并保存到 <code>random_numbers.txt</code> 文件中</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python bit_flip_generator.py --file random_output.txt --count 5000</span><br></pre></td></tr></table></figure><h4 id="2-处理一个-44-位的数字（模式为-A）进行-1-位和-2-位翻转，并将结果保存到-flipped-results-txt-文件"><a href="#2-处理一个-44-位的数字（模式为-A）进行-1-位和-2-位翻转，并将结果保存到-flipped-results-txt-文件" class="headerlink" title="2. 处理一个 44 位的数字（模式为 A）进行 1 位和 2 位翻转，并将结果保存到 flipped_results.txt 文件"></a>2. 处理一个 44 位的数字（模式为 <code>A</code>）进行 1 位和 2 位翻转，并将结果保存到 <code>flipped_results.txt</code> 文件</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python bit_flip_generator.py --pattern A --output_file flipped_output.txt</span><br></pre></td></tr></table></figure><h4 id="3-使用默认参数执行所有功能"><a href="#3-使用默认参数执行所有功能" class="headerlink" title="3. 使用默认参数执行所有功能"></a>3. 使用默认参数执行所有功能</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python bit_flip_generator.py</span><br></pre></td></tr></table></figure><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><ul><li>ZLin，2024年11月16日</li></ul><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a><a>Source Code</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomNumberGenerator</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename, count=<span class="number">10000</span>, output_file=<span class="string">&#x27;44bit_numbers.txt&#x27;</span></span>):</span><br><span class="line">    <span class="comment"># Initialize random number generator and 44-bit number reverser</span></span><br><span class="line">    <span class="variable language_">self</span>.filename = filename</span><br><span class="line">    <span class="variable language_">self</span>.count = count</span><br><span class="line">    <span class="variable language_">self</span>.output_file = output_file</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">generate_random_numbers</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># Generate specified number of 32-bit unsigned random numbers and write them to file</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="variable language_">self</span>.filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.count):</span><br><span class="line">        random_number = random.randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">32</span> - <span class="number">1</span>)</span><br><span class="line">        binary_representation = <span class="string">f&quot;<span class="subst">&#123;random_number:032b&#125;</span>&quot;</span></span><br><span class="line">        f.write(binary_representation + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">generate_pattern</span>(<span class="params">self, pattern_type</span>):</span><br><span class="line">    <span class="comment"># Generate a 44-bit binary pattern based on the input pattern type</span></span><br><span class="line">    <span class="keyword">if</span> pattern_type == <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> * <span class="number">44</span></span><br><span class="line">    <span class="keyword">elif</span> pattern_type == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> * <span class="number">44</span></span><br><span class="line">    <span class="keyword">elif</span> pattern_type == <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;01&#x27;</span> * <span class="number">22</span></span><br><span class="line">    <span class="keyword">elif</span> pattern_type == <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;10&#x27;</span> * <span class="number">22</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid pattern type. Supported types are: &#x27;F&#x27;, &#x27;0&#x27;, &#x27;5&#x27;, &#x27;A&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">reverse_44bit_number</span>(<span class="params">self, number</span>):</span><br><span class="line">    <span class="comment"># Reverse the 44-bit number, performing 1-bit and 2-bit reversals from the right side</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(number) != <span class="number">44</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&quot;The input number must be a 44-bit binary string.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># List to store all the 1-bit reversed numbers</span></span><br><span class="line">    reversed_1bit_numbers = []</span><br><span class="line">    <span class="comment"># List to store all the 2-bit reversed numbers</span></span><br><span class="line">    reversed_2bit_numbers = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Flip each bit one at a time (1-bit reversal) from the right side</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(number)):</span><br><span class="line">      num_list = <span class="built_in">list</span>(number)</span><br><span class="line">      <span class="comment"># Flip the ith bit</span></span><br><span class="line">      num_list[<span class="built_in">len</span>(number)-<span class="number">1</span>-i] = <span class="string">&#x27;1&#x27;</span> <span class="keyword">if</span> num_list[<span class="built_in">len</span>(number)-<span class="number">1</span>-i] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">      <span class="comment"># &#x27;&#x27;.join(num_list) =&gt; list to string</span></span><br><span class="line">      reversed_1bit_numbers.append(<span class="string">&#x27;&#x27;</span>.join(num_list))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Flip every 2-bit combination (flip pairs of bits) from the right side</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(number)):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(number)):</span><br><span class="line">        num_list = <span class="built_in">list</span>(number)</span><br><span class="line">        <span class="comment"># Flip the i-th and j-th bits (both flipped independently)</span></span><br><span class="line">        num_list[<span class="built_in">len</span>(number)-<span class="number">1</span>-i] = <span class="string">&#x27;1&#x27;</span> <span class="keyword">if</span> num_list[<span class="built_in">len</span>(number)-<span class="number">1</span>-i] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        num_list[<span class="built_in">len</span>(number)-<span class="number">1</span>-j] = <span class="string">&#x27;1&#x27;</span> <span class="keyword">if</span> num_list[<span class="built_in">len</span>(number)-<span class="number">1</span>-j] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        reversed_2bit_numbers.append(<span class="string">&#x27;&#x27;</span>.join(num_list))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> reversed_1bit_numbers, reversed_2bit_numbers</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">write_44bit_numbers_to_file</span>(<span class="params">self, number, reversed_1bit_numbers, reversed_2bit_numbers</span>):</span><br><span class="line">    <span class="comment"># Write the original number, 1-bit reversed numbers, and 2-bit reversed numbers to file</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="variable language_">self</span>.output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      f.write(<span class="string">f&quot;Original number: <span class="subst">&#123;number&#125;</span>\n&quot;</span>)</span><br><span class="line">      f.write(<span class="string">&quot;All 1-bit reversed numbers:\n&quot;</span>)</span><br><span class="line">      <span class="keyword">for</span> rev_num <span class="keyword">in</span> reversed_1bit_numbers:</span><br><span class="line">        f.write(rev_num + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      f.write(<span class="string">&quot;All 2-bit reversed numbers:\n&quot;</span>)</span><br><span class="line">      <span class="keyword">for</span> rev_num <span class="keyword">in</span> reversed_2bit_numbers:</span><br><span class="line">        f.write(rev_num + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self, pattern_type</span>):</span><br><span class="line">    <span class="comment"># Generate the 44-bit number, perform 1-bit and 2-bit reversals, and write results to file</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      number = <span class="variable language_">self</span>.generate_pattern(pattern_type)</span><br><span class="line">      reversed_1bit_numbers, reversed_2bit_numbers = <span class="variable language_">self</span>.reverse_44bit_number(number)</span><br><span class="line">      <span class="variable language_">self</span>.write_44bit_numbers_to_file(number, reversed_1bit_numbers, reversed_2bit_numbers)</span><br><span class="line">      <span class="comment">#print(f&quot;Original number: &#123;number&#125;&quot;)</span></span><br><span class="line">      <span class="comment">#print(&quot;All 1-bit reversed numbers:&quot;)</span></span><br><span class="line">      <span class="comment">#for rev_num in reversed_1bit_numbers:</span></span><br><span class="line">      <span class="comment">#  print(rev_num)</span></span><br><span class="line">      <span class="comment">#print(&quot;All 2-bit reversed numbers:&quot;)</span></span><br><span class="line">      <span class="comment">#for rev_num in reversed_2bit_numbers:</span></span><br><span class="line">      <span class="comment">#  print(rev_num)</span></span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="comment"># Parse command-line arguments</span></span><br><span class="line">  parser = argparse.ArgumentParser(description=<span class="string">&quot;Generate a specified number of 32-bit random numbers or reverse a 44-bit number.&quot;</span>)</span><br><span class="line">  parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--file&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;random_numbers.txt&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Output file path for 32-bit random numbers&#x27;</span>)</span><br><span class="line">  parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--count&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of random numbers to generate (default is 10000)&#x27;</span>)</span><br><span class="line">  parser.add_argument(<span class="string">&#x27;-n&#x27;</span>, <span class="string">&#x27;--pattern&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;Pattern type for 44-bit number (F=all 1s, 0=all 0s, 5=alternating 0 and 1, A=alternating 1 and 0)&quot;</span>)</span><br><span class="line">  parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, <span class="string">&#x27;--output_file&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;44bit_numbers.txt&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Output file path for 44-bit numbers and reversals&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">  rng = RandomNumberGenerator(args.file, args.count, args.output_file)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> args.pattern:</span><br><span class="line">    rng.process(args.pattern)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    rng.generate_random_numbers()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串的使用</title>
      <link href="/2024/11/16/Programming/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/16/Programming/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>‘’.join(num_list) 是 Python 中常用的字符串方法，通常用于将一个可迭代的对象（如列表、元组）中的元素连接成一个单一的字符串。<a><span id="more"></span></a></p></blockquote><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="1-num-list-是一个包含字符的列表。每个字符都是一个单独的字符串。例如"><a href="#1-num-list-是一个包含字符的列表。每个字符都是一个单独的字符串。例如" class="headerlink" title="1. num_list 是一个包含字符的列表。每个字符都是一个单独的字符串。例如"></a>1. <strong><code>num_list</code></strong> 是一个包含字符的列表。每个字符都是一个单独的字符串。例如</h4>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num_list = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="2-join-num-list"><a href="#2-join-num-list" class="headerlink" title="2. &#39;&#39;.join(num_list)"></a>2. <strong><code>&#39;&#39;.join(num_list)</code></strong></h4><ul><li><code>&#39;&#39;.join()</code> 方法是调用在一个空字符串 <code>&#39;&#39;</code> 上，它会将 <code>num_list</code> 列表中的每个元素连接成一个新的字符串。</li><li><code>&#39; &#39;</code>（即空字符串）是分隔符，表示列表中的元素将被直接连接在一起，不会有任何额外的字符（如空格、逗号等）插入。</li></ul><h4 id="3-结果"><a href="#3-结果" class="headerlink" title="3. 结果"></a>3. <strong>结果</strong></h4><ul><li><p>通过 <code>&#39; &#39;.join(num_list)</code>，它会将列表中的所有字符按顺序连接起来，返回一个新的字符串：</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>])  <span class="comment"># 结果是 &#x27;101000&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>这是将 <code>num_list</code> 中的元素（字符 <code>&#39;1&#39;</code>, <code>&#39;0&#39;</code>, <code>&#39;1&#39;</code>, <code>&#39;0&#39;</code>, <code>&#39;0&#39;</code>, <code>&#39;0&#39;</code>）按顺序合并成一个单一的字符串 <code>&#39;101000&#39;</code>。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>&#39;&#39;.join(num_list)</code> 的作用是将 <code>num_list</code> 列表中的所有元素（通常是字符）连接成一个连续的字符串，<code>&#39;&#39;</code> 表示 <strong>没有分隔符</strong>。这个方法通常用于将列表中的字符或字符串拼接成一个完整的字符串。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VCS-Ucli命令汇总</title>
      <link href="/2024/11/16/IC/VCS-ucli%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2024/11/16/IC/VCS-ucli%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下是一些常用的 VCS 调试命令，帮助更高效地进行仿真调试。<a><span id="more"></span></a></p></blockquote><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><strong>scope</strong></td><td>显示当前的顶层模块</td><td></td></tr><tr><td><strong>scope xxx</strong></td><td>进入 <code>xxx</code> 模块</td><td></td></tr><tr><td><strong>scope -up</strong></td><td>回到上一层模块</td><td></td></tr><tr><td><strong>show</strong></td><td>显示当前模块的信号及子模块</td><td></td></tr><tr><td><strong>show xxx -value -radix hex&#x2F;bin&#x2F;dec</strong></td><td>以特定进制（十六进制、二进制或十进制）显示信号值</td><td><code>xxx</code> 为信号名称</td></tr><tr><td><strong>run</strong></td><td>运行仿真，直到遇到 <code>$stop</code> 或设置的断点</td><td></td></tr><tr><td><strong>run xx</strong></td><td>运行仿真，持续 <code>xx</code> 时间后停止（不推荐使用）</td><td></td></tr><tr><td><strong>run -posedge xx</strong></td><td>运行仿真，直到信号 <code>xx</code> 的上升沿</td><td></td></tr><tr><td><strong>run -negedge xx</strong></td><td>运行仿真，直到信号 <code>xx</code> 的下降沿</td><td></td></tr><tr><td><strong>run -change xx</strong></td><td>运行仿真，直到信号 <code>xx</code> 变化时停止</td><td></td></tr><tr><td><strong>stop</strong></td><td>显示当前已经设置的断点</td><td></td></tr><tr><td><strong>stop -posedge xx</strong></td><td>在信号 <code>xx</code> 的上升沿设置断点</td><td></td></tr><tr><td><strong>stop -negedge xx</strong></td><td>在信号 <code>xx</code> 的下降沿设置断点</td><td></td></tr><tr><td><strong>stop -condition {信号表达式}</strong></td><td>在信号表达式为真时设置断点</td><td>例如：<code>stop -condition &#123;a == 1&#125;</code></td></tr><tr><td><strong>stop -delete xx</strong></td><td>删除编号为 <code>xx</code> 的断点</td><td><code>xx</code> 为断点编号</td></tr><tr><td><strong>restart</strong></td><td>重新启动 UCLI 调试</td><td></td></tr><tr><td><strong>&lt;cmd&gt; -h</strong></td><td>查询某个命令的帮助信息</td><td><code>&lt;cmd&gt;</code> 为具体的命令，例如 <code>run -h</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> VCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DV </tag>
            
            <tag> VCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VCS动态加载DPI共享库(.so)</title>
      <link href="/2024/11/16/IC/VCS%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDDPI%E5%85%B1%E4%BA%AB%E5%BA%93(.so)/"/>
      <url>/2024/11/16/IC/VCS%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDDPI%E5%85%B1%E4%BA%AB%E5%BA%93(.so)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用Verilog&#x2F;SystemVerilog进行硬件验证时，动态加载DPI（Direct Programming Interface）共享库是一个常见且强大的功能。通过这种方式，我们可以将C或C++代码与Verilog代码结合起来，以实现更复杂的验证任务。本文将介绍如何在VCS仿真环境中动态加载DPI共享库，以及如何高效地管理这些库文件。<a><span id="more"></span></a></p></blockquote><h2 id="VCS编译与DPI共享库"><a href="#VCS编译与DPI共享库" class="headerlink" title="VCS编译与DPI共享库"></a><a>VCS编译与DPI共享库</a></h2><p>在VCS中，我们通常先进行VCS的编译（<code>vcs compile</code>），然后通过调用GCC编译器生成C语言的<code>.so</code>文件（共享库）。这些<code>.so</code>文件包含了C&#x2F;C++代码，可以在仿真时与SystemVerilog代码进行交互。</p><h3 id="动态加载DPI共享库"><a href="#动态加载DPI共享库" class="headerlink" title="动态加载DPI共享库"></a>动态加载DPI共享库</h3><p>在仿真运行时（<code>vcs run</code>），需要手动加载这些<code>.so</code>文件。VCS提供了两种命令行选项来加载DPI共享库，具体方式如下：</p><ul><li><strong>使用<code>-sv_liblist</code>指定.so的列表文件（Bootstrap file）</strong><br>这种方式需要提供一个列表文件，其中列出了所有需要加载的<code>.so</code>文件（不需要加文件后缀名）。这个文件将包含所有依赖的共享库路径，VCS会根据这些信息动态加载相关的库。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-sv_liblist Bootstrap.file</span><br></pre></td></tr></table></figure><ul><li><strong>使用<code>-sv_lib</code>逐个指定共享库</strong><br>你也可以通过<code>-sv_lib</code>选项手动指定每个<code>.so</code>库。注意，库名不需要加<code>.so</code>后缀。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-sv_lib libname</span><br></pre></td></tr></table></figure><h3 id="配置DPI共享库根目录"><a href="#配置DPI共享库根目录" class="headerlink" title="配置DPI共享库根目录"></a>配置DPI共享库根目录</h3><p><code>-sv_root</code>选项用于指定DPI共享库的根目录。这个目录是共享库查找的起始路径。通过设置这个选项，我们可以确保仿真器在正确的位置查找和加载共享库。特别是，这个路径还支持环境变量<code>$ENV</code>，使得路径设置更加灵活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-sv_root /home/user</span><br></pre></td></tr></table></figure><h2 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a><a>示例配置</a></h2><p>假设我们有一组共享库文件，分别位于不同的目录。可以通过以下两种方式进行配置：</p><h4 id="使用-sv-liblist"><a href="#使用-sv-liblist" class="headerlink" title="使用-sv_liblist"></a>使用<code>-sv_liblist</code></h4><p>首先，设置DPI共享库根目录，然后指定包含共享库路径的列表文件（<code>Bootstrap.file</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-sv_root /home/user</span><br><span class="line">-sv_liblist Bootstrap.file</span><br></pre></td></tr></table></figure><h4 id="使用-sv-lib"><a href="#使用-sv-lib" class="headerlink" title="使用-sv_lib"></a>使用<code>-sv_lib</code></h4><p>另外一种方式是直接指定每个共享库的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-sv_root /home/user</span><br><span class="line">-sv_lib myclibs/lib1</span><br><span class="line">-sv_lib myclibs/lib3</span><br><span class="line">-sv_lib proj1/clibs/lib4</span><br></pre></td></tr></table></figure><p>这会加载以下路径的共享库：</p><ul><li><code>/home/user/myclibs/lib1.so</code></li><li><code>/home/user/myclibs/lib3.so</code></li><li><code>/home/user/proj1/clibs/lib4.so</code></li></ul><h3 id="sv-liblist示例"><a href="#sv-liblist示例" class="headerlink" title="sv_liblist示例"></a>sv_liblist示例</h3><p>在<code>Bootstrap.file</code>文件中，你可以列出所有需要加载的共享库。文件内容可能类似如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myclibs/lib1</span><br><span class="line">myclibs/lib3</span><br><span class="line">proj1/clibs/lib4</span><br></pre></td></tr></table></figure><p>这些库的完整路径将在仿真过程中被解析为：</p><ul><li><code>/home/user/myclibs/lib1.so</code></li><li><code>/home/user/myclibs/lib3.so</code></li><li><code>/home/user/proj1/clibs/lib4.so</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h2><p>动态加载DPI共享库是一种强大的技术，能够帮助我们在VCS仿真过程中将C&#x2F;C++代码与Verilog代码无缝集成。通过使用<code>-sv_liblist</code>或<code>-sv_lib</code>选项，我们可以灵活地加载多个共享库，而<code>-sv_root</code>选项则允许我们指定共享库的根目录。这些功能不仅提高了仿真效率，还增加了配置的灵活性。</p><p>如果你正在进行复杂的硬件验证，尤其是需要与C&#x2F;C++代码交互时，掌握这些DPI共享库加载技巧将大大提高你的工作效率。</p>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> VCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DV </tag>
            
            <tag> VCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高VCS仿真效率-UVM Runtime Cmdline和VCS分块编译</title>
      <link href="/2024/11/16/IC/%E6%8F%90%E9%AB%98VCS%E4%BB%BF%E7%9C%9F%E6%95%88%E7%8E%87-UVM%20Runtime%20Cmdline%E5%92%8CVCS%E5%88%86%E5%9D%97%E7%BC%96%E8%AF%91/"/>
      <url>/2024/11/16/IC/%E6%8F%90%E9%AB%98VCS%E4%BB%BF%E7%9C%9F%E6%95%88%E7%8E%87-UVM%20Runtime%20Cmdline%E5%92%8CVCS%E5%88%86%E5%9D%97%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在实际验证过程中，仿真效率是我们常常面临的挑战之一。尤其是在修改代码时，明明只改动了一个文件（例如，在testcase中增加了一行打印），但编译却需要重新编译整个工程中的所有文件。这种情况不仅浪费了大量时间，还显著降低了仿真效率。为了应对这种问题，常用的解决方法有两种：充分利用UVM的runtime cmdline传递参数机制和增量编译。然而，即使采用了增量编译，仿真效率仍然受到一定影响，因为仿真器无法准确识别哪些文件已经被修改。那么，是否有其他方法可以进一步提高仿真效率呢？答案是：[分块编译（Partition Compile）]。本文将详细介绍这两种方法及其优缺点，特别是分块编译如何作为增量编译的一种有效补充。<a><span id="more"></span></a></p></blockquote><h2 id="1-充分利用UVM的runtime-cmdline传递参数机制"><a href="#1-充分利用UVM的runtime-cmdline传递参数机制" class="headerlink" title="1. 充分利用UVM的runtime cmdline传递参数机制"></a><a>1. 充分利用UVM的runtime cmdline传递参数机制</a></h2><p>在UVM中，我们可以通过命令行动态地传递参数，而不必重新编译代码。这对于提高仿真效率非常重要，因为每次修改UVM相关参数时，都可以避免重新编译整个项目。</p><p>比如，在测试过程中，我们可以使用命令行来动态修改UVM的相关参数，如<code>UVM_TESTNAME</code>、<code>UVM_VERBOSITY</code>等，这样就能在运行时直接影响UVM环境的行为，而不需要重新编译源代码。具体来说，只需在仿真启动时通过命令行传递这些参数，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs +UVM_TESTNAME=test1 +UVM_VERBOSITY=UVM_LOW</span><br></pre></td></tr></table></figure><p>这种方式不仅避免了不必要的重新编译，还能更灵活地调整仿真设置，提高工作效率。</p><h2 id="2-增量编译"><a href="#2-增量编译" class="headerlink" title="2. 增量编译"></a><a>2. 增量编译</a></h2><p>增量编译是提升仿真效率的另一种常用方法。它的理想情况是：只有修改过的文件需要重新编译，而未修改的文件则跳过编译。通过这种方式，我们可以显著减少编译时间。</p><p>在VCS中，增量编译可以通过添加<code>-Mupdate</code>参数来启用。该参数允许仿真器检测文件是否发生了修改，只有修改过的文件才会被重新编译。然而，实际使用中，我们发现即使启用了增量编译，仿真器依然会重新编译一些未修改的文件。这是因为仿真器的优化能力还不够，无法准确识别哪些文件被修改了。</p><h2 id="3-VCS分块编译（Partition-Compile）"><a href="#3-VCS分块编译（Partition-Compile）" class="headerlink" title="3. VCS分块编译（Partition Compile）"></a><a>3. VCS分块编译（Partition Compile）</a></h2><p>为了进一步提高仿真效率，VCS提供了一种名为<strong>分块编译（Partition Compile）</strong>的方法。分块编译的核心思想是将整个工程中的文件划分为多个独立的“块”，只有当某个块中的文件被修改时，才会重新编译该块中的文件。通过这种方式，我们可以减少每次编译所需处理的文件数量，从而提高仿真效率。</p><h3 id="分块编译的基本原理"><a href="#分块编译的基本原理" class="headerlink" title="分块编译的基本原理"></a>分块编译的基本原理</h3><p>分块编译的本质是将代码拆分成若干个独立的块，每个块都包含一组相关的文件。只有当某个块中的文件发生变化时，仿真器才会重新编译该块。而在其他块中没有修改的文件则不会被重新编译。因此，通过合理划分这些块，我们可以减少编译的范围，从而提高效率。</p><p>然而，分块编译的精细程度需要在“精细”和“高效”之间找到一个平衡。如果将文件拆分得过细，仿真器需要处理的块会增多，从而消耗更多的系统时间；如果块划分过粗，又可能导致重新编译的文件过多。因此，在块分割的粒度上，需要根据实际情况进行调节。</p><h3 id="VCS分块编译的实现"><a href="#VCS分块编译的实现" class="headerlink" title="VCS分块编译的实现"></a>VCS分块编译的实现</h3><p>在VCS中，我们可以通过添加<code>-partcomp</code>参数来启用分块编译功能。具体的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs -partcomp</span><br></pre></td></tr></table></figure><p>此外，VCS还支持自动划分Partition的大小和数量，可以通过以下选项来指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs -partcomp=autopart_[low|medium|high]</span><br></pre></td></tr></table></figure><p>这三个选项分别对应不同的分块粒度（低、中、高），一般情况下可以使用<a>默认设置</a>，不必手动调整。</p><ul><li>添加<code>-pcmakeprof</code>把编译过程中的每一步所花费的时间做分析打印，并在编译日志的结尾进行输出，这样方便比较不同编译参数所花费的编译时间的区别。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs -pcmakeprof</span><br></pre></td></tr></table></figure><h4 id="纵向分析：VCS仿真流程"><a href="#纵向分析：VCS仿真流程" class="headerlink" title="纵向分析：VCS仿真流程"></a>纵向分析：VCS仿真流程</h4><table><thead><tr><th>阶段</th><th>描述</th><th>作用&#x2F;功能</th></tr></thead><tbody><tr><td><strong>Parsing</strong></td><td>解析过程，读取文件并进行语法分析。</td><td>将Verilog&#x2F;SystemVerilog源代码转换为仿真器可以理解的格式，检查语法和结构的正确性。</td></tr><tr><td><strong>_Elabcom</strong></td><td>编译文件生成过程，生成提供给Verdi解析的编译文件（需要<code>-kdb</code>选项）。</td><td>生成仿真器调试信息，供Verdi等工具解析和调试。</td></tr><tr><td><strong>Compiling</strong></td><td>编译过程，检查语法错误并生成中间二进制文件。</td><td>检查Verilog&#x2F;SystemVerilog代码中的语法错误，并生成Elaboration阶段可以识别的二进制文件。</td></tr><tr><td><strong>Elaboration</strong></td><td>精化过程，计算模块的参数值，处理模块的绑定关系，生成最终可执行文件<code>simv</code>。</td><td>根据设计层次结构计算参数，处理模块绑定关系，生成最终的可执行仿真文件<code>simv</code>。</td></tr></tbody></table><h4 id="横向分析：VCS仿真性能指标"><a href="#横向分析：VCS仿真性能指标" class="headerlink" title="横向分析：VCS仿真性能指标"></a>横向分析：VCS仿真性能指标</h4><table><thead><tr><th>性能指标</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td><strong>Real time</strong></td><td>程序从开始到结束的总时间。</td><td>仿真程序执行的真实时间，包括所有计算、I&#x2F;O操作等。</td></tr><tr><td><strong>User time</strong></td><td>程序在用户模式下的CPU耗时。</td><td>仿真程序在执行用户代码时消耗的CPU时间。通常与程序逻辑的复杂度相关。</td></tr><tr><td><strong>Sys time</strong></td><td>程序在内核模式下的CPU耗时。</td><td>仿真程序在执行系统调用、I&#x2F;O操作等内核级任务时消耗的CPU时间。</td></tr><tr><td><strong>Virt</strong></td><td>程序的虚拟内存空间大小。</td><td>仿真程序的虚拟内存空间大小，包括所有可访问的内存地址空间。</td></tr><tr><td><strong>Res</strong></td><td>程序已映射到物理内存的部分。</td><td>程序在物理内存中占用的实际空间。</td></tr><tr><td><strong>Shr</strong></td><td>程序占用的共享内存大小。</td><td>仿真程序占用的共享内存区域，多个进程可能会访问这些内存。</td></tr></tbody></table><h3 id="手动指定Partition"><a href="#手动指定Partition" class="headerlink" title="手动指定Partition"></a>手动指定Partition</h3><p>如果需要更精细的控制，我们还可以手动指定Partition。通过在VCS编译命令中指定<code>-top topcfg</code>选项，可以指定特定的配置文件，并在该配置文件中定义Partition。示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcs -partcomp -top topcfg topcfg.v</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/16/cUY6sTmnyQdZoXR.png" alt="image-20241116134607941"></p><ul><li><code>-top</code>后面跟的topcfg根据我的实测是topcfg中的<code>config_name</code></li></ul><p>在<code>topcfg.v</code>文件中，我们可以定义具体的Partition，示例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">config</span> topcfg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">design</span>    apb_tb;</span><br><span class="line">  partition <span class="keyword">package</span> uvm_pkg;</span><br><span class="line">  partition <span class="keyword">package</span> svt_amba_uvm_pkg;</span><br><span class="line">  partition <span class="keyword">package</span> svt_uvm_pkg;</span><br><span class="line">  partition <span class="keyword">package</span> apb_pkg;</span><br><span class="line">  <span class="comment">// partition instance apb_tb.u_dut;</span></span><br><span class="line">  <span class="comment">// default liblist DEFAULT;</span></span><br><span class="line">  <span class="comment">// partition cell module_name;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endconfig</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们将<code>apb_tb</code>、<code>uvm_pkg</code>、<code>svt_amba_uvm_pkg</code>、<code>svt_uvm_pkg</code>和<code>apb_pkg</code>分别定义为独立的Partition，当其中的文件发生变化时，仿真器只会重新编译相应的Partition。(其中apb_tb是我顶层的tb, instance是例化的dut, cell是module_name)</p><h3 id="Partition并行参数"><a href="#Partition并行参数" class="headerlink" title="Partition并行参数"></a>Partition并行参数</h3><ul><li><code>-fastpartcomp=j4</code>中的 <code>j4</code> 表示使用 4 个并行作业来执行编译任务。并行处理的优势在于，它可以同时处理多个部分，大大提高编译效率（j和4之间没有空白字符）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-fastpartcomp=j4</span><br></pre></td></tr></table></figure><h2 id="避免在-unit空间导入package：增量编译效率的陷阱"><a href="#避免在-unit空间导入package：增量编译效率的陷阱" class="headerlink" title="避免在$unit空间导入package：增量编译效率的陷阱"></a><a>避免在$unit空间导入package：增量编译效率的陷阱</a></h2><p>在进行Verilog&#x2F;SystemVerilog的设计和验证时，增量编译是一项至关重要的技术，它能够有效减少编译时间，提高仿真效率。然而，在实际使用过程中，我们需要注意一些常见的陷阱，特别是在项目的$unit空间中导入package（包）这一做法。</p><h3 id="什么是-unit空间？"><a href="#什么是-unit空间？" class="headerlink" title="什么是$unit空间？"></a>什么是$unit空间？</h3><p>在Verilog&#x2F;SystemVerilog中，<code>$unit</code>空间指的是<strong>顶层全局空间</strong>，通常是<code>package...endpackage</code>、<code>module...endmodule</code>、<code>interface...endinterface</code>之外的部分。简单来说，$unit层次是指那些不属于具体模块、接口或包的地方。它包括了定义文件级别的各种设置或行为的区域。</p><h3 id="为什么避免在-unit空间导入package？"><a href="#为什么避免在-unit空间导入package？" class="headerlink" title="为什么避免在$unit空间导入package？"></a>为什么避免在$unit空间导入package？</h3><p>导入<code>package</code>的本意是为了共享其中的定义、类型、函数等，避免重复编写相同的代码。但如果我们在$unit空间导入<code>package</code>，会带来以下几个问题：</p><ol><li><strong>增量编译失效</strong>： 当我们在$unit空间导入一个<code>package</code>时，这个<code>package</code>的变动将直接影响到所有使用它的模块和文件。假设这个<code>package</code>被多次导入，那么在后续修改<code>package</code>中的内容时，仿真器无法精确识别哪些文件发生了变化，进而会导致整个项目的重新编译。这使得增量编译失效，浪费大量编译时间。</li><li><strong>影响编译效率</strong>： 增量编译的核心优势是<strong>仅编译修改过的部分文件</strong>，但如果我们在$unit空间导入<code>package</code>，会使得修改<code>package</code>文件后，所有依赖它的模块都会被重新编译。对于大型项目来说，这种情况会显著降低编译效率，特别是当<code>package</code>较为庞大或被多个模块依赖时，编译时间会显著增加。</li><li><strong>影响项目的可维护性</strong>： 在$unit空间中随意导入<code>package</code>，可能导致代码结构混乱，依赖关系复杂，难以追溯具体依赖了哪些文件，增加了调试和维护的难度。</li></ol><h3 id="如何避免这个问题？"><a href="#如何避免这个问题？" class="headerlink" title="如何避免这个问题？"></a>如何避免这个问题？</h3><p>为了避免在$unit空间导入<code>package</code>带来的问题，我们可以采取以下策略：</p><ol><li><strong>局部导入<code>package</code></strong><br> 最好将<code>package</code>的导入限制在具体的模块、接口或包内部。这样只有在需要的地方才会导入，而不会影响到整个项目的编译。</li><li><strong>合理划分文件结构</strong><br> 尽量将公共包和模块隔离开来，在独立的文件夹中进行管理，避免包的导入影响到顶层全局空间。</li><li><strong>避免频繁修改核心<code>package</code></strong><br> 如果<code>package</code>中包含了多个常用的定义或函数，尽量减少对其结构的修改。若确实需要修改，尽量使这些修改局部化，避免频繁改动全局影响。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h2><p>提高仿真效率是每个验证工程师都希望解决的问题，尤其是在大型项目中，避免不必要的全量编译可以显著节省时间。通过UVM的runtime cmdline参数机制，我们可以避免重新编译整个项目，只通过命令行传递参数来修改UVM环境；通过增量编译，我们可以减少不必要的文件编译，但仍会遇到仿真器无法精确识别文件修改的情况；而VCS的分块编译则是一种有效的补充方法，它通过将文件划分为多个独立的块，减少每次需要重新编译的文件数量，从而提高仿真效率。</p><p>在实际工作中，我们可以根据项目的需求和仿真器的表现来选择合适的优化方式。分块编译作为增量编译的补充，将会在提高效率和缩短仿真时间方面发挥重要作用。</p>]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> VCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DV </tag>
            
            <tag> VCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的基本命令</title>
      <link href="/2024/11/10/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/11/10/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Git 是一种分布式版本控制系统，广泛用于管理代码和文件的版本控制。它允许多个开发者在同一项目中并行工作，同时跟踪每个文件的修改历史，方便合并更改并解决冲突。<a><span id="more"></span></a></p></blockquote><h3 id="Git-基础操作"><a href="#Git-基础操作" class="headerlink" title="Git 基础操作"></a><a>Git 基础操作</a></h3><h4 id="1-初始化-Git-仓库"><a href="#1-初始化-Git-仓库" class="headerlink" title="1. 初始化 Git 仓库"></a>1. <strong>初始化 Git 仓库</strong></h4><p>在一个文件夹中初始化一个新的 Git 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这将创建一个 <code>.git</code> 文件夹，Git 用它来跟踪版本和历史。</p><h4 id="2-克隆现有仓库"><a href="#2-克隆现有仓库" class="headerlink" title="2. 克隆现有仓库"></a>2. <strong>克隆现有仓库</strong></h4><p>克隆一个现有的 Git 仓库到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repository_url&gt;</span><br></pre></td></tr></table></figure><p>例如，克隆 GitHub 上的一个仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/repository.git</span><br></pre></td></tr></table></figure><h4 id="3-检查-Git-状态"><a href="#3-检查-Git-状态" class="headerlink" title="3. 检查 Git 状态"></a>3. <strong>检查 Git 状态</strong></h4><p>查看当前工作目录和暂存区的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>它会显示哪些文件已更改、哪些文件未被跟踪、哪些文件已暂存等信息。</p><h4 id="4-添加文件到暂存区"><a href="#4-添加文件到暂存区" class="headerlink" title="4. 添加文件到暂存区"></a>4. <strong>添加文件到暂存区</strong></h4><p>将文件添加到暂存区（准备提交）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>如果要添加所有更改的文件，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h4 id="5-提交更改"><a href="#5-提交更改" class="headerlink" title="5. 提交更改"></a>5. <strong>提交更改</strong></h4><p>提交暂存区的更改到本地仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Commit message&quot;</span></span><br></pre></td></tr></table></figure><p><code>-m</code> 后面是提交信息，简要描述这次提交的内容。</p><h4 id="6-查看提交历史"><a href="#6-查看提交历史" class="headerlink" title="6. 查看提交历史"></a>6. <strong>查看提交历史</strong></h4><p>查看提交的历史记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>这将列出所有提交，包括提交ID、作者、提交时间和提交信息。</p><h4 id="7-创建和切换分支"><a href="#7-创建和切换分支" class="headerlink" title="7. 创建和切换分支"></a>7. <strong>创建和切换分支</strong></h4><p>创建并切换到一个新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>切换到已有分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><h4 id="8-合并分支"><a href="#8-合并分支" class="headerlink" title="8. 合并分支"></a>8. <strong>合并分支</strong></h4><p>将另一个分支的更改合并到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>如果存在冲突，Git 会提示你手动解决冲突。</p><h4 id="9-推送更改到远程仓库"><a href="#9-推送更改到远程仓库" class="headerlink" title="9. 推送更改到远程仓库"></a>9. <strong>推送更改到远程仓库</strong></h4><p>将本地提交推送到远程仓库（如 GitHub）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>如果是第一次推送一个新分支，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><h4 id="10-拉取远程仓库的更改"><a href="#10-拉取远程仓库的更改" class="headerlink" title="10. 拉取远程仓库的更改"></a>10. <strong>拉取远程仓库的更改</strong></h4><p>获取远程仓库的更新并合并到本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>这相当于 <code>git fetch</code> 和 <code>git merge</code> 的组合。</p><h4 id="11-删除分支"><a href="#11-删除分支" class="headerlink" title="11. 删除分支"></a>11. <strong>删除分支</strong></h4><p>删除本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>删除远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><h4 id="12-查看差异"><a href="#12-查看差异" class="headerlink" title="12. 查看差异"></a>12. <strong>查看差异</strong></h4><p>查看文件修改的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>查看已暂存的更改与最后提交的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><h4 id="13-撤销更改"><a href="#13-撤销更改" class="headerlink" title="13. 撤销更改"></a>13. <strong>撤销更改</strong></h4><p>如果想撤销对某个文件的修改，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>如果想撤销暂存区的更改（还没有提交的更改）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>要完全撤销最后一次提交的更改（保留文件，但撤销提交）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><h4 id="14-解决冲突"><a href="#14-解决冲突" class="headerlink" title="14. 解决冲突"></a>14. <strong>解决冲突</strong></h4><p>如果在合并过程中出现冲突，Git 会标记出冲突部分。你需要手动解决冲突，然后使用以下命令标记冲突已解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;conflicted_file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><h4 id="15-标签"><a href="#15-标签" class="headerlink" title="15. 标签"></a>15. <strong>标签</strong></h4><p>标签用于标记重要的提交，例如版本发布：</p><p>创建一个标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><p>查看所有标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>推送标签到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><h3 id="Git-常用配置"><a href="#Git-常用配置" class="headerlink" title="Git 常用配置"></a><a>Git 常用配置</a></h3><h4 id="1-配置用户名和邮箱-设置-Git-用户名和邮箱是必要的，它们将用于提交记录"><a href="#1-配置用户名和邮箱-设置-Git-用户名和邮箱是必要的，它们将用于提交记录" class="headerlink" title="1. 配置用户名和邮箱 设置 Git 用户名和邮箱是必要的，它们将用于提交记录"></a>1. <strong>配置用户名和邮箱</strong> 设置 Git 用户名和邮箱是必要的，它们将用于提交记录</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-查看配置-查看-Git-配置信息"><a href="#2-查看配置-查看-Git-配置信息" class="headerlink" title="2. 查看配置 查看 Git 配置信息"></a>2. <strong>查看配置</strong> 查看 Git 配置信息</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h4 id="3-全局忽略文件-创建一个-gitignore-文件，列出不需要版本控制的文件或文件夹。例"><a href="#3-全局忽略文件-创建一个-gitignore-文件，列出不需要版本控制的文件或文件夹。例" class="headerlink" title="3. 全局忽略文件 创建一个 .gitignore 文件，列出不需要版本控制的文件或文件夹。例"></a>3. <strong>全局忽略文件</strong> 创建一个 <code>.gitignore</code> 文件，列出不需要版本控制的文件或文件夹。例</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.log</span><br><span class="line">*.tmp</span><br><span class="line">/node_modules</span><br></pre></td></tr></table></figure><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a><a>其他常用命令</a></h3><ul><li><p><strong>查看本地仓库信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p><strong>添加远程仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;repository_url&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>查看分支信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p><strong>查看文件历史</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;filename&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-rm-的常用用法"><a href="#git-rm-的常用用法" class="headerlink" title="git rm 的常用用法"></a><a><code>git rm</code> 的常用用法</a></h3><h4 id="1-删除一个文件-删除一个文件，并将删除操作加入暂存区，准备提交"><a href="#1-删除一个文件-删除一个文件，并将删除操作加入暂存区，准备提交" class="headerlink" title="1. 删除一个文件 删除一个文件，并将删除操作加入暂存区，准备提交"></a>1. <strong>删除一个文件</strong> 删除一个文件，并将删除操作加入暂存区，准备提交</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>   例如，删除文件 <code>example.txt</code>：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> example.txt</span><br></pre></td></tr></table></figure><p>   删除后，Git 会把这个删除操作添加到暂存区，在下一次提交时会从 Git 仓库中移除该文件。</p><h4 id="2-删除一个文件并保留本地文件-如果你希望删除-Git-仓库中的文件，但保留工作目录中的文件（即本地文件不被删除），可以使用-cached-选项"><a href="#2-删除一个文件并保留本地文件-如果你希望删除-Git-仓库中的文件，但保留工作目录中的文件（即本地文件不被删除），可以使用-cached-选项" class="headerlink" title="2. 删除一个文件并保留本地文件 如果你希望删除 Git 仓库中的文件，但保留工作目录中的文件（即本地文件不被删除），可以使用 --cached 选项"></a>2. <strong>删除一个文件并保留本地文件</strong> 如果你希望删除 Git 仓库中的文件，但保留工作目录中的文件（即本地文件不被删除），可以使用 <code>--cached</code> 选项</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>   例如，删除文件 <code>example.txt</code> 但保留本地副本：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached example.txt</span><br></pre></td></tr></table></figure><p>   这样做会将文件从 Git 仓库中删除，但文件仍然会保留在你的工作目录中。此操作常用于从 Git 仓库中移除敏感文件（如 <code>.env</code> 文件），但不希望本地文件被删除。</p><h4 id="3-删除多个文件-你可以使用通配符或多个文件路径来一次性删除多个文件"><a href="#3-删除多个文件-你可以使用通配符或多个文件路径来一次性删除多个文件" class="headerlink" title="3. 删除多个文件 你可以使用通配符或多个文件路径来一次性删除多个文件"></a>3. <strong>删除多个文件</strong> 你可以使用通配符或多个文件路径来一次性删除多个文件</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;</span><br></pre></td></tr></table></figure><p>   或者使用通配符删除所有 <code>.log</code> 文件：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> *.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><h4 id="4-删除目录-如果你想删除整个目录及其内容，可以使用-r-选项"><a href="#4-删除目录-如果你想删除整个目录及其内容，可以使用-r-选项" class="headerlink" title="4. 删除目录 如果你想删除整个目录及其内容，可以使用 -r 选项"></a>4. <strong>删除目录</strong> 如果你想删除整个目录及其内容，可以使用 <code>-r</code> 选项</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r &lt;directory_name&gt;</span><br></pre></td></tr></table></figure><p>   这将递归删除目录及其所有文件和子目录。</p><h3 id="删除文件后的操作"><a href="#删除文件后的操作" class="headerlink" title="删除文件后的操作"></a>删除文件后的操作</h3><p>在删除文件后，你需要提交更改以将删除操作记录到 Git 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Removed unnecessary files&quot;</span></span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="1-删除一个文件并提交：-假设你要删除文件-test-txt"><a href="#1-删除一个文件并提交：-假设你要删除文件-test-txt" class="headerlink" title="1. 删除一个文件并提交： 假设你要删除文件 test.txt"></a>1. <strong>删除一个文件并提交：</strong> 假设你要删除文件 <code>test.txt</code></h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> test.txt</span><br><span class="line">git commit -m <span class="string">&quot;Remove test.txt&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-仅从-Git-仓库中删除文件，保留本地文件：-假设你想从-Git-中删除文件-secrets-txt，但保留本地文件"><a href="#2-仅从-Git-仓库中删除文件，保留本地文件：-假设你想从-Git-中删除文件-secrets-txt，但保留本地文件" class="headerlink" title="2. 仅从 Git 仓库中删除文件，保留本地文件： 假设你想从 Git 中删除文件 secrets.txt，但保留本地文件"></a>2. <strong>仅从 Git 仓库中删除文件，保留本地文件：</strong> 假设你想从 Git 中删除文件 <code>secrets.txt</code>，但保留本地文件</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached secrets.txt</span><br><span class="line">git commit -m <span class="string">&quot;Remove secrets.txt from the repository&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR科普-DDR时序参数</title>
      <link href="/2024/11/09/DDR/DDR%E7%A7%91%E6%99%AE-DDR%E6%97%B6%E5%BA%8F%E5%8F%82%E6%95%B0/"/>
      <url>/2024/11/09/DDR/DDR%E7%A7%91%E6%99%AE-DDR%E6%97%B6%E5%BA%8F%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>PHY手册中ddr的时序参数和uMCTL2的时序参数，以及时序图 <a><span id="more"></span></a></p></blockquote><p><img src="https://s2.loli.net/2024/11/09/QqsBcDPluRTxv18.png" alt="image-20241109195426624"></p><p><img src="https://s2.loli.net/2024/11/09/9WQcjHUTiREafx2.png" alt="image-20241109195501856"></p><p><img src="https://s2.loli.net/2024/11/09/D65cQ2H1bajEIen.png" alt="image-20241109215911953"></p><p><img src="https://s2.loli.net/2024/11/09/6Sg9TQrobNyWqC4.png" alt="image-20241109215933399"></p><p><img src="https://s2.loli.net/2024/11/09/hBkjFDf4qbVRWEd.png" alt="image-20241109201316288"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR进阶-Refresh命令</title>
      <link href="/2024/11/09/DDR/DDR%E8%BF%9B%E9%98%B6-Refresh%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/11/09/DDR/DDR%E8%BF%9B%E9%98%B6-Refresh%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自刷新（Self-Refresh） 和 自动刷新（Auto-Refresh） 是两种用来维持内存中数据的有效性、避免丢失数据的刷新模式。这两种模式的主要区别在于刷新操作的控制方式和适用场景。<a><span id="more"></span></a></p></blockquote><h3 id="1-自动刷新（Auto-Refresh）"><a href="#1-自动刷新（Auto-Refresh）" class="headerlink" title="1. 自动刷新（Auto-Refresh）"></a>1. <strong>自动刷新（Auto-Refresh）</strong></h3><p><strong>自动刷新</strong>模式是由<strong>内存控制器</strong>负责周期性地发出<strong>刷新命令</strong>，以确保内存的每个行在特定的时间间隔内都被刷新一次。这个刷新是全局的，控制器会自动在适当的时候发出刷新命令来刷新内存中所有的行。</p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><ul><li>在<strong>Auto-Refresh</strong>模式下，内存控制器会周期性地向DDR内存发出刷新命令（<code>REF</code>命令）。</li><li>刷新命令的频率是固定的，通常由内存的工作频率决定（例如每64ms刷新一次）。</li><li>控制器在这个过程中会根据设定的<strong>刷新周期</strong>，遍历内存的所有bank，并逐行刷新每个bank中的数据。</li><li>自动刷新的过程是由内存控制器统一调度和管理的，用户不需要手动干预。</li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>自动刷新</strong>的过程由内存控制器完全控制，通常在内存空闲时进行，不影响其他内存操作。</li><li>需要消耗内存带宽，因为刷新操作会占用内存的访问周期。</li><li>适合对实时性要求较高的系统，能够确保内存的数据保持有效，且不需要额外的控制。</li></ul><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li><strong>自动刷新</strong>通常用于普通的内存工作模式，在大多数DDR系统中，自动刷新是默认的刷新模式。</li><li>它是由内存控制器在后台管理的，因此适用于无需额外干预的应用。</li></ul><h3 id="2-自刷新（Self-Refresh）"><a href="#2-自刷新（Self-Refresh）" class="headerlink" title="2. 自刷新（Self-Refresh）"></a>2. <strong>自刷新（Self-Refresh）</strong></h3><p><strong>自刷新</strong>模式是一种低功耗模式，在这种模式下，<strong>内存本身</strong>会自动刷新其数据，而不需要依赖内存控制器。自刷新模式通常是在系统进入低功耗状态时使用的模式。</p><h4 id="工作原理：-1"><a href="#工作原理：-1" class="headerlink" title="工作原理："></a>工作原理：</h4><ul><li>在<strong>Self-Refresh</strong>模式下，内存会自主执行刷新操作，不依赖外部控制器发出刷新命令。</li><li>在进入自刷新模式之前，内存控制器会通过发出一个特定的命令将内存置于自刷新状态。</li><li>进入自刷新模式后，DDR内存会定期刷新自身的行（通常按照特定的时间间隔，如64ms），确保数据不丢失。</li><li>内存控制器在自刷新模式下会进入低功耗状态，基本不参与内存的读写操作，直到退出自刷新模式。</li></ul><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>自刷新</strong>模式是一种<strong>低功耗模式</strong>，它使得DDR内存在不需要外部控制的情况下自动进行数据刷新。</li><li>当内存处于<strong>自刷新</strong>模式时，内存控制器不进行数据读写操作，仅仅等待系统恢复或外部控制器的重新启动。</li><li>内存在此模式下自动刷新，而无需占用主系统的带宽，适合系统在待机或低功耗模式下运行时使用。</li></ul><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li><strong>自刷新</strong>模式常用于设备进入低功耗状态时，例如移动设备（智能手机、平板等）在待机时，或服务器系统在闲置时。</li><li>适用于不需要高频繁内存访问的场合，例如系统休眠期间。</li></ul><h3 id="3-两者的区别总结"><a href="#3-两者的区别总结" class="headerlink" title="3. 两者的区别总结"></a>3. <strong>两者的区别总结</strong></h3><table><thead><tr><th>特性</th><th><strong>Auto-Refresh</strong></th><th><strong>Self-Refresh</strong></th></tr></thead><tbody><tr><td><strong>控制方式</strong></td><td>内存控制器发出刷新命令</td><td>内存自主管理刷新</td></tr><tr><td><strong>功耗</strong></td><td>较高（因为控制器持续运行）</td><td>低功耗（内存自主刷新）</td></tr><tr><td><strong>适用场景</strong></td><td>系统正常运行时，需要保证数据有效性时</td><td>系统低功耗模式下，保持数据有效性</td></tr><tr><td><strong>刷新频率</strong></td><td>固定频率（通常是每64ms刷新一次）</td><td>自动刷新，内存自主控制刷新周期</td></tr><tr><td><strong>内存带宽占用</strong></td><td>会占用内存带宽进行刷新操作</td><td>无需占用带宽，因为刷新由内存自己进行</td></tr><tr><td><strong>是否需要控制器干预</strong></td><td>需要控制器发出刷新命令</td><td>不需要控制器，内存自动完成刷新</td></tr></tbody></table><h3 id="4-自刷新与自动刷新结合使用"><a href="#4-自刷新与自动刷新结合使用" class="headerlink" title="4. 自刷新与自动刷新结合使用"></a>4. <strong>自刷新与自动刷新结合使用</strong></h3><p>在某些复杂的DDR系统中，<strong>自刷新</strong>和<strong>自动刷新</strong>可能会结合使用。例如，当系统处于待机状态时，内存可能会切换到<strong>自刷新模式</strong>以减少功耗，但当系统恢复到活跃状态时，内存控制器又会重新启用<strong>自动刷新模式</strong>，以保证内存数据始终有效。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>自动刷新</strong>是内存控制器定期发出刷新命令来刷新内存数据，确保数据保持有效。</li><li><strong>自刷新</strong>是内存本身独立进行刷新操作，适用于系统处于低功耗模式时。</li><li>自刷新通常用于降低功耗，而自动刷新是确保内存数据完整性和有效性的常规操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQS漂移检测与补偿</title>
      <link href="/2024/11/09/DDR/DQS%E6%BC%82%E7%A7%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A1%A5%E5%81%BF/"/>
      <url>/2024/11/09/DDR/DQS%E6%BC%82%E7%A7%BB%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A1%A5%E5%81%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DQS（Data Strobe）是DDR内存系统中的关键时钟信号，其准确性对数据传输至关重要。在DDR内存系统中，DQS信号的漂移会导致数据读取的错误，因此需要监测并补偿漂移。<a><span id="more"></span></a></p></blockquote><h3 id="1-DQS漂移检测和补偿的概述"><a href="#1-DQS漂移检测和补偿的概述" class="headerlink" title="1. DQS漂移检测和补偿的概述"></a>1. <strong>DQS漂移检测和补偿的概述</strong></h3><p>除了标准的DQS门控LCDL VT补偿外，DDR IP提供了一种可选的功能，用于检测和补偿来自DDR IP内部以及外部（包括SDRAM）的漂移。其基本原理是通过采样进入的读取DQS#信号与门控信号，并持续追踪这些采样值是否发生变化。</p><h3 id="2-门控信号和DQS-信号采样"><a href="#2-门控信号和DQS-信号采样" class="headerlink" title="2. 门控信号和DQS#信号采样"></a>2. <strong>门控信号和DQS#信号采样</strong></h3><ul><li>设计中使用两个门控信号，之间有一个小的可编程延迟（通过<code>DTCR1.RDLVLGDIFF</code>设置）。这两个信号会在DQS#信号的上升沿两侧采样。</li><li>如果没有漂移，两个门控信号的采样值应该分别是0和1（即在DQS信号的上升沿一侧为0，另一侧为1）。</li><li>如果两个门控信号都采样到0或1，表明DQS信号相对于门控信号发生了漂移。采样值的变化指示了漂移的方向，PUB（PHY控制单元）可以根据此信息调整门控信号的位置。</li></ul><h3 id="3-漂移检测和补偿启用"><a href="#3-漂移检测和补偿启用" class="headerlink" title="3. 漂移检测和补偿启用"></a>3. <strong>漂移检测和补偿启用</strong></h3><ul><li>DQS漂移检测和补偿功能通过设置<code>DQSDR0.DFTDTEN</code>来启用。</li><li>需要注意的是，只有两种补偿机制中的一种可以启用：<code>DQSDR0.DFTDTEN</code> 和 <code>DXnGCR3.RGLVT</code> 是互斥的，即不能同时启用。</li></ul><h3 id="4-漂移补偿过程"><a href="#4-漂移补偿过程" class="headerlink" title="4. 漂移补偿过程"></a>4. <strong>漂移补偿过程</strong></h3><ul><li>当PUB检测到漂移时，它会通过标准的DFI PHY更新协议通知控制器，要求DFI总线空闲以便启动漂移补偿机制。</li><li>控制器确认PHY更新后，PUB会执行<code>DQSDR0.DFTUPDRD</code>虚拟读取，以获取最新的漂移状态。</li><li>由于漂移检测机制无法检测漂移的幅度（尤其是在任务模式下进行DFI事务时），PUB需要通过增量补偿例程来确定漂移的幅度。具体做法是，PUB会发出一系列的虚拟读取操作（dummy reads），每次检测到漂移时，PUB会通过<code>DQSDR1.DFTDLY</code>调整延迟来进行补偿。直到不再检测到漂移为止。</li><li>如果<code>DQSDR0.DFTUPDRD</code>设置为0，则PUB只会执行单步漂移补偿，调整数字延迟线的<code>DQSDR0.DTDLY</code>延迟，这时不会在漂移补偿阶段实际确定漂移幅度。</li></ul><h3 id="5-漂移检测的特殊情形"><a href="#5-漂移检测的特殊情形" class="headerlink" title="5. 漂移检测的特殊情形"></a>5. <strong>漂移检测的特殊情形</strong></h3><p>漂移检测可能无法在某些情况下进行，尤其是在没有读取事务或门控信号没有变化时。为此，PUB提供了以下机制：</p><ul><li><strong>无读取场景</strong>：如果控制器长时间没有对某个rank执行读取操作，PUB会在<code>DQSDR1.DFTRDIDLC × DQSDR1.DFTRDIDLF</code>时钟周期后请求PHY更新，执行<code>DQSDR0.DFTIDLRD</code>虚拟读取。</li><li><strong>连续读取场景</strong>：如果控制器发送了连续的读取操作，PUB会在<code>DQSDR1.DFTRDB2BC * DQSDR1.DFTRDB2BF</code>时钟周期后请求PHY更新，执行<code>DQSDR1.DFTB2BRD</code>虚拟读取。</li></ul><h3 id="6-DQS漂移逻辑"><a href="#6-DQS漂移逻辑" class="headerlink" title="6. DQS漂移逻辑"></a>6. <strong>DQS漂移逻辑</strong></h3><p>DQS漂移逻辑只使用<strong>bank 0</strong>进行虚拟读取操作，并根据银行0的状态来决定是否需要发出激活命令。</p><h3 id="7-防止不必要的漂移检测和补偿"><a href="#7-防止不必要的漂移检测和补偿" class="headerlink" title="7. 防止不必要的漂移检测和补偿"></a>7. <strong>防止不必要的漂移检测和补偿</strong></h3><p>为了防止DQS漂移检测和&#x2F;或补偿的过度触发，PUB提供了两个可编程功能来调节漂移检测的频率和补偿：</p><ul><li><strong>漂移监测周期</strong>（<code>DQSDR2.DFTMNTPRD</code>）：指定两次漂移监测事件之间的最小时钟周期数。它控制PUB采样PHY宏的漂移状态的频率。此功能可以用于避免频繁的漂移检测，特别是当系统的漂移更像是抖动（jitter）而非单向漂移时。</li><li><strong>漂移阈值</strong>（<code>DQSDR2.DFTTHRSH</code>）：指定在同一方向上连续检测到的最小漂移次数，只有当检测到该阈值的漂移时，PUB才会认为漂移是有效的。如果漂移方向发生反转，计数器会重置。此功能用于避免频繁检测和&#x2F;或补偿周期性的漂移。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h2><p>这段话描述了<strong>DQS漂移的检测与补偿机制</strong>，该机制用于确保DQS信号在面临电压温度变化和系统状态变化时仍然稳定可靠。关键的步骤包括通过门控信号采样DQS信号来检测漂移，以及根据漂移的方向来调整DQS门控位置。PUB通过增量补偿和虚拟读取操作来调整系统，以消除漂移的影响。为了避免频繁的补偿，系统提供了可编程功能来控制漂移监测的周期和阈值，从而确保系统的效率和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> VT compensation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQS门控信号的延迟补偿</title>
      <link href="/2024/11/09/DDR/DQS%E9%97%A8%E6%8E%A7%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF/"/>
      <url>/2024/11/09/DDR/DQS%E9%97%A8%E6%8E%A7%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在电压温度（VT）变化和SDRAM本身的漂移情况下如何确保DQS信号的稳定性和准确性。<a><span id="more"></span></a></p></blockquote><h3 id="1-DQS门控位置漂移的问题"><a href="#1-DQS门控位置漂移的问题" class="headerlink" title="1. DQS门控位置漂移的问题"></a>1. <strong>DQS门控位置漂移的问题</strong></h3><p>一旦DQS的门控位置被训练出来，DQS相对于门控信号的位置可能会发生漂移。这个漂移会减小最初训练的门控位置的裕量。漂移的原因可能是电压和温度的变化（VT变化），或者是来自SDRAM的未定义漂移。</p><h3 id="2-DQS门控信号路径匹配"><a href="#2-DQS门控信号路径匹配" class="headerlink" title="2. DQS门控信号路径匹配"></a>2. <strong>DQS门控信号路径匹配</strong></h3><p>在DDR IP模块内部，DQS门控信号的路径延迟是通过设计与读命令路径和读DQS路径的延迟总和匹配来完成的。为了确保DQS门控信号与读取数据路径的延迟相匹配，设计使用了与读取命令路径相同的时序和组件来驱动DQS门控信号。这是通过将门控信号返回到PHY并通过专用的I&#x2F;O接口（即PDQSG）传递来实现的，从而确保DQS门控信号的路径延迟与读DQS路径相匹配。</p><h3 id="3-匹配的关键组件"><a href="#3-匹配的关键组件" class="headerlink" title="3. 匹配的关键组件"></a>3. <strong>匹配的关键组件</strong></h3><p>在DDR IP中，门控I&#x2F;O（PDQSG）使用与读取命令I&#x2F;O驱动（PDDRIO）和读取DQS I&#x2F;O接收器（PDIFF）相同的驱动器和接收器组件。设计的目标是通过使用这些相同的组件，确保DQS门控信号路径的延迟与读命令和读DQS路径的延迟一致，从而自我补偿电压温度变化的影响。</p><h3 id="4-LCDL（延迟线）对VT变化的影响"><a href="#4-LCDL（延迟线）对VT变化的影响" class="headerlink" title="4. LCDL（延迟线）对VT变化的影响"></a>4. <strong>LCDL（延迟线）对VT变化的影响</strong></h3><p>DQS门控信号路径中唯一没有与读取命令&#x2F;数据路径匹配的主要组件是DQS门控LCDL（Delay Line）。这个延迟线负责确定门控信号的精细延迟。电压和温度变化会影响这个延迟线产生的延迟。因此，为了补偿这个效应，DDR IP使用延迟线VT补偿功能来补偿所有延迟线的VT变化。</p><h3 id="5-LCDL-VT补偿"><a href="#5-LCDL-VT补偿" class="headerlink" title="5. LCDL VT补偿"></a>5. <strong>LCDL VT补偿</strong></h3><p>对于DQS门控LCDL的延迟补偿，可以通过设置<code>DXnGCR3.RGLVT</code>来启用该功能。这意味着，当系统中的SDRAM没有显著的外部漂移时，标准的LCDL基于VT补偿机制就足够应对DQS信号与最初训练的门控信号之间的相对漂移。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>DQS信号的精确门控位置对DDR内存的性能至关重要。然而，DQS信号的延迟路径可能会受到电压和温度变化的影响，导致最初训练的门控位置出现漂移。为了避免这种漂移影响，DDR IP通过精确匹配DQS门控路径和读取数据路径的延迟来实现自我补偿。然而，DQS门控路径中的LCDL（延迟线）并不与其他路径完全匹配，因此必须通过一个专门的VT补偿机制来补偿由于VT变化带来的影响。这种补偿机制可以通过启用<code>DXnGCR3.RGLVT</code>功能来实现，从而保持DQS门控信号的稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> VT compensation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFI-update</title>
      <link href="/2024/11/09/DDR/DFI-update/"/>
      <url>/2024/11/09/DDR/DFI-update/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如何通过寄存器配置DQS漂移检测和补偿逻辑与其他如DDL和阻抗VT漂移的更新进行交互。<a><span id="more"></span></a></p></blockquote><h2 id="与其他PHY-控制器更新的交互"><a href="#与其他PHY-控制器更新的交互" class="headerlink" title="与其他PHY&#x2F;控制器更新的交互"></a><a><strong>与其他PHY&#x2F;控制器更新的交互</strong></a></h2><p>除了由<strong>DQS漂移检测和补偿逻辑</strong>生成的PHY更新请求外，<strong>DQS漂移</strong>还可以在以下情况下进行检测和补偿：</p><ol><li>由<strong>DDL</strong>（数字延迟线）或<strong>阻抗VT漂移</strong>生成的PHY更新。</li><li><strong>控制器更新</strong>期间。</li></ol><p>这类配置通过寄存器位<strong>DQSDR1.PUDFTUP</strong>和<strong>DQSDR1.CUDFTUP</strong>来完成。可以使用<strong>DQSDR0.PUDFTRD</strong>和<strong>DQSDR0.CUDFTRD</strong>寄存器位配置在这些外部更新期间的可选虚拟读操作的次数。</p><p>同样，<strong>DDL</strong>和<strong>阻抗VT漂移</strong>也可以配置为在最初由<strong>DQS漂移</strong>触发的PHY更新期间进行更新。此配置通过寄存器位<strong>DQSDR0.DFTDDLUP</strong>和<strong>DQSDR0.DFTZQUP</strong>来实现。</p><h3 id="关键点解释"><a href="#关键点解释" class="headerlink" title="关键点解释"></a>关键点解释</h3><ul><li><strong>DQS漂移</strong>：指的是数据时钟信号（DQS）由于温度、电压变化或其他因素引起的漂移，需要进行实时检测和补偿。</li><li><strong>DDL和阻抗VT漂移的交互</strong>：在<strong>DQS漂移</strong>的检测和补偿过程中，<strong>DDL</strong>和<strong>阻抗VT漂移</strong>的影响也可能同时被考虑，并在相关的PHY更新周期内进行补偿。</li><li><strong>第三方更新</strong>：指的是在非直接由<strong>DQS漂移</strong>引发的PHY更新中，进行的例如<strong>DDL</strong>或<strong>阻抗补偿</strong>更新，采用了虚拟读操作来确保更新的时序一致性。</li></ul><h3 id="配置寄存器位的功能："><a href="#配置寄存器位的功能：" class="headerlink" title="配置寄存器位的功能："></a>配置寄存器位的功能：</h3><ol><li><strong>DQSDR1.PUDFTUP</strong> 和 <strong>DQSDR1.CUDFTUP</strong>：这些寄存器位用于配置在<strong>DDL</strong>或<strong>阻抗VT漂移</strong>补偿期间的PHY更新。</li><li><strong>DQSDR0.PUDFTRD</strong> 和 <strong>DQSDR0.CUDFTRD</strong>：这些寄存器位用于配置在这些外部更新期间的虚拟读操作次数。</li><li><strong>DQSDR0.DFTDDLUP</strong> 和 <strong>DQSDR0.DFTZQUP</strong>：这些寄存器位用于配置<strong>DDL</strong>和<strong>阻抗VT漂移</strong>是否可以在由<strong>DQS漂移</strong>引发的PHY更新期间进行更新。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> DFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture-Register Programming for Impedance Calibration</title>
      <link href="/2024/11/09/DDR/PUB%20Architecture-Register%20Programming%20for%20Impedance%20Calibration/"/>
      <url>/2024/11/09/DDR/PUB%20Architecture-Register%20Programming%20for%20Impedance%20Calibration/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.2.4.1，在DDR内存初始化和正常运行过程中，用户可以通过配置不同的寄存器来调整和控制阻抗校准的行为。<a><span id="more"></span></a></p></blockquote><h3 id="1-初始化期间的默认寄存器设置"><a href="#1-初始化期间的默认寄存器设置" class="headerlink" title="1. 初始化期间的默认寄存器设置"></a>1. <strong>初始化期间的默认寄存器设置</strong></h3><ul><li><strong>PIR.ZCALBYP</strong> 设置为‘0’，表示在初始化过程中不会绕过阻抗校准。</li><li><strong>ZQCR.PGWAIT</strong> 设置为 <code>0x5</code>，这个值适应控制时钟（ctl_clk）频率为 333 MHz 至 400 MHz。</li><li><strong>ZQCR.ZCALT</strong> 设置为 <code>0x1</code>，表示启用始终开启的背景校准。</li><li><strong>ZQCR.AVGEN</strong> 设置为 <code>0</code>，表示禁用代码平均，这样可以加快校准的完成时间。</li><li><strong>ZQCR.IODLMT</strong> 设置为 <code>0x2</code>，表示当电压温度漂移（VT drift）导致与之前校准的代码相差2个代码时，会触发VT相关的更新请求。</li><li><strong>ZQnPR.PU_ODT_ONLY</strong> 设置为 <code>0</code>，禁用LPDDR3&#x2F;DDR4的只上拉ODT（On Die Termination）校准。</li><li><strong>ZQnPR.ZPROG_ASYM_DRV_PU</strong> 和 <strong>ZQnPR.ZPROG_ASYM_DRV_PD</strong> 设置为 <code>0xb</code>，这两个寄存器用于设置典型工作条件下的上拉和下拉驱动强度校准代码。</li><li><strong>ZQnPR.ZPROG_PU_ODT_ONLY</strong> 设置为 <code>0x7</code>，设置上拉终端（ODT）仅进行校准的代码。</li><li><strong>ZQnPR.PU_DRV_ADJUST</strong> 和 <strong>ZQnPR.PD_DRV_ADJUST</strong> 设置为 <code>0x0</code>，表示禁用上拉和下拉驱动强度调整。</li><li><strong>ZQnPR.ODT_ZDEN</strong> 设置为 <code>0</code>，禁用终端代码覆盖功能。</li><li><strong>ZQnPR.DRV_ZDEN</strong> 设置为 <code>0</code>，禁用驱动强度代码覆盖功能。</li><li><strong>ZQnPR.ZSEGBYP</strong> 设置为 <code>0</code>，禁用校准段旁路。</li></ul><h3 id="2-初始化后的正常操作期间"><a href="#2-初始化后的正常操作期间" class="headerlink" title="2. 初始化后的正常操作期间"></a>2. <strong>初始化后的正常操作期间</strong></h3><ul><li>初始化后的默认设置保持不变，除了以下几点：<ul><li><strong>ZQCR.AVGEN</strong> 被设置为 <code>1</code>，表示始终启用代码平均（对校准过程进行多次平均，减少误差）。</li></ul></li></ul><h3 id="3-用户期望的编程模式"><a href="#3-用户期望的编程模式" class="headerlink" title="3. 用户期望的编程模式"></a>3. <strong>用户期望的编程模式</strong></h3><h4 id="a-非对称驱动强度校准（LPDDR3-DDR4）"><a href="#a-非对称驱动强度校准（LPDDR3-DDR4）" class="headerlink" title="a. 非对称驱动强度校准（LPDDR3&#x2F;DDR4）"></a>a. <strong>非对称驱动强度校准（LPDDR3&#x2F;DDR4）</strong></h4><ul><li>设置 <strong>ZQnPR.PU_ODT_ONLY</strong> 为 <code>1</code>，表示启用只上拉ODT校准。</li><li>设置 <strong>ZQnPR.ZPROG_ASYM_DRV_PU</strong> 为所需的上拉驱动强度分频比。</li><li>设置 <strong>ZQnPR.ZPROG_ASYM_DRV_PD</strong> 为所需的下拉驱动强度分频比。</li></ul><h4 id="b-仅上拉ODT校准（LPDDR3-DDR4）"><a href="#b-仅上拉ODT校准（LPDDR3-DDR4）" class="headerlink" title="b. 仅上拉ODT校准（LPDDR3&#x2F;DDR4）"></a>b. <strong>仅上拉ODT校准（LPDDR3&#x2F;DDR4）</strong></h4><ul><li>设置 <strong>ZQnPR.PU_ODT_ONLY</strong> 为 <code>1</code>，表示启用仅上拉ODT校准。</li><li>设置 <strong>ZQnPR.ZPROG_PU_ODT_ONLY</strong> 为所需的上拉终端分频比。</li></ul><h4 id="c-在非默认ctl-clk频率下进行校准（默认频率为400-MHz）"><a href="#c-在非默认ctl-clk频率下进行校准（默认频率为400-MHz）" class="headerlink" title="c. 在非默认ctl_clk频率下进行校准（默认频率为400 MHz）"></a>c. <strong>在非默认ctl_clk频率下进行校准（默认频率为400 MHz）</strong></h4><ul><li>根据操作频率设置 <strong>ZQCR.PGWAIT</strong> 寄存器的等待周期数。</li></ul><h4 id="d-控制校准重复（默认是背景模式，始终开启校准）"><a href="#d-控制校准重复（默认是背景模式，始终开启校准）" class="headerlink" title="d. 控制校准重复（默认是背景模式，始终开启校准）"></a>d. <strong>控制校准重复（默认是背景模式，始终开启校准）</strong></h4><ul><li><p>设置<code>ZQCR.ZCALT</code>为所需的校准粒度模式。</p><ul><li>注意：某些模式需要触发DFI控制&#x2F;PHY更新才能继续校准。</li></ul></li></ul><h4 id="e-代码平均控制"><a href="#e-代码平均控制" class="headerlink" title="e. 代码平均控制"></a>e. <strong>代码平均控制</strong></h4><ul><li><p>设置 <strong>ZQCR.AVGEN</strong> 为 <code>1</code> 启用代码平均，或设置为 <code>0</code> 禁用代码平均。</p></li><li><p>设置 <code>ZQCR.AVGMAX</code>来控制平均轮次数量。</p><ul><li>注：该值越大，校准时间越长。</li></ul></li></ul><h4 id="f-驱动强度调整"><a href="#f-驱动强度调整" class="headerlink" title="f. 驱动强度调整"></a>f. <strong>驱动强度调整</strong></h4><ul><li>设置 <strong>ZQnPR.PU_DRV_ADJUST</strong> 为所需的上拉驱动强度调整。</li><li>设置 <strong>ZQnPR.PD_DRV_ADJUST</strong> 为所需的下拉驱动强度调整。</li></ul><h4 id="g-代码覆盖"><a href="#g-代码覆盖" class="headerlink" title="g. 代码覆盖"></a>g. <strong>代码覆盖</strong></h4><ul><li><p>设置 <strong>ZQnPR.ODT_ZDEN</strong> 为 <code>1</code>，启用终端代码覆盖功能。</p></li><li><p>设置 <strong>ZQnPR.DRV_ZDEN</strong> 为 <code>1</code>，启用驱动强度代码覆盖功能。</p></li><li><p>设置 <strong>ZQnDR.ZDATA[15:0]</strong> 为所需的驱动强度ZCTRL代码，强制软件在该段上使用。</p></li><li><p>设置 <code>ZQnDR.ZDATA[31:16]</code>为所需的终端ZCTRL代码，强制软件在该段上使用。</p><ul><li>注：这些值需要由软件更新，并且不会进行VT补偿。</li></ul></li></ul><h4 id="h-校准旁路"><a href="#h-校准旁路" class="headerlink" title="h. 校准旁路"></a>h. <strong>校准旁路</strong></h4><ul><li>设置 <strong>PIR.ZCALBYP</strong> 为 <code>1</code>，这将禁用自动校准和VT补偿。</li></ul><h3 id="4-VREF使用设置"><a href="#4-VREF使用设置" class="headerlink" title="4. VREF使用设置"></a>4. <strong>VREF使用设置</strong></h3><ul><li><strong>IOVCR1.ZQREFIEN</strong> 设置为 ‘1’，表示使用内部生成的VREF为PZQ单元提供电压参考（VREF）。</li><li><strong>IOVCR1.ZQREFPEN</strong> 设置为 ‘0’，表示不使用外部VREF。</li><li>如果使用外部VREF，需将 <strong>IOVCR1.ZQREFIEN</strong> 设置为 ‘0’，并将 <strong>IOVCR1.ZQREFPEN</strong> 设置为 ‘1’。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段文档详细描述了<strong>阻抗校准</strong>过程中的寄存器编程，涵盖了从初始化到正常操作阶段，如何通过设置不同的寄存器来控制阻抗校准的细节，包括校准模式、驱动强度、代码覆盖、校准频率、平均控制等方面的内容。通过灵活的编程配置，用户可以根据实际需求调整DDR的性能和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> PUB </tag>
            
            <tag> Impedance Calibration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture-Delay Line VT Drift Detection and Compensation</title>
      <link href="/2024/11/09/DDR/PUB%20Architecture-Delay%20Line%20VT%20Drift%20Detection%20and%20Compensation/"/>
      <url>/2024/11/09/DDR/PUB%20Architecture-Delay%20Line%20VT%20Drift%20Detection%20and%20Compensation/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.2.3， 如何通过MDL来检测电压和温度漂移，并使用补偿逻辑调整延迟线的延迟值。这种机制确保了即使在电压和温度发生变化的情况下，DDR 系统中的延迟线依然保持精确的时序，从而保证数据传输的稳定性和可靠性。<a><span id="more"></span></a></p></blockquote><h3 id="1-VT漂移补偿逻辑"><a href="#1-VT漂移补偿逻辑" class="headerlink" title="1. VT漂移补偿逻辑"></a>1. <strong>VT漂移补偿逻辑</strong></h3><ul><li><strong>VT漂移</strong>指的是由于 <strong>电压</strong> 和 <strong>温度</strong> 的变化，导致电路中的电气特性发生漂移或变化。由于延迟线（DDL）通常是基于电压和温度变化工作的，必须进行补偿，确保它们的延迟精度保持不变。</li><li>在 <strong>PUB（PHY Initialization Block）</strong> 中，有一个 <strong>VT漂移补偿逻辑</strong>，它的作用是 <strong>调节每条延迟线的延迟选择输入值</strong>，确保延迟时间保持不变，即使在电压和温度发生变化时。</li></ul><h3 id="2-主延迟线-MDL-的作用"><a href="#2-主延迟线-MDL-的作用" class="headerlink" title="2. 主延迟线 (MDL) 的作用"></a>2. <strong>主延迟线 (MDL) 的作用</strong></h3><ul><li><strong>MDL（Master Delay Line）</strong> 是一种主延迟线，用来监测 <strong>DDR 时钟周期</strong> 的变化。MDL 会 <strong>持续测量 DDR 时钟周期</strong>，并通过测量结果调整其他延迟线的延迟值。</li><li><strong>MDL 定期测量 DDR 时钟周期</strong>，并且将测量结果存储为以下几个值：<ul><li>初始的 MDL 校准周期 (<code>MDLinit</code>)</li><li>上一个 MDL 校准周期</li><li>当前的 MDL 校准周期</li></ul></li></ul><h3 id="3-延迟线的温度和电压补偿"><a href="#3-延迟线的温度和电压补偿" class="headerlink" title="3. 延迟线的温度和电压补偿"></a>3. <strong>延迟线的温度和电压补偿</strong></h3><ul><li>当 <strong>电压</strong> 或 <strong>温度</strong> 发生变化时，MDL 会检测到 DDR 时钟周期的漂移，并将漂移值传递给其他延迟线的 <strong>状态机</strong>，在“<strong>更新期</strong>”内进行调整。这些更新期是通过在<strong>PGCR0</strong>寄存器中写入数据来控制的。</li><li>在 <strong>初始校准</strong> 后，MDL 会定期进行周期测量，并将每次新的测量值记录下来。如果新测量的 MDL 校准周期和上一个周期的差异超过了某个阈值（该阈值由 <strong><code>PGCR6.DLDLMT</code></strong> 控制），就会触发 <strong>VT漂移状态</strong>，并通过 <strong>vt_drift 输出引脚</strong> 表示。</li></ul><h3 id="4-补偿公式"><a href="#4-补偿公式" class="headerlink" title="4. 补偿公式"></a>4. <strong>补偿公式</strong></h3><ul><li><p>每条延迟线的补偿是通过以下公式来实现的：</p><p>  $$<br>D L_{\text {new }}&#x3D;\frac{M D L_{\text {new }}}{M D L_{\text {init }}} \times D L_{\text {init }}<br>$$</p><ul><li><strong>MDL_init</strong>：初始的 MDL 校准周期</li><li><strong>MDL_new</strong>：当前（新的）MDL 校准周期</li><li><strong>DL_init</strong>：延迟线的初始延迟选择值（在 MDL_init 时的值）</li><li><strong>DL_new</strong>：经过 VT 补偿后的延迟线新值</li></ul><p>通过这个公式，系统可以根据 MDL 的新周期来调整延迟线的选择值，从而补偿电压和温度漂移的影响。</p></li></ul><h3 id="5-补偿计算过程"><a href="#5-补偿计算过程" class="headerlink" title="5. 补偿计算过程"></a>5. <strong>补偿计算过程</strong></h3><ul><li>当检测到 <strong>MDL周期的变化</strong> 时，VT 补偿逻辑会被触发。补偿逻辑会根据 MDL 的新校准周期计算一个 <strong>补偿后的延迟线值</strong>，并将该值存储在 <strong>每条延迟线的本地寄存器</strong> 中。</li><li>但是，这个补偿值并不会立即应用到延迟线。<strong>只有在 PUB（PHY Initialization Block）服务 VT 更新时</strong>，这个补偿值才会被应用到延迟线中。</li></ul><h3 id="6-关键点总结"><a href="#6-关键点总结" class="headerlink" title="6. 关键点总结"></a>6. <strong>关键点总结</strong></h3><ul><li><strong>VT漂移补偿</strong>：用于弥补由于电压和温度变化导致的延迟线性能漂移。</li><li><strong>MDL 作为基准</strong>：主延迟线 MDL 定期测量 DDR 时钟周期，并用其校准其他延迟线。</li><li><strong>周期比较</strong>：如果新的 MDL 校准周期与上一个周期的差异超过设定阈值，VT 漂移状态会被触发，表明需要进行补偿。</li><li><strong>补偿公式</strong>：通过使用 MDL 的校准周期差异，计算每个延迟线的补偿值，以调整其延迟。</li><li><strong>寄存器更新</strong>：补偿后的延迟值会被存储在本地寄存器中，并且只有在 VT 更新期间才会被应用到延迟线。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> VT compensation </tag>
            
            <tag> PUB </tag>
            
            <tag> DDL </tag>
            
            <tag> MDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture-Impedance Calibration</title>
      <link href="/2024/11/09/DDR/PUB%20Architecture-Impedance%20Calibration/"/>
      <url>/2024/11/09/DDR/PUB%20Architecture-Impedance%20Calibration/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.2.4，DDR接口中的阻抗校准过程，涉及如何通过控制逻辑、专用的单元和总线来实现对SSTL（Stub Series Terminated Logic）信号的阻抗调节。这个过程确保信号在传输过程中能维持正确的阻抗，以优化信号的质量和稳定性。<a><span id="more"></span></a></p></blockquote><h2 id="阻抗控制器模块"><a href="#阻抗控制器模块" class="headerlink" title="阻抗控制器模块"></a><a><strong>阻抗控制器模块</strong></a></h2><p>提供了必需的阻抗控制功能，能够使<strong>功能性SSTL单元</strong>的<strong>可编程</strong>和<strong>PVT补偿</strong>的<strong>ODT（On-Die Termination，片内终端）</strong>以及<strong>输出阻抗</strong>得到有效控制。具体包括以下几种控制选项：</p><h4 id="1-Sample-based-tracking-of-RZQ："><a href="#1-Sample-based-tracking-of-RZQ：" class="headerlink" title="1. Sample-based tracking of RZQ："></a>1. <strong>Sample-based tracking of RZQ</strong>：</h4><ul><li><strong>RZQ</strong> 是指阻抗参考电阻值，通常与DDR总线的阻抗匹配有关。该功能表示通过采样来跟踪RZQ的变化，以保证SSTL接口的稳定信号传输，并使阻抗回路电路能够在较低功耗下稳定运行。</li></ul><h4 id="2-Impedance-code-override："><a href="#2-Impedance-code-override：" class="headerlink" title="2. Impedance code override："></a>2. <strong>Impedance code override</strong>：</h4><ul><li>该功能允许直接控制阻抗代码（Impedance Code）。这些阻抗代码是用来控制SSTL信号的驱动阻抗的，这项功能使得用户能够绕过自动控制，手动设置阻抗，从而有更多的灵活性和控制。</li></ul><h4 id="3-Impedance-code-output："><a href="#3-Impedance-code-output：" class="headerlink" title="3. Impedance code output："></a>3. <strong>Impedance code output</strong>：</h4><ul><li>通过输出阻抗代码，用户可以监控控制回路的操作情况。这意味着可以实时查看当前控制回路在调节阻抗时的状态，帮助调试和优化。</li></ul><h4 id="4-Programmable-divide-on-the-input-clock-signal："><a href="#4-Programmable-divide-on-the-input-clock-signal：" class="headerlink" title="4. Programmable divide on the input clock signal："></a>4. <strong>Programmable divide on the input clock signal</strong>：</h4><ul><li>这项功能提供了一个可编程的分频器，可以在输入时钟信号上进行分频。通过分频，可以实现稳定的操作，适应不同频率范围的输入时钟。这对于支持高频信号的稳定性非常重要。</li></ul><h4 id="5-Automatic-sequencing-for-independent-impedance-compensation："><a href="#5-Automatic-sequencing-for-independent-impedance-compensation：" class="headerlink" title="5. Automatic sequencing for independent impedance compensation："></a>5. <strong>Automatic sequencing for independent impedance compensation</strong>：</h4><ul><li>该功能会自动进行独立的阻抗补偿，针对四个不同的阻抗元素进行逐一补偿：<ul><li>ODT（On-Die Termination）拉高&#x2F;拉低电阻</li><li>输出阻抗拉高&#x2F;拉低</li></ul></li><li>这样可以确保每个阻抗元素在不同操作状态下都能得到最佳的匹配与补偿。</li></ul><h4 id="6-Programmable-asymmetric-drive-strength-and-pullup-only-termination-calibration："><a href="#6-Programmable-asymmetric-drive-strength-and-pullup-only-termination-calibration：" class="headerlink" title="6. Programmable asymmetric drive strength and pullup-only termination calibration："></a>6. <strong>Programmable asymmetric drive strength and pullup-only termination calibration</strong>：</h4><ul><li>支持可编程的不对称驱动强度调节和仅拉高终止校准。也就是说，用户可以对SSTL接口的驱动强度进行调节，以应对不同的负载需求。</li></ul><h4 id="7-VT-drift-detection-and-automatic-DFI-update-request："><a href="#7-VT-drift-detection-and-automatic-DFI-update-request：" class="headerlink" title="7. VT drift detection and automatic DFI update request："></a>7. <strong>VT drift detection and automatic DFI update request</strong>：</h4><ul><li><strong>VT drift</strong>（电压漂移）指的是随着温度、工艺变化，电压参考点可能发生的漂移。这项功能能够检测到电压漂移，并在发现漂移时，自动发出DFI（DDR接口）更新请求，以调整内存接口的配置，确保系统始终稳定运行。</li></ul><h4 id="8-Code-averaging-support-for-smoother-code-transitions："><a href="#8-Code-averaging-support-for-smoother-code-transitions：" class="headerlink" title="8. Code averaging support for smoother code transitions："></a>8. <strong>Code averaging support for smoother code transitions</strong>：</h4><ul><li>支持代码平均（Code Averaging），用来平滑阻抗代码的过渡。这意味着当阻抗代码变化时，变化的过程会更为平滑，从而避免因突变引起的信号不稳定。</li></ul><h4 id="9-Programmable-drive-strength-adjustment-for-pullup-drive-and-pulldown-drive-strengths："><a href="#9-Programmable-drive-strength-adjustment-for-pullup-drive-and-pulldown-drive-strengths：" class="headerlink" title="9. Programmable drive strength adjustment for pullup drive and pulldown drive strengths："></a>9. <strong>Programmable drive strength adjustment for pullup drive and pulldown drive strengths</strong>：</h4><ul><li>允许用户调节驱动强度，分别调整拉高和拉低的驱动强度。这使得在不同的工作条件下，SSTL接口能够适应各种负载，从而优化信号的完整性和稳定性。</li></ul><p><img src="https://s2.loli.net/2024/11/09/eJG2RrbQ5IF1McU.png" alt="image-20241109184303118"></p><h3 id="关键组件和流程"><a href="#关键组件和流程" class="headerlink" title="关键组件和流程"></a>关键组件和流程</h3><h4 id="1-PZQ单元与PZCTRL单元的配合"><a href="#1-PZQ单元与PZCTRL单元的配合" class="headerlink" title="1. PZQ单元与PZCTRL单元的配合"></a>1. <strong>PZQ单元与PZCTRL单元的配合</strong></h4><ul><li>一个<strong>PZQ（Programmable Impedance）单元</strong>和一个<strong>PZCTRL单元</strong>可以用于一个或多个SSTL组，这些SSTL组需要独立的驱动阻抗和ODT（On-Die Termination，芯片内终端电阻）阻抗控制。</li><li>每个<strong>PZCTRL单元</strong>必须与一个<strong>PZQ单元</strong>配对使用，这两个单元的协作用于控制信号的阻抗。</li></ul><h4 id="2-PVSSQZB单元和ZIOH总线"><a href="#2-PVSSQZB单元和ZIOH总线" class="headerlink" title="2. PVSSQZB单元和ZIOH总线"></a>2. <strong>PVSSQZB单元和ZIOH总线</strong></h4><ul><li><strong>PVSSQZB单元</strong>用来创建一个独立的<strong>ZIOH总线段</strong>，专门用于阻抗校准。<strong>ZIOH总线</strong>是连接各个阻抗控制单元的总线，确保信号的正确传输。</li><li>在没有连接阻抗控制逻辑的接口段中，<strong>PVREF单元</strong>不能使用。这是为了避免信号干扰和不必要的电压参考误差。</li></ul><h4 id="3-阻抗校准触发与绕过"><a href="#3-阻抗校准触发与绕过" class="headerlink" title="3. 阻抗校准触发与绕过"></a>3. <strong>阻抗校准触发与绕过</strong></h4><ul><li>通过PIR寄存器的<strong>ZCALBYP位</strong>，可以随时绕过阻抗校准过程。</li><li>如果校准被绕过，那么阻抗需要在稍后的时间通过重新触发校准或直接编程控制寄存器<strong>ZQnDR</strong>来进行重新校准。</li></ul><h4 id="4-阻抗校准流程"><a href="#4-阻抗校准流程" class="headerlink" title="4. 阻抗校准流程"></a>4. <strong>阻抗校准流程</strong></h4><ul><li><p>一旦触发校准，阻抗校准逻辑会按照以下顺序依次校准四个阻抗元素：</p><ol><li><strong>输出阻抗拉低（pull-down）</strong></li><li><strong>输出阻抗拉高（pull-up）</strong></li><li><strong>ODT拉低（pull-down）</strong></li><li><strong>ODT拉高（pull-up）</strong></li></ol></li><li><p>对每个阻抗元素，阻抗控制逻辑会通过<strong>ZCTRL总线</strong>发送一个阻抗代码到<strong>PZCTRL单元</strong>，然后PZCTRL单元将这些数据进行编码并转换电平，传送到SSTL单元中的功能性I&#x2F;O单元和<strong>PZQ单元</strong>。</p></li></ul><h4 id="5-PZQ单元与外部电阻的匹配"><a href="#5-PZQ单元与外部电阻的匹配" class="headerlink" title="5. PZQ单元与外部电阻的匹配"></a>5. <strong>PZQ单元与外部电阻的匹配</strong></h4><ul><li><strong>PZQ单元</strong>接收到来自<strong>PZCTRL单元</strong>的控制代码，并与外部电阻进行比较，从而确定最佳的阻抗值。</li><li><strong>PZQ单元</strong>还接收到<strong>PUB</strong>（PHY控制器）的分频比（ZPROG），用于调整阻抗校准的精度。</li><li>当<strong>PZQ单元</strong>计算出阻抗匹配情况后，会将<strong>zcomp</strong>值反馈给阻抗控制逻辑，阻抗控制逻辑会根据反馈值更新控制代码，继续优化阻抗。</li></ul><h4 id="6-闭环控制"><a href="#6-闭环控制" class="headerlink" title="6. 闭环控制"></a>6. <strong>闭环控制</strong></h4><ul><li>阻抗控制过程是一个闭环控制系统。每次校准都会根据反馈信息调整阻抗代码，直到找到最匹配的阻抗值为止。</li><li>一旦一个阻抗元素的校准完成，逻辑会自动开始下一个阻抗元素的校准。</li></ul><h4 id="7-错误监控和完成状态"><a href="#7-错误监控和完成状态" class="headerlink" title="7. 错误监控和完成状态"></a>7. <strong>错误监控和完成状态</strong></h4><ul><li>在校准过程中，用户可以通过<strong>ZQnSR寄存器</strong>监控回路状态，检查是否有错误。</li><li>当所有四个阻抗元素的校准完成后，逻辑会在**PGSR[ZCDONE]**寄存器的**ZCDONE**位中标记“完成”状态，表示校准成功。</li></ul><h4 id="8-时钟控制"><a href="#8-时钟控制" class="headerlink" title="8. 时钟控制"></a>8. <strong>时钟控制</strong></h4><ul><li>校准逻辑使用<strong>PUB控制器时钟</strong>作为采样时钟来控制阻抗校准回路的操作。由于这个回路不需要高频操作，因此通常使用较低的时钟频率来保证稳定性。</li><li>该回路的频率比<strong>PUB时钟</strong>低得多，阻抗控制模块包含一个<strong>可编程时钟计数器</strong>，用于控制等待一定的时钟周期再进行采样。</li></ul><h4 id="9-背景运行与DFI更新"><a href="#9-背景运行与DFI更新" class="headerlink" title="9. 背景运行与DFI更新"></a>9. <strong>背景运行与DFI更新</strong></h4><ul><li>校准初始化完成后，阻抗校准会继续在后台运行，周期性地进行DFI控制和PHY更新，将更新后的VT（Voltage Threshold，电压阈值）代码传播到DDR接口上的I&#x2F;O单元。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这段描述的内容主要讲述了<strong>DDR接口阻抗校准的流程</strong>，以及如何通过一系列专用单元和总线实现对信号阻抗的精确调节。通过这个校准过程，信号的阻抗可以被精确地控制和优化，从而确保DDR接口能够稳定高效地工作。这个过程不仅考虑了不同工艺、电压和温度的变化，还确保了校准的反馈是闭环的，能够实时调整，最终达到最佳的阻抗匹配效果。</p><p><img src="https://s2.loli.net/2024/11/09/vdy18QaBkEmLHUY.png" alt="image-20241109184846343"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> PUB </tag>
            
            <tag> Impedance Calibration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR科普-信号反射</title>
      <link href="/2024/11/09/DDR/DDR%E7%A7%91%E6%99%AE-%E4%BF%A1%E5%8F%B7%E5%8F%8D%E5%B0%84/"/>
      <url>/2024/11/09/DDR/DDR%E7%A7%91%E6%99%AE-%E4%BF%A1%E5%8F%B7%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>信号反射是由于信号传输过程中遇到阻抗不匹配的情况，导致信号在传输线路上被部分或完全反射回源端的现象。信号反射可能导致信号质量下降，造成数据错误或通信中断。理解反射的原因，首先需要了解阻抗匹配的概念。<a><span id="more"></span></a></p></blockquote><h3 id="1-阻抗匹配的重要性"><a href="#1-阻抗匹配的重要性" class="headerlink" title="1. 阻抗匹配的重要性"></a>1. <strong>阻抗匹配的重要性</strong></h3><p>在信号传输过程中，信号需要沿着导线（比如电路板上的铜线或导线）传输。导线的特性阻抗（<strong>Zo</strong>）指的是信号沿导线传播时对电压和电流的响应。当信号从一个地方传播到另一个地方时，如果信号的源端、传输线和接收端的阻抗不匹配，就会发生反射。</p><h4 id="阻抗不匹配时的反射机制："><a href="#阻抗不匹配时的反射机制：" class="headerlink" title="阻抗不匹配时的反射机制："></a>阻抗不匹配时的反射机制：</h4><ul><li><strong>阻抗匹配</strong>：如果信号源的输出阻抗、传输线路的特性阻抗以及接收端的输入阻抗是相等的，那么信号会顺利地通过传输线路，几乎没有反射发生。</li><li><strong>阻抗不匹配</strong>：如果信号源的输出阻抗与传输线路的特性阻抗不同，或者传输线路的特性阻抗与接收端的输入阻抗不同，信号就会在接触到不匹配的阻抗时发生反射。</li></ul><h3 id="2-为什么会反射？"><a href="#2-为什么会反射？" class="headerlink" title="2. 为什么会反射？"></a>2. <strong>为什么会反射？</strong></h3><p>信号反射发生的原因是，信号遇到不同阻抗时会产生一种<strong>反射波</strong>，与原始信号方向相反。具体来说，信号遇到不匹配的阻抗时，会被部分地反射回去，同时另一部分会继续前进。</p><h4 id="反射的过程："><a href="#反射的过程：" class="headerlink" title="反射的过程："></a>反射的过程：</h4><ul><li>当信号通过传输线时，它的电流和电压会受到线路的特性阻抗影响。</li><li>如果传输线路的<strong>阻抗</strong>与信号源的<strong>输出阻抗</strong>或接收端的<strong>输入阻抗</strong>不同，信号的部分能量就会被反射回源端，产生反射信号。</li><li>反射波可能会干扰到原始信号，导致数据错误、时序问题或信号干扰。</li></ul><h3 id="3-反射会带来哪些问题？"><a href="#3-反射会带来哪些问题？" class="headerlink" title="3. 反射会带来哪些问题？"></a>3. <strong>反射会带来哪些问题？</strong></h3><ol><li><strong>信号失真</strong>：反射波与原始信号重叠，导致信号在接收端发生畸变，可能使信号变得模糊不清，从而产生错误的解码。</li><li><strong>时序问题</strong>：在高速信号传输中，反射可能导致信号的延迟，进而引发时序问题，特别是在同步电路中，导致数据丢失或错误。</li><li><strong>噪声增加</strong>：反射会在电路中引入不必要的噪声，影响电路的正常工作。</li></ol><h3 id="4-信号反射的常见原因"><a href="#4-信号反射的常见原因" class="headerlink" title="4. 信号反射的常见原因"></a>4. <strong>信号反射的常见原因</strong></h3><ul><li><strong>传输线的阻抗不匹配</strong>：如果电路板的走线设计不合理，传输线的阻抗与信号源或接收端的阻抗不匹配，就会发生反射。</li><li><strong>接头和连接器</strong>：在信号传输过程中，连接器或插座的接触不良、插头不正确或松动，都会导致阻抗不匹配，进而产生反射。</li><li><strong>不连续的线路</strong>：例如，信号线弯曲得太急或有不规则的变化，这些都可能导致局部的阻抗变化，进而产生反射。</li><li><strong>终端未连接或连接不当</strong>：如果传输线路没有正确的终端（即阻抗匹配），或者终端与线路的阻抗不匹配，也会导致反射。</li></ul><h3 id="5-如何避免信号反射？"><a href="#5-如何避免信号反射？" class="headerlink" title="5. 如何避免信号反射？"></a>5. <strong>如何避免信号反射？</strong></h3><ul><li><strong>阻抗匹配</strong>：最有效的方法是确保信号源、传输线路和接收端之间的阻抗是匹配的。这可以通过设计电路时选择合适的导线宽度、材料和布局来实现。</li><li><strong>使用终端电阻（ODT）</strong>：在信号传输线路的末端加入适当的电阻，确保终端阻抗与线路阻抗匹配。内存接口、SSTL标准和DDR接口常使用<strong>ODT</strong>（On-Die Termination）来实现阻抗匹配。</li><li><strong>避免信号线的急转弯</strong>：设计时避免信号线的急剧弯曲，保持较为平缓的线路走向，减少阻抗不连续的可能性。</li><li><strong>使用阻抗匹配的连接器</strong>：确保使用合适的连接器或插头，避免因连接不当而产生阻抗不匹配。</li></ul><h3 id="6-阻抗匹配的应用："><a href="#6-阻抗匹配的应用：" class="headerlink" title="6. 阻抗匹配的应用："></a>6. <strong>阻抗匹配的应用：</strong></h3><ul><li><strong>内存接口</strong>：如DDR内存中，阻抗匹配是确保信号稳定传输的关键，通常采用ODT（On-Die Termination）技术来实现。</li><li><strong>高速信号传输</strong>：例如，在PCIe、USB、HDMI等高速通信协议中，信号传输的阻抗匹配至关重要，反射会极大地影响数据传输速率和可靠性。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>信号反射的根本原因是阻抗不匹配，导致信号在传输过程中部分反射回源端。为了避免反射，必须确保信号源、传输线和接收端的阻抗匹配，设计时注意电路走线、使用合适的终端电阻等。通过这些方法，可以确保信号的完整性，提高系统的性能和可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR科普-ODT介绍</title>
      <link href="/2024/11/09/DDR/DDR%E7%A7%91%E6%99%AE-ODT%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/11/09/DDR/DDR%E7%A7%91%E6%99%AE-ODT%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ODT（On-Die Termination） 是一种在半导体芯片（尤其是内存芯片，如DDR SDRAM）中用于信号完整性和减少反射的技术。它的作用是提供一种终端电阻，通常通过内置的电阻网络实现，用来匹配信号线路的阻抗，确保信号的稳定传输。<span id="more"></span></p></blockquote><h2 id="ODT的工作原理"><a href="#ODT的工作原理" class="headerlink" title="ODT的工作原理"></a><a>ODT的工作原理</a></h2><h4 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. <strong>目的</strong></h4><ul><li>在高速信号传输中，尤其是大规模集成电路（如内存）中，信号在传输过程中可能会发生反射，这种反射会导致信号质量下降。ODT技术通过在信号线路终端提供一个匹配的阻抗，消除或减少信号反射，从而提高信号的完整性和系统的稳定性。</li></ul><h4 id="2-如何工作"><a href="#2-如何工作" class="headerlink" title="2. 如何工作"></a>2. <strong>如何工作</strong></h4><ul><li>ODT通过将终端电阻放置在芯片的I&#x2F;O端口（如内存芯片的DQS、DQ等数据线）上，以减少信号的反射。</li><li>ODT电阻通常会根据内存控制器的需求动态调节。例如，在数据传输期间，内存控制器可以启用ODT以进行有效的信号匹配，而在没有数据传输时，ODT可以被禁用以节省功耗。</li></ul><h4 id="3-ODT的类型："><a href="#3-ODT的类型：" class="headerlink" title="3. ODT的类型："></a>3. <strong>ODT的类型</strong>：</h4><ul><li><p>拉高（Pull-up）和拉低（Pull-down）终端：ODT可以通过两种方式进行配置：</p><ul><li><strong>拉高（Pull-up）</strong>：将信号线连接到VDD（电源电压）以增强信号的上升沿。</li><li><strong>拉低（Pull-down）</strong>：将信号线连接到地（GND）以增强信号的下降沿。</li></ul></li><li><p><strong>动态可编程ODT</strong>：在一些现代内存系统中，ODT的电阻值是可以动态调整的（例如根据工作频率、温度或其他条件），这种灵活性帮助系统在不同工作条件下优化信号传输。</p></li></ul><h4 id="4-优势："><a href="#4-优势：" class="headerlink" title="4. 优势："></a>4. <strong>优势</strong>：</h4><ul><li><strong>信号完整性</strong>：ODT能够减少信号反射和串扰，从而确保数据传输的准确性。</li><li><strong>功耗优化</strong>：通过在不需要的时候关闭ODT，可以减少功耗。</li><li><strong>高速操作</strong>：在高速DDR内存和其他高速I&#x2F;O接口中，ODT帮助信号在较高的频率下保持稳定。</li></ul><h4 id="5-常见应用："><a href="#5-常见应用：" class="headerlink" title="5. 常见应用："></a>5. <strong>常见应用</strong>：</h4><ul><li><strong>内存控制器</strong>：在DDR、LPDDR等内存标准中，ODT广泛应用于内存的读写过程中。</li><li><strong>高速数据总线</strong>：如SSTL、HSTL等标准，在高速数据传输中也会使用ODT技术。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h2><p>ODT技术是现代电子系统中用于提高信号质量、减少反射和优化功耗的重要技术。它通过在芯片内部集成电阻来终止信号线，从而实现信号的阻抗匹配，广泛应用于内存接口和其他高速I&#x2F;O接口中。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture-DRAM Command Unit(DCU)</title>
      <link href="/2024/11/06/DDR/PUB%20Architecture-DRAM%20Command%20Unit(DCU)/"/>
      <url>/2024/11/06/DDR/PUB%20Architecture-DRAM%20Command%20Unit(DCU)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.7，DRAM Command Unit (DCU) 是一个执行内存命令的模块，主要用于通过配置端口发出和控制 DRAM（动态随机存取存储器）命令以及 RDIMM（注册式双列直插内存模块）缓冲芯片的命令。它在 DRAM 系统中的作用是确保内存的初始化、调试和控制能够独立于内存控制器进行操作，提供灵活性和可调试性。<span id="more"></span></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a>简介</a></h2><h3 id="1-允许通过配置端口执行-DRAM-初始化"><a href="#1-允许通过配置端口执行-DRAM-初始化" class="headerlink" title="1. 允许通过配置端口执行 DRAM 初始化"></a>1. <strong>允许通过配置端口执行 DRAM 初始化</strong></h3><ul><li><strong>DRAM 初始化</strong> 是指在内存模块首次启用或复位时，需要进行的一系列操作，以确保内存正常工作。通常包括设置内存时序、刷新模式、存取模式等参数。</li><li><strong>配置端口</strong> 提供了一种通过软件来控制 DRAM 初始化过程的方法，而不需要依赖复杂的硬件控制逻辑。这意味着，用户可以通过编程接口向 DRAM 发出命令，从而实现初始化操作。这种方法使得内存初始化过程可以更加灵活和可控。</li><li>举个例子，执行 DRAM 初始化时，可能需要向内存发送预充电、行激活、读取、写入等命令，通过配置端口，开发人员可以精确控制这些命令的发送顺序和时序，确保内存的可靠性。</li></ul><h3 id="2-提供独立于控制器的统一硅调试和表征功能"><a href="#2-提供独立于控制器的统一硅调试和表征功能" class="headerlink" title="2. 提供独立于控制器的统一硅调试和表征功能"></a>2. <strong>提供独立于控制器的统一硅调试和表征功能</strong></h3><ul><li><strong>硅调试</strong> 和 <strong>表征</strong> 是指在开发过程中通过硬件和软件的协同工作来验证和测试芯片（尤其是内存子系统）的性能、时序、功耗等特性。</li><li>DCU 允许开发人员通过软件接口直接向 DRAM 发送命令进行调试，而不依赖于内存控制器（如内存控制器的硬件实现）。这样，即使没有完整的内存控制器，调试人员仍然可以独立地对内存进行测试和验证。</li><li>例如，可以使用 DCU 单元发送特定的命令流来验证 DRAM 在各种工作负载下的性能，或者进行精确的时序分析，确保内存与控制器之间的信号传输没有问题。</li></ul><h3 id="3-提供-DRAM-命令的通用软件执行机制"><a href="#3-提供-DRAM-命令的通用软件执行机制" class="headerlink" title="3. 提供 DRAM 命令的通用软件执行机制"></a>3. <strong>提供 DRAM 命令的通用软件执行机制</strong></h3><ul><li>DCU 不仅仅是一个硬件单元，它还支持通过软件来执行一系列 DRAM 命令。这使得开发人员能够通过编程方式控制内存的各个方面。</li><li>例如，软件可以通过 DCU 向 DRAM 发出常见的命令，如 <strong>读取</strong>（READ）、<strong>写入</strong>（WRITE）、<strong>预充电</strong>（PRECHARGE）、<strong>行激活</strong>（ACTIVATE）等。这样，开发人员可以在不同的工作模式下测试内存，验证功能是否正常。</li><li>这种通用软件执行的机制使得软件开发人员能够灵活地模拟和控制内存行为，方便进行不同的测试和操作。</li></ul><p><img src="https://s2.loli.net/2024/11/06/Qmv5cFEN6lDIjGn.png" alt="image-20241106235450107"></p><p><img src="https://s2.loli.net/2024/11/06/KPkgvjCd9mGOTEH.png" alt="image-20241106235724242"></p><h3 id="1-读取状态块-Read-Status-Block"><a href="#1-读取状态块-Read-Status-Block" class="headerlink" title="1. 读取状态块 (Read Status Block)"></a>1. <strong>读取状态块 (Read Status Block)</strong></h3><p>读取状态块是一个用于管理和跟踪内存读取操作状态的模块。它通常存储与读取操作相关的信息，例如读取请求是否完成、是否发生了错误等。在这个上下文中，读取状态块内有两个重要的缓存（期望缓存和读取缓存），它们共同工作来验证读取的数据是否符合预期。</p><h3 id="2-期望缓存-Expected-Cache"><a href="#2-期望缓存-Expected-Cache" class="headerlink" title="2. 期望缓存 (Expected Cache)"></a>2. <strong>期望缓存 (Expected Cache)</strong></h3><p>期望缓存用于存储系统预期从内存中读取的数据。当系统发起读取操作时，通常会预设一个预期值，并将其存入期望缓存中。然后，读取的数据将与这个期望值进行比较，用以验证读取的正确性。如果读取的数据与预期数据不符，则可能表明出现了错误或数据不一致。</p><h3 id="3-读取缓存-Read-Cache"><a href="#3-读取缓存-Read-Cache" class="headerlink" title="3. 读取缓存 (Read Cache)"></a>3. <strong>读取缓存 (Read Cache)</strong></h3><p>读取缓存存储实际从内存中读取的数据。它充当了内存与其他系统组件之间的缓冲区，用于缓存刚刚从内存中读取的数据。读取缓存中的数据会与期望缓存中的数据进行比较，从而确认数据是否符合预期。</p><h3 id="4-读取比较逻辑-Read-Compare-Logic"><a href="#4-读取比较逻辑-Read-Compare-Logic" class="headerlink" title="4. 读取比较逻辑 (Read Compare Logic)"></a>4. <strong>读取比较逻辑 (Read Compare Logic)</strong></h3><p>读取比较逻辑的作用是将读取缓存中的数据与期望缓存中的数据进行比较。这一步是确保数据一致性和正确性的重要环节。如果读取到的数据和期望的数据不匹配，系统可以根据需要触发错误或执行某些修复措施。这对于数据完整性检测和故障诊断至关重要。</p><h3 id="5-PUB引擎-PUB-Engines"><a href="#5-PUB引擎-PUB-Engines" class="headerlink" title="5. PUB引擎 (PUB Engines)"></a>5. <strong>PUB引擎 (PUB Engines)</strong></h3><p>PUB 引擎是系统中负责处理特定任务的模块或单元。文中提到，这些引擎与读取状态块共享期望缓存和读取缓存。也就是说，多个不同的处理单元或模块都可以访问这些缓存和比较逻辑，这样可以实现对内存读取的集中管理和处理。</p><h3 id="6-DCU寄存器-DCU-Registers"><a href="#6-DCU寄存器-DCU-Registers" class="headerlink" title="6. DCU寄存器 (DCU Registers)"></a>6. <strong>DCU寄存器 (DCU Registers)</strong></h3><p><strong>DCU</strong>（DRAM命令单元）是与内存控制器进行交互的模块，它负责发出命令、控制内存操作等。DCU寄存器是访问期望缓存和读取缓存的接口。换句话说，期望缓存和读取缓存的内容是通过DCU寄存器来读写的。开发人员或硬件组件可以通过操作这些寄存器来控制缓存中的数据或获取所需的信息。</p><h3 id="7-写入或读取DCU缓存-Writing-or-Reading-DCU-Caches"><a href="#7-写入或读取DCU缓存-Writing-or-Reading-DCU-Caches" class="headerlink" title="7. 写入或读取DCU缓存 (Writing or Reading DCU Caches)"></a>7. <strong>写入或读取DCU缓存 (Writing or Reading DCU Caches)</strong></h3><p>这部分描述了如何通过DCU寄存器来访问期望缓存和读取缓存。系统可以通过向这些寄存器写入数据来加载期望的值，或通过读取寄存器来获取实际读取的数据。通过这种方式，DCU为内存操作提供了灵活的控制接口，开发人员可以通过它来执行各种内存读取验证操作。</p><hr><h2 id="DCU命令（DCU-Commands）"><a href="#DCU命令（DCU-Commands）" class="headerlink" title="DCU命令（DCU Commands）"></a><a><strong>DCU命令（DCU Commands）</strong></a></h2><p><strong>DCU</strong>（DRAM命令单元）允许用户通过配置端口、APB（外设总线）或JTAG接口发出SDRAM命令。这个部分描述了如何编程DCU来执行SDRAM命令以及相关的时序要求。</p><h4 id="1-通过DCU执行SDRAM命令"><a href="#1-通过DCU执行SDRAM命令" class="headerlink" title="1. 通过DCU执行SDRAM命令"></a>1. <strong>通过DCU执行SDRAM命令</strong></h4><ul><li>DCU能够支持执行各种SDRAM命令，具体命令可以在文档的“PUB Commands”部分（第471页）找到。SDRAM命令是内存控制器与SDRAM之间通信的基本单元，例如读写操作、激活（Activate）、预充电（Precharge）等。</li><li>用户通过编程DCU来设置这些命令，并将其发送到SDRAM。这意味着通过DCU，用户可以控制SDRAM的操作，而无需直接控制硬件级别的细节。</li></ul><h4 id="2-时序要求"><a href="#2-时序要求" class="headerlink" title="2. 时序要求"></a>2. <strong>时序要求</strong></h4><ul><li><strong>时序控制</strong>：当用户编程DCU并发出命令时，DCU并不会自动处理这些命令的时序。也就是说，DCU只是将命令发送到SDRAM，但不会自动根据命令的执行顺序和时序要求来调整操作。</li><li><strong>NOP命令</strong>：在SDRAM命令序列中，NOP（No Operation，无操作）命令常用于填充时序空隙或者确保系统的时序满足要求。如果DCU在执行命令时存在时间间隔，需要通过插入适当数量的NOP命令来填补这些空白。</li><li><strong>时序特性</strong>：为了确保命令按预期执行，用户可以使用DCU的一些<strong>时序功能</strong>来调整命令之间的间隔，确保满足设备的时序要求。设备的时序要求包括每个命令的最小间隔时间，以及不同命令之间的依赖关系（例如，读取命令与激活命令之间的时序关系）。</li></ul><h4 id="3-激活（Activate）和预充电（Precharge）命令"><a href="#3-激活（Activate）和预充电（Precharge）命令" class="headerlink" title="3. 激活（Activate）和预充电（Precharge）命令"></a>3. <strong>激活（Activate）和预充电（Precharge）命令</strong></h4><ul><li><strong>激活命令（Activate Command）</strong>：用于打开SDRAM的一个特定的行。只有在激活命令之后，SDRAM的特定行才能被访问。</li><li><strong>预充电命令（Precharge Command）</strong>：用于关闭SDRAM的一个行，为新的读取或写入操作腾出空间。预充电命令通常在进行写入操作之前发出，以确保行被正确关闭。</li><li><strong>手动控制</strong>：DCU不会自动生成激活命令或预充电命令。这意味着在执行读取或写入命令之前，用户需要手动发出激活命令来打开正确的行，并在操作结束后发出预充电命令以关闭该行。</li></ul><h4 id="4-操作顺序和依赖关系"><a href="#4-操作顺序和依赖关系" class="headerlink" title="4. 操作顺序和依赖关系"></a>4. <strong>操作顺序和依赖关系</strong></h4><ul><li>在执行SDRAM命令时，命令之间有严格的顺序和依赖关系。例如，在发出读写命令之前，必须确保相应的SDRAM银行（bank）已被激活（Activate），并且在结束写入操作后需要发出预充电（Precharge）命令。</li><li>用户必须根据SDRAM的时序规范来手动安排这些命令的顺序。如果命令顺序不正确，可能导致读取或写入错误，甚至是内存损坏。</li></ul><hr><h2 id="DCU缓存（DCU-Caches）-的详细解释："><a href="#DCU缓存（DCU-Caches）-的详细解释：" class="headerlink" title="DCU缓存（DCU Caches） 的详细解释："></a><a><strong>DCU缓存（DCU Caches）</strong> 的详细解释：</a></h2><p>DCU（DRAM命令单元）有三个主要缓存，用于提高操作效率和数据访问的灵活性。下面对这三个缓存进行详细解释：</p><h3 id="1-命令缓存（Command-Cache）"><a href="#1-命令缓存（Command-Cache）" class="headerlink" title="1. 命令缓存（Command Cache）"></a>1. <strong>命令缓存（Command Cache）</strong></h3><ul><li><strong>深度</strong>：16深度（16 entries）。</li><li><strong>功能</strong>：命令缓存用于存储待执行的DRAM命令。这些命令由调度器（scheduler）执行。命令缓存是一个队列，按顺序存储和调度将要发送到DRAM的命令。通过使用命令缓存，系统可以按顺序缓冲多个命令，提高执行效率。</li><li><strong>内容</strong>：缓存中的每个条目不仅包括DRAM命令，还包含调度器所需的所有字段。特别地，每个条目还包含一个3位的RPT字段（Repeat Field），用于指示命令是否需要重复执行。RPT字段允许命令被执行多次。</li></ul><h3 id="2-读取数据缓存（Read-Data-Cache）"><a href="#2-读取数据缓存（Read-Data-Cache）" class="headerlink" title="2. 读取数据缓存（Read Data Cache）"></a>2. <strong>读取数据缓存（Read Data Cache）</strong></h3><ul><li><strong>深度</strong>：4深度（4 entries）。</li><li><strong>别名</strong>：也叫做<strong>捕获缓存（Capture Cache）</strong>。</li><li><strong>功能</strong>：读取数据缓存用于捕获从DRAM读取的数据。它存储从DRAM读取的一个字节的数据。这是为了快速捕捉和暂存读取的数据，在后续的操作中可以直接从缓存中获取，而不必每次都去访问DRAM。</li><li><strong>应用</strong>：该缓存是一个非常小的缓存，它通过缓存最常用的数据，减少了访问DRAM的次数，从而提高了数据读取的效率。</li></ul><h3 id="3-期望数据缓存（Expected-Data-Cache）"><a href="#3-期望数据缓存（Expected-Data-Cache）" class="headerlink" title="3. 期望数据缓存（Expected Data Cache）"></a>3. <strong>期望数据缓存（Expected Data Cache）</strong></h3><ul><li><strong>深度</strong>：16深度（16 entries）。</li><li><strong>功能</strong>：期望数据缓存用于存储预期与读取数据进行比较的数据。通过将读取数据与期望数据进行比对，系统能够判断数据是否正确或是否存在错误。该缓存是数据验证的一部分。</li><li><strong>内容</strong>：缓存中的每个条目都包含一个5位的数据码，共80个寄存器。为了提高配置端口的访问速度，期望数据缓存是作为一个1深度、80位宽的缓存来定义的，这样只需要3次寄存器写入（而如果定义为16深度5位的缓存，则需要16次写入）。这个设计减少了配置数据写入的次数，从而提高了数据加载的效率。</li></ul><h3 id="4-缓存结构和访问"><a href="#4-缓存结构和访问" class="headerlink" title="4. 缓存结构和访问"></a>4. <strong>缓存结构和访问</strong></h3><ul><li>每个缓存行都有一个与之对应的地址，用于标识缓存中的具体条目。例如，命令缓存有16行，因此缓存行的地址范围是0到15。</li><li>每个缓存行会被划分为若干个<strong>32位片段（slice）</strong>，其中第0片段是缓存行中的最低有效字（least significant word）。每行的片段数量取决于设计中存在的字节通道数（byte lanes）和缓存类型。</li><li>例如，<strong>读取数据缓存</strong>和<strong>期望数据缓存</strong>仅存储数据，不包含命令信息，而<strong>命令缓存</strong>除了包含命令字段外，还包括调度器需要的其他字段。</li></ul><h3 id="5-命令缓存条目的结构"><a href="#5-命令缓存条目的结构" class="headerlink" title="5. 命令缓存条目的结构"></a>5. <strong>命令缓存条目的结构</strong></h3><ul><li><strong>命令缓存</strong>的每个条目包括多个字段，这些字段由调度器使用。命令字段的格式类似于系统中其他内部引擎所使用的格式。这些字段包括命令类型、地址、数据和控制信号。</li><li>需要注意的是，<strong>命令缓存行的宽度不一定需要是32位的倍数</strong>。如果不是，最重要的字段（即最高有效字）应该通过填充0来确保它成为一个完整的32位字，以便进行写入操作。</li></ul><h3 id="6-访问方式"><a href="#6-访问方式" class="headerlink" title="6. 访问方式"></a>6. <strong>访问方式</strong></h3><ul><li>用户可以通过<strong>DCU地址寄存器（DCUAR）</strong>和<strong>DCU数据寄存器（DCUDR）</strong>来读写这些缓存。DCU地址寄存器用于选择缓存的条目（例如，选择命令缓存的某一行），而数据寄存器则用于存取该条目的数据。</li><li>在配置端口上，数据的写入或读取操作是通过寄存器来完成的，每个条目的数据通过这些寄存器进行传输。</li></ul><h3 id="7-缓存行格式"><a href="#7-缓存行格式" class="headerlink" title="7. 缓存行格式"></a>7. <strong>缓存行格式</strong></h3><ul><li>每个缓存行的格式对于正确编程和使用DCU命令缓存至关重要。特别是，编程DCU命令缓存时，必须正确设置每个字段的宽度，以确保数据能够按预期方式存储和访问。</li></ul><h3 id="8-BIST和训练功能的使用"><a href="#8-BIST和训练功能的使用" class="headerlink" title="8. BIST和训练功能的使用"></a>8. <strong>BIST和训练功能的使用</strong></h3><ul><li>读取数据缓存和期望数据缓存不仅仅用于标准的DRAM命令执行，它们还被其他PUB内部引擎（如<strong>BIST</strong>或<strong>训练功能</strong>）所使用。BIST（内建自测试，Built-In Self Test）和训练功能通常用于自检或优化SDRAM的性能。</li></ul><p><img src="https://s2.loli.net/2024/11/07/dum25cyYqCeDQjl.png" alt="image-20241107000127665"></p><hr><h2 id="写入或读取DCU缓存（Writing-or-Reading-DCU-Caches）-的详细解释："><a href="#写入或读取DCU缓存（Writing-or-Reading-DCU-Caches）-的详细解释：" class="headerlink" title="写入或读取DCU缓存（Writing or Reading DCU Caches） 的详细解释："></a><a><strong>写入或读取DCU缓存（Writing or Reading DCU Caches）</strong> 的详细解释：</a></h2><p>写入和读取DCU缓存（命令缓存、读取数据缓存、期望数据缓存）有两种方法。下面详细解释了这两种方法。</p><h3 id="1-手动写入或读取"><a href="#1-手动写入或读取" class="headerlink" title="1. 手动写入或读取"></a>1. <strong>手动写入或读取</strong></h3><ul><li>步骤<ul><li><strong>写入</strong>：要写入数据，首先需要将<strong>行地址（row address）**和**切片地址（slice address）**写入到**DCU地址寄存器（DCUAR）<strong>。接着，将32位的数据写入</strong>DCU数据寄存器（DCUDR）</strong>。这个过程需要手动控制行地址和切片地址的变化，确保每次都写入正确的地址位置。</li><li><strong>读取</strong>：与写入类似，读取数据时也需要首先设置正确的行地址和切片地址，然后读取相应的数据。</li></ul></li></ul><p>这种方法虽然可以精确控制缓存的读写，但也可能比较繁琐，因为每次都需要手动更新地址寄存器，逐步填写每个缓存行的内容。</p><h3 id="2-自动地址递增机制"><a href="#2-自动地址递增机制" class="headerlink" title="2. 自动地址递增机制"></a>2. <strong>自动地址递增机制</strong></h3><p>为了简化写入和读取过程，PUB实现了一种<strong>自动地址递增机制</strong>，该机制通过设置<strong>DCUAR寄存器中的INCA字段</strong>来启用。这种方式简化了手动控制的步骤，减少了错误和混乱的可能性。</p><ul><li><p>如何工作：</p><ul><li><strong>启用自动递增</strong>：通过在<strong>DCUAR寄存器</strong>中设置<strong>INCA字段</strong>，用户只需要指定<strong>起始行地址</strong>和<strong>起始切片地址</strong>，而不需要逐个更新地址。</li><li><strong>自动递增</strong>：每次将32位数据写入<strong>DCUDR寄存器</strong>时，切片地址（slice address）会自动递增，直到当前缓存行被填满。当当前缓存行被填满时，切片地址会重置为0，并且行地址会自动递增，跳转到下一个缓存行。</li><li><strong>简化操作</strong>：用户只需要进行一次起始地址和切片地址的设置，之后的所有操作会自动进行地址递增，极大简化了缓存操作，减少了手动控制的复杂性。</li></ul></li></ul><h3 id="3-自动地址递增的优点"><a href="#3-自动地址递增的优点" class="headerlink" title="3. 自动地址递增的优点"></a>3. <strong>自动地址递增的优点</strong></h3><ul><li><strong>减少复杂性</strong>：启用自动递增后，用户不需要每次都手动更新地址和切片地址，系统会自动处理这些步骤。这样可以减少配置错误和不必要的操作。</li><li><strong>提高效率</strong>：自动递增机制加快了数据写入的速度，因为它减少了对寄存器的频繁写入，并且在写入时，缓存行地址和切片地址的更新都是自动完成的。</li><li><strong>更少的错误</strong>：由于不需要手动跟踪和更新每个地址，减少了出错的可能性，尤其是在需要处理大批量数据时。</li></ul><hr><h2 id="DCU命令缓存写入示例（DCU-Command-Cache-Write-Example）-的详细解释："><a href="#DCU命令缓存写入示例（DCU-Command-Cache-Write-Example）-的详细解释：" class="headerlink" title="DCU命令缓存写入示例（DCU Command Cache Write Example） 的详细解释："></a><a><strong>DCU命令缓存写入示例（DCU Command Cache Write Example）</strong> 的详细解释：</a></h2><p>此部分展示了如何使用<strong>地址&#x2F;切片模式（address&#x2F;slice mode）</strong>来写入DCU命令缓存（command cache）。此模式用于将一个46位宽的命令字写入缓存。这是典型的用于支持LPDDRn系统的系统，其中使用了20位地址，并支持最多4个rank（内存通道）。</p><h4 id="1-背景说明"><a href="#1-背景说明" class="headerlink" title="1. 背景说明"></a>1. <strong>背景说明</strong></h4><ul><li><strong>命令字宽度</strong>：每个命令字为46位。为了在命令缓存中写入此类数据，每一行将被拆分成两个32位的字（也就是两个切片），因此一个缓存行会由两个32位的字组成，其中第二个32位的字只有前14位有效（因为总宽度是46位）。</li><li><strong>命令缓存行数</strong>：命令缓存的每一行有两个32位的切片，其中每个切片（32位）存储命令字的一个部分。第二个切片中的数据只有前14位有效，后18位将被忽略。</li></ul><h4 id="2-写入过程"><a href="#2-写入过程" class="headerlink" title="2. 写入过程"></a>2. <strong>写入过程</strong></h4><p>要在此模式下写入命令缓存，必须按如下步骤通过配置端口（或者APB或JTAG）向寄存器写入数据：</p><p><strong>步骤 1：写入DCU地址寄存器（<code>DCUAR</code>）</strong></p><ul><li>将以下字段写入<code>DCUAR</code>寄存器，设置用于命令缓存的地址和切片信息：<ul><li><strong>CSEL &#x3D; 2’b00</strong>：选择命令缓存（Command Cache）。</li><li><strong>INCA &#x3D; 0</strong>：禁用地址递增（即每次写入时，地址不会自动递增，需要手动递增切片地址）。</li><li><strong>ATYPE &#x3D; 0</strong>：写入访问（Write Access）。</li><li><strong>CWADDR &#x3D; 0</strong>：选择缓存行地址为0。</li><li><strong>CSADDR &#x3D; 0</strong>：选择缓存切片为0（即写入第一部分的32位数据）。</li></ul></li></ul><p><strong>步骤 2：写入32位数据到DCU数据寄存器（<code>DCUDR</code>）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表命令字的第0到31位（即命令字的低32位）。这是缓存行的第一部分数据。</li></ul><p><strong>步骤 3：更新DCU地址寄存器（<code>DCUAR</code>）以选择切片1</strong></p><ul><li>在<code>DCUAR</code>寄存器中再次写入（保持之前的设置，更新切片地址）：<ul><li><strong>CWADDR &#x3D; 0</strong>：行地址保持为0。</li><li><strong>CSADDR &#x3D; 1</strong>：选择缓存的第二个切片（即写入命令字的第32到45位）。</li></ul></li></ul><p><strong>步骤 4：写入32位数据到DCU数据寄存器（DCUDR）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表命令字的第32到45位（即命令字的高14位）。请注意，命令字的第14到31位会被忽略，只写入有效的高14位数据。</li></ul><p><strong>步骤 5：重复上述步骤</strong></p><ul><li>对于每个命令缓存行（从行地址0开始），重复步骤1到步骤4，直到所有命令缓存行都写入数据。每次操作时，更新<strong>CWADDR（行地址）</strong>，使其递增，直到所有缓存行完成写入。</li></ul><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. <strong>注意事项</strong></h4><ul><li><strong>起始和结束地址</strong>：命令缓存的写入不一定需要从行地址<strong>CWADDR &#x3D; 0</strong>开始。你可以通过<strong>DCU运行寄存器（DCURR）</strong>指定任何起始和结束地址。但是，结束地址必须大于起始地址，因为执行会在命令缓存的最后一行结束，而不会环绕到缓存的开头。</li><li><strong>命令缓存的执行顺序</strong>：即使你指定了不同的起始和结束行地址，命令缓存的执行仍会按顺序从起始行执行到结束行，不会回绕到缓存的开头。</li></ul><hr><h2 id="DCU期望数据缓存写入示例（DCU-Expected-Cache-Write-Example）-的详细解释："><a href="#DCU期望数据缓存写入示例（DCU-Expected-Cache-Write-Example）-的详细解释：" class="headerlink" title="DCU期望数据缓存写入示例（DCU Expected Cache Write Example） 的详细解释："></a><a><strong>DCU期望数据缓存写入示例（DCU Expected Cache Write Example）</strong> 的详细解释：</a></h2><p>该示例展示了如何使用<strong>自动地址递增模式（automatic address incrementing mode）</strong>来写入DCU的期望数据缓存（expected data cache）。为了加速从配置端口的访问，期望数据缓存被定义为1深度、80位宽的缓存，这使得只需要<strong>3次寄存器写入</strong>即可加载数据，而如果该缓存被定义为**16深度、5位宽，则需要16次写入。</p><h4 id="1-背景说明-1"><a href="#1-背景说明-1" class="headerlink" title="1. 背景说明"></a>1. <strong>背景说明</strong></h4><ul><li><strong>缓存行宽度</strong>：期望数据缓存的行宽为80位。为了适应这个宽度，每行会被分成三个32位切片（即3个切片）。其中，第三个32位切片中只有前16位有效，因为总行宽只有80位，剩余的16位会被忽略。</li><li><strong>缓存的格式</strong>：期望数据缓存的每一行包含3个32位数据字（切片），每个数据字的位宽分别为[31:0]、[63:32]和[79:64]。</li></ul><h4 id="2-写入过程-1"><a href="#2-写入过程-1" class="headerlink" title="2. 写入过程"></a>2. <strong>写入过程</strong></h4><p>要在期望数据缓存中写入数据，并启用自动地址递增模式，需要按照以下步骤通过配置端口（或APB或JTAG）向寄存器写入数据：</p><p><strong>步骤 1：写入DCU地址寄存器（<code>DCUAR</code>）</strong></p><ul><li>将以下字段写入<code>DCUAR</code>寄存器，设置用于期望数据缓存的地址和切片信息：<ul><li><strong>CSEL &#x3D; 2’b01</strong>：选择期望数据缓存（Expected Data Cache）。</li><li><strong>INCA &#x3D; 1</strong>：启用地址递增（即每次写入时，地址会自动递增）。</li><li><strong>ATYPE &#x3D; 0</strong>：写入访问（Write Access）。</li><li><strong>CWADDR &#x3D; 0</strong>：选择缓存行地址为0（行地址为0）。</li><li><strong>CSADDR &#x3D; 0</strong>：选择缓存切片为0（即写入第一部分的32位数据）。</li></ul></li></ul><p><strong>步骤 2：写入32位数据到DCU数据寄存器（<code>DCUDR</code>）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表期望数据缓存的第0到31位（即命令字的低32位）。这是缓存行的第一部分数据。</li></ul><p><strong>步骤 3：更新DCU地址寄存器（<code>DCUAR</code>）以选择切片1</strong></p><ul><li>在<code>DCUAR</code>寄存器中再次写入（保持之前的设置，更新切片地址）：<ul><li><strong>CWADDR &#x3D; 0</strong>：行地址保持为0。</li><li><strong>CSADDR &#x3D; 1</strong>：选择缓存的第二个切片（即写入命令字的第32到63位）。</li></ul></li></ul><p><strong>步骤 4：写入32位数据到DCU数据寄存器（<code>DCUDR</code>）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表期望数据缓存的第32到63位（即命令字的第32到63位）。写入的数据会填充缓存行的第二部分。</li></ul><p><strong>步骤 5：更新DCU地址寄存器（&#96;&#96;DCUAR&#96;）以选择切片2</strong></p><ul><li>在DCUAR寄存器中再次写入（保持之前的设置，更新切片地址）：<ul><li><strong>CWADDR &#x3D; 0</strong>：行地址保持为0。</li><li><strong>CSADDR &#x3D; 2</strong>：选择缓存的第三个切片（即写入命令字的第64到79位）。</li></ul></li></ul><p><strong>步骤 6：写入32位数据到DCU数据寄存器（<code>DCUDR</code>）</strong></p><ul><li>写入<strong>32位数据字</strong>，该数据字代表期望数据缓存的第64到79位（即命令字的第64到79位）。请注意，此时数据的第16到31位将被忽略，只会写入有效的前16位。</li></ul><h4 id="3-注意事项-1"><a href="#3-注意事项-1" class="headerlink" title="3. 注意事项"></a>3. <strong>注意事项</strong></h4><ul><li><strong>地址递增</strong>：启用<strong>INCA &#x3D; 1</strong>后，每次写入时切片地址会自动递增，直到缓存行写满为止。这样可以省去手动更新地址的步骤，简化操作。</li><li><strong>无效数据位</strong>：期望数据缓存的每行宽度为80位，第三个32位切片中只有前16位有效，后16位的数据会被忽略，因此每次写入时，需要确保只写入有效数据。</li></ul><hr><h2 id="DCU读取数据缓存读取示例（DCU-Read-Data-Cache-Read-Example）的详细解释："><a href="#DCU读取数据缓存读取示例（DCU-Read-Data-Cache-Read-Example）的详细解释：" class="headerlink" title="DCU读取数据缓存读取示例（DCU Read Data Cache Read Example）的详细解释："></a><a><strong>DCU读取数据缓存读取示例（DCU Read Data Cache Read Example）</strong>的详细解释：</a></h2><p>此示例展示了如何使用<strong>自动地址递增模式（automatic address incrementing mode）</strong>读取DCU的读取数据缓存（read data cache）。读取数据缓存每行包含32位数据，并且总共有4行，每行包含1个32位数据字（或1个切片）。</p><h4 id="1-背景说明-2"><a href="#1-背景说明-2" class="headerlink" title="1. 背景说明"></a>1. <strong>背景说明</strong></h4><ul><li><strong>缓存行宽度</strong>：读取数据缓存的每一行宽度为32位，即每行只有1个切片。</li><li><strong>缓存的行数</strong>：共有4行数据，分别对应读取缓存的不同部分。</li></ul><h4 id="2-读取过程"><a href="#2-读取过程" class="headerlink" title="2. 读取过程"></a>2. <strong>读取过程</strong></h4><p>要从读取数据缓存中读取数据，并启用自动地址递增模式，需要按照以下步骤通过配置端口（或APB或JTAG）与寄存器进行交互：</p><p><strong>步骤 1：写入DCU地址寄存器（DCUAR）</strong></p><ul><li>向DCUAR寄存器写入以下字段，设置用于读取数据缓存的地址和切片信息：<ul><li><strong>CSEL &#x3D; 2’b10</strong>：选择读取数据缓存（Read Data Cache）。</li><li><strong>INCA &#x3D; 1</strong>：启用地址递增（即每次读取时，地址会自动递增）。</li><li><strong>ATYPE &#x3D; 1</strong>：读取访问（Read Access）。</li><li><strong>CWADDR &#x3D; 0</strong>：选择缓存行地址为0（行地址为0）。</li><li><strong>CSADDR &#x3D; 0</strong>：选择缓存切片为0（即从第一个切片开始读取）。</li></ul></li></ul><p><strong>步骤 2：从DCU数据寄存器（DCUDR）读取32位数据</strong></p><ul><li>读取<strong>32位数据字</strong>，该数据字代表缓存行的第0行数据（即缓存字的[31:0]位）。这是读取数据缓存的第一部分。</li></ul><p><strong>步骤 3：更新DCU地址寄存器（DCUAR）以选择下一行（行1）</strong></p><ul><li>在DCUAR寄存器中再次写入（保持之前的设置，更新行地址和切片地址）：<ul><li><strong>CWADDR &#x3D; 1</strong>：选择缓存行地址为1（读取缓存的第二行数据）。</li><li><strong>CSADDR &#x3D; 0</strong>：继续选择缓存切片为0。</li></ul></li></ul><p><strong>步骤 4：从DCU数据寄存器（DCUDR）读取32位数据</strong></p><ul><li>读取<strong>32位数据字</strong>，该数据字代表缓存行的第1行数据（即缓存字的[31:0]位）。这是读取数据缓存的第二部分。</li></ul><p><strong>步骤 5：更新DCU地址寄存器（DCUAR）以选择下一行（行2）</strong></p><ul><li>在DCUAR寄存器中再次写入：<ul><li><strong>CWADDR &#x3D; 2</strong>：选择缓存行地址为2（读取缓存的第三行数据）。</li><li><strong>CSADDR &#x3D; 0</strong>：继续选择缓存切片为0。</li></ul></li></ul><p><strong>步骤 6：从DCU数据寄存器（DCUDR）读取32位数据</strong></p><ul><li>读取<strong>32位数据字</strong>，该数据字代表缓存行的第2行数据（即缓存字的[31:0]位）。这是读取数据缓存的第三部分。</li></ul><p><strong>步骤 7：更新DCU地址寄存器（DCUAR）以选择下一行（行3）</strong></p><ul><li>在DCUAR寄存器中再次写入：<ul><li><strong>CWADDR &#x3D; 3</strong>：选择缓存行地址为3（读取缓存的第四行数据）。</li><li><strong>CSADDR &#x3D; 0</strong>：继续选择缓存切片为0。</li></ul></li></ul><p><strong>步骤 8：从DCU数据寄存器（DCUDR）读取32位数据</strong></p><ul><li>读取<strong>32位数据字</strong>，该数据字代表缓存行的第3行数据（即缓存字的[31:0]位）。这是读取数据缓存的最后部分。</li></ul><h4 id="3-注意事项-2"><a href="#3-注意事项-2" class="headerlink" title="3. 注意事项"></a>3. <strong>注意事项</strong></h4><ul><li><strong>地址递增</strong>：由于每行的宽度为32位，并且每行只有一个切片，因此每次从DCUDR读取32位数据时，地址会自动递增。这样每次读取的数据都会对应到下一行的内容。即每次读取时，<strong>行地址（CWADDR）会自动递增</strong>，不需要手动更新。</li><li><strong>缓存行宽度</strong>：读取数据缓存的每行宽度为32位，这意味着每次读取的数据都会填充整个缓存行，不会出现需要裁剪或忽略的部分。</li></ul><p><a>BDXSEL 由 DCU 读数据缓存使用，以选择字节通道来捕获读取数据。</a></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> PUB </tag>
            
            <tag> DCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture-BIST Loopback</title>
      <link href="/2024/11/05/DDR/PUB%20Architecture-BIST%20Loopback/"/>
      <url>/2024/11/05/DDR/PUB%20Architecture-BIST%20Loopback/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pub手册4.6.4，<strong>BIST (Built-In Self-Test)</strong> 模块是一种可编程的自检引擎，它为应用程序提供了一种测试 DDR PHY 和 I&#x2F;O 的方法，主要用于高速生产测试。BIST 模块通过 <strong>回路回送</strong>（loopback）方式来验证 PHY 的发送路径和接收路径的功能。除此之外，还可以选择测试外部内存的功能。<a><span id="more"></span></a></p></blockquote><h3 id="BIST-模块的功能"><a href="#BIST-模块的功能" class="headerlink" title="BIST 模块的功能"></a>BIST 模块的功能</h3><ol><li><strong>PHY 测试</strong>：<br>BIST 通过将数据从 PHY 的发送路径通过回路回送到接收路径，来测试 PHY 的发送和接收功能。通过此方式，不需要外部存储器即可完成测试。</li><li><strong>I&#x2F;O 测试</strong>：<br>BIST 还可以测试 I&#x2F;O 的功能，确保数据能够正确地通过 I&#x2F;O 接口传输。</li><li><strong>外部内存测试</strong>（可选）：<br>如果需要，BIST 还提供了测试外部内存的功能。此时，BIST 会发送常规的写读事务到外部 DRAM，并比较从 DRAM 读取的数据和写入的数据是否一致。</li></ol><h3 id="BIST-模块的工作原理"><a href="#BIST-模块的工作原理" class="headerlink" title="BIST 模块的工作原理"></a>BIST 模块的工作原理</h3><ul><li><strong>回路回送模式</strong>（Loopback Mode）：<br>在回路回送模式下，BIST 将数据从 PHY 的发送路径通过 I&#x2F;O 返回到接收路径。这样，数据就可以在 PHY 内部进行循环回送，进行自检。这种模式不需要外部内存，因此适用于不需要依赖外部存储器的测试场景。</li><li><strong>DRAM 模式</strong>（DRAM Mode）：<br>在 DRAM 模式下，BIST 会向 DRAM 发送正常的写读事务，并将读取的数据与预期数据进行比较。该模式适用于测试外部 DRAM 存储器。</li></ul><h3 id="BIST-模块的结构（Block-Diagram）"><a href="#BIST-模块的结构（Block-Diagram）" class="headerlink" title="BIST 模块的结构（Block Diagram）"></a><strong>BIST 模块的结构（Block Diagram）</strong></h3><ul><li><p>BIST 模块的框图（提供详细图示）展示了各个功能模块之间的连接方式。它通常包括以下几个主要组件：</p><ul><li><strong>传输路径（Transmit Path）</strong>：用于将数据从 PHY 的发送端发送出去。</li><li><strong>接收路径（Receive Path）</strong>：用于接收回送的数据并进行比较。</li><li><strong>外部内存接口</strong>：如果使用 DRAM 测试模式，则通过外部内存接口与 DRAM 进行通信。</li><li><strong>测试模式选择器</strong>：允许选择回路回送模式或 DRAM 模式。</li><li><strong>控制寄存器</strong>：通过这些寄存器，可以控制 BIST 模块的启停，配置回送模式、DRAM 模式、错误检测等。</li></ul></li></ul><p>通过该图示，用户可以理解如何在不同测试模式下配置 BIST 模块，并进行 PHY 和 I&#x2F;O 的功能验证。</p><p><img src="https://s2.loli.net/2024/11/05/KVoF7RqgQZnbhmH.png" alt="image-20241105231703048"></p><hr><h3 id="1-环回模式（Loopback-Mode）"><a href="#1-环回模式（Loopback-Mode）" class="headerlink" title="1. 环回模式（Loopback Mode）"></a>1. <strong>环回模式（Loopback Mode）</strong></h3><p>环回模式是用来测试 PHY（物理层）和 I&#x2F;O 接口的。其原理是将写入的数据直接送回接收路径，这样就不需要外部存储器（例如 DRAM）来进行测试。具体来说：</p><ul><li><strong>DATXn 写路径和接收路径的环回：</strong> 在环回模式下，<strong>DATXn</strong>（数据线组）的写入数据将直接通过 I&#x2F;O 传输到接收路径上。也就是说，BIST 发送数据之后，数据直接回到发送端，而不经过外部存储器，这样可以用来验证 PHY 数据通道是否正常。</li><li><strong>AC 输出路径的环回：</strong> 另外，<strong>AC 输出路径</strong>也会在 I&#x2F;O 处被环回到专用的 AC 环回逻辑。AC 是指命令和地址通道（Address&#x2F;Command），它用于传输内存的读写地址和控制信号。这部分的环回确保地址和命令通道也能正确工作。</li></ul><p>这种模式的好处是无需连接外部 DRAM，测试过程可以在没有外部存储器的情况下进行，适合用于检查 PHY 层和 I&#x2F;O 接口的基本功能。</p><ul><li><strong>最小的 WL&#x2F;RL：</strong> 环回模式下支持的最小 WL（写延迟）和 RL（读延迟）为 6。WL&#x2F;RL 是内存操作的延时设置，通常与内存的时序参数有关。BIST 测试时，环回模式对延迟有最低要求。</li></ul><h3 id="2-DRAM模式（DRAM-Mode）"><a href="#2-DRAM模式（DRAM-Mode）" class="headerlink" title="2. DRAM模式（DRAM Mode）"></a>2. <strong>DRAM模式（DRAM Mode）</strong></h3><p>在 DRAM 模式下，BIST 会像正常的内存访问一样进行读写操作，写入数据到 DRAM 中，并从 DRAM 中读取数据来进行对比。这个模式实际上测试的是内存的数据完整性以及内存与 PHY 接口之间的配合。具体来说：</p><ul><li><strong>写读事务：</strong> 在 DRAM 模式下，BIST 会执行正常的<strong>写读事务</strong>（Write&#x2F;Read Transactions）。即，它将数据写入 DRAM 并从 DRAM 中读取数据来进行对比，确保内存和 PHY 层能够正常交互。</li><li><strong>地址和命令通道的环回：</strong> 即使是在 DRAM 模式下，<strong>地址&#x2F;命令通道</strong>（Address&#x2F;Command Channel）依然会在 I&#x2F;O 处进行环回。这意味着，BIST 不会向外部发送命令和地址信号，而是会将这些信号发送回自身，以确保地址&#x2F;命令通道的功能正确。</li><li><strong>外部存储器测试：</strong> 在 DRAM 模式下，可以将其用作测试外部内存（例如，外部的 DRAM 存储芯片），通过发送写读事务并进行数据比较，验证 DRAM 和 PHY 层的通信是否正确。</li></ul><hr><h3 id="PHY环回功能"><a href="#PHY环回功能" class="headerlink" title="PHY环回功能"></a><strong>PHY环回功能</strong></h3><p>PHY（物理层）环回是通过 <strong>I&#x2F;O</strong> 接口的环回功能实现的，目的是将从 I&#x2F;O 驱动出去的数据通过环回机制传回，以便进行测试和验证。环回的实现取决于 <strong>PGCR1[IOLB] 寄存器位的设置</strong>。</p><h3 id="环回机制的工作方式"><a href="#环回机制的工作方式" class="headerlink" title="环回机制的工作方式"></a><strong>环回机制的工作方式</strong></h3><ul><li><p>数据的环回：当数据从 I&#x2F;O 驱动出来时，它可以在两种不同的位置进行环回：</p><ul><li><strong>I&#x2F;O的pad侧：</strong> 这种方式是将数据在I&#x2F;O的pad（物理引脚）端进行环回，即数据通过I&#x2F;O引脚直接返回。</li><li><strong>I&#x2F;O的核心侧：</strong> 另一种方式是在I&#x2F;O的核心侧进行环回，即数据回到I&#x2F;O的内部逻辑。</li></ul></li></ul><p>具体选择哪种环回方式，取决于 <strong>PGCR1[IOLB]</strong> 寄存器位的设置。PGCR1 寄存器中的 <strong>[IOLB]</strong> 位用于配置环回的模式：</p><ul><li>如果 <strong>IOLB</strong> 位设置为某个特定值，它将决定数据是从 <strong>pad侧</strong> 还是 <strong>核心侧</strong> 进行环回。</li></ul><hr><h3 id="DATX8-Loopback"><a href="#DATX8-Loopback" class="headerlink" title="DATX8 Loopback"></a>DATX8 Loopback</h3><p><strong>DATX8 读路径与环回路径：</strong></p><ul><li><strong>DATX8</strong> 是 DDR 接口中的一部分，它在数据字节传输中负责读取数据。</li><li>在环回模式下，<strong>DATX8 的读路径</strong>会被用作环回路径。也就是说，数据（DQ、DM）和写入的 <strong>DQS</strong>（数据选通信号）会被环回到 <strong>DATX8</strong> 读路径中，并被当作 <strong>读 DQ&#x2F;DM</strong> 和 <strong>读 DQS</strong> 来处理。</li></ul><p><strong>DQS 信号的对齐问题：</strong></p><ul><li><strong>DQS</strong> 是在 DDR 写入操作中与数据一起传输的同步信号。在 <strong>写入路径</strong> 中，<strong>DQS</strong> 会相对于 <strong>DQ&#x2F;DM</strong> 信号提前 90 度发送，这样可以帮助在读取时对齐数据。</li><li>但是在 <strong>读路径</strong> 中，<strong>DATX8</strong> 期望 <strong>读 DQS</strong> 和 <strong>读 DQ&#x2F;DM</strong> 信号是 <strong>边缘对齐</strong>（edge-aligned）的，意味着它们应该在时序上保持同步。</li></ul><p><strong>问题：</strong></p><ul><li>在环回测试中，由于 <strong>写路径</strong> 会将 <strong>DQS</strong> 信号相对于 <strong>DQ&#x2F;DM</strong> 信号提前 90 度（这是为了帮助读取数据），<strong>DATX8</strong> 读路径会接收到已经提前 90 度的 <strong>DQS</strong> 信号。这个提前的 90 度是写路径的特性，而 <strong>DATX8</strong> 需要去掉这个提前，以确保 <strong>读 DQS</strong> 与 <strong>读 DQ&#x2F;DM</strong> 对齐。</li></ul><p><strong>解决方案：</strong></p><ul><li>为了消除这个 90 度的提前，应该通过 设置 LCDL（读取延迟控制）来调整 DQS信号的相位。具体来说：<ul><li>设置 <strong>DXnLCDLR4[RDQSD]</strong> 和 <strong>DXnLCDLR4[RDQSND]</strong> 为 0，这样可以去掉读取路径中 DQS 信号的 90 度偏移。</li><li>这确保了 <strong>环回模式</strong> 下，<strong>DQS</strong> 信号相对于 <strong>读数据</strong> 只会偏移 90 度，且 <strong>读取数据</strong> 和 <strong>读取 DQS</strong> 是同步对齐的。</li></ul></li></ul><p><strong>DDR3 写操作的预置（Write Preamble）：</strong></p><ul><li><strong>预置</strong> 是指在数据传输开始之前，信号在一定周期内的初始状态。在 DDR3 中，写操作通常有一个 <strong>全翻转预置</strong>（full toggle preamble），即信号在开始时进行翻转。</li><li>这个预置是为了保证数据的正确性，确保数据和控制信号能够准确地同步。</li></ul><p><strong>环回模式中的问题：</strong></p><ul><li>在 <strong>环回模式</strong> 下，数据通过 I&#x2F;O 路径被送回到接收器。通常在环回测试中，我们期望数据传输的信号在写入路径和读取路径之间能够同步。</li><li>由于 <strong>写预置</strong> 是一个全翻转预置，这意味着写入路径中的 <strong>DQS</strong>（数据选通信号）会进行翻转。</li><li>但是，如果环回时将这个信号直接送回读取路径，那么读取路径的 <strong>DQS 预置</strong> 也会跟着翻转，这就与预期的读取数据（通常来自 SDRAM 的数据）不一致。</li></ul><p><strong>问题的根源：</strong></p><ul><li><strong>预期的读取数据</strong> 应该是一个稳定的、没有翻转的信号。在标准的 <strong>SDRAM 写入操作</strong> 中，数据的读取路径中的 <strong>DQS</strong> 信号应该是一个稳定的 <strong>全时钟预置</strong>（non-toggling full-clock preamble），而不是像写路径中那样进行翻转。</li><li>如果将 <strong>写预置</strong> 在环回模式下直接传递到读取路径，那么读取路径的 <strong>DQS</strong> 信号也会经历翻转，导致数据和时序的错误。</li></ul><p><strong>解决方案：</strong></p><ul><li>为了保证环回模式下的正确性，需要 <strong>生成非翻转的全时钟预置</strong>（non-toggling full-clock preamble）信号，而不是全翻转的写预置。通过这种方式，可以确保在环回测试中，<strong>DQS</strong> 信号与读取数据的同步要求一致，避免了翻转问题。</li><li>具体来说，环回模式下会 <strong>生成与 SDRAM 预期相符的读取数据</strong>，即通过 <strong>不翻转的时钟预置</strong> 来确保 <strong>DQS</strong> 信号稳定，以匹配标准的 <strong>SDRAM</strong> 行为。</li></ul><hr><h3 id="AC-Loopback"><a href="#AC-Loopback" class="headerlink" title="AC Loopback"></a>AC Loopback</h3><h4 id="1-地址-命令通道-AC-Lane-："><a href="#1-地址-命令通道-AC-Lane-：" class="headerlink" title="1. 地址&#x2F;命令通道 (AC Lane)："></a>1. <strong>地址&#x2F;命令通道 (AC Lane)：</strong></h4><ul><li>地址&#x2F;命令通道负责与 <strong>SDRAM</strong>（同步动态随机存取存储器）进行通信，传输地址和控制信号。例如，<strong>地址信号</strong> 用于定位存储位置，<strong>命令信号</strong> 用于控制读写操作。</li></ul><h4 id="2-AC-PHY-环回逻辑："><a href="#2-AC-PHY-环回逻辑：" class="headerlink" title="2. AC PHY 环回逻辑："></a>2. <strong>AC PHY 环回逻辑</strong>：</h4><ul><li>在 DDR3 或 DDR4 系统中，AC PHY 负责处理地址和命令的物理层传输。为了在测试时不依赖外部内存，AC PHY 提供了内建的 <strong>环回逻辑</strong>，允许将地址和命令信号从 SDRAM 发送到 AC PHY，再从 AC PHY 环回到接收路径。环回后的信号被当作 <strong>读取数据</strong> 和 <strong>读取时钟</strong> 进行处理。</li></ul><h4 id="3-CK-CK-时钟信号的环回："><a href="#3-CK-CK-时钟信号的环回：" class="headerlink" title="3. CK&#x2F;CK# 时钟信号的环回："></a>3. <strong>CK&#x2F;CK# 时钟信号的环回</strong>：</h4><ul><li><strong>CK&#x2F;CK#</strong> 是用于同步数据传输的差分时钟信号。在 AC 环回模式下，<strong>CK&#x2F;CK#</strong> 信号被环回到 AC PHY，并被当作 <strong>读取时钟</strong> 来使用。</li><li>在环回过程中，时钟会被 <strong>反向</strong>（inverted），以确保 <strong>ck_do</strong>（环回后的时钟信号）能在 <strong>DDR 时钟</strong> 的一个周期之前传输，确保第一个环回数据能够被正确地采样。</li></ul><h4 id="4-BISTRR-BCKSEL-寄存器："><a href="#4-BISTRR-BCKSEL-寄存器：" class="headerlink" title="4. BISTRR[BCKSEL] 寄存器："></a>4. <strong>BISTRR[BCKSEL] 寄存器</strong>：</h4><ul><li>该寄存器字段用于选择哪个时钟信号（**CK[n]**）将用于捕捉地址和命令信号。在环回模式下，可以根据需要配置时钟源。</li></ul><h4 id="5-时钟反转（Inverted-Clock）："><a href="#5-时钟反转（Inverted-Clock）：" class="headerlink" title="5. 时钟反转（Inverted Clock）："></a>5. <strong>时钟反转（Inverted Clock）</strong>：</h4><ul><li>在 AC 环回模式中，时钟信号会被 <strong>反转</strong>，这样可以使环回数据在 DDR 时钟周期的 <strong>提前一个周期</strong>（一个 DDR 时钟周期提前）时被正确采样。</li><li><strong>反向时钟</strong> 的目的是确保 <strong>第一个环回的数据</strong> 能够在正确的时钟边沿上被采样，从而避免时序问题。</li></ul><h4 id="6-cke-和-cs-n-对齐："><a href="#6-cke-和-cs-n-对齐：" class="headerlink" title="6. cke 和 cs_n 对齐："></a>6. <strong>cke 和 cs_n 对齐</strong>：</h4><ul><li><strong>cke</strong>（时钟启用信号）和 <strong>cs_n</strong>（芯片选择信号）会与 <strong>ck_do</strong> 上升沿对齐。尽管时钟反转了，但因为 <strong>cke</strong> 和 <strong>cs_n</strong> 并没有被用于外部 DRAM 的操作，因此在环回测试中它们的对齐不会造成问题。</li><li>这意味着，即使时钟信号发生了反转，<strong>cke</strong> 和 <strong>cs_n</strong> 信号与时钟的对齐状态并不影响环回模式中的测试，因为它们并不直接影响 DRAM 的操作。</li></ul><h4 id="环回模式中的信号流程："><a href="#环回模式中的信号流程：" class="headerlink" title="环回模式中的信号流程："></a><strong>环回模式中的信号流程：</strong></h4><ol><li><strong>地址和命令信号</strong>：从 <strong>SDRAM</strong> 发出，通过 <strong>AC PHY</strong> 环回逻辑，进入 <strong>AC PHY</strong> 接收路径，并被视为 <strong>读取数据</strong>。</li><li><strong>时钟信号（CK&#x2F;CK#）</strong>：时钟信号同样被环回，反转后成为用于 <strong>读取数据</strong> 的时钟信号。</li><li><strong>cke 和 cs_n</strong>：这些信号与时钟信号对齐，但由于它们不影响 DRAM，时序对齐不影响测试。</li></ol><hr><h3 id="Loopback-Data-Capture"><a href="#Loopback-Data-Capture" class="headerlink" title="Loopback Data Capture"></a>Loopback Data Capture</h3><h4 id="时钟路径和数据路径的延迟差异"><a href="#时钟路径和数据路径的延迟差异" class="headerlink" title="时钟路径和数据路径的延迟差异"></a><strong>时钟路径和数据路径的延迟差异</strong></h4><p>在 <strong>环回数据捕获</strong>（loopback data capture）模式下，时钟路径和数据路径的延迟存在差异：</p><ul><li><strong>时钟路径</strong>：时钟信号的传播通常会有更大的延迟，因为时钟信号需要经过更多的逻辑单元（如时钟缓冲器、分配网络等）。</li><li><strong>数据路径</strong>：数据从发送端到接收端的路径可能涉及不同的逻辑单元，但相对于时钟路径的延迟，数据路径的延迟通常较小。</li></ul><p>这种延迟差异的产生是因为：</p><ul><li>时钟信号必须被精确同步并分配到所有相关的接收器。</li><li>数据路径通常依赖于更少的逻辑单元来传输实际的数据。</li></ul><h4 id="2-如何补偿时钟路径和数据路径之间的延迟差异"><a href="#2-如何补偿时钟路径和数据路径之间的延迟差异" class="headerlink" title="2. 如何补偿时钟路径和数据路径之间的延迟差异"></a>2. <strong>如何补偿时钟路径和数据路径之间的延迟差异</strong></h4><p>为了确保 <strong>环回数据</strong> 的正确捕获，需要补偿时钟路径和数据路径之间的延迟差异。这个补偿的方式是通过增加 <strong>数据路径的延迟</strong> 来实现，使其与时钟路径的延迟差异相匹配。</p><ul><li>为了补偿这种延迟差异，可以通过设置 <strong>AC BDLs</strong>（Address&#x2F;Command Bus Delay Line）为 <strong>0xA</strong> 来添加延迟。BDLs 控制 <strong>数据路径的延迟</strong>，通过设置这些寄存器的值为 0xA，可以在数据路径中引入适当的延迟，使其与时钟路径的延迟差异相匹配。<ul><li><strong>AC BDLs</strong>: 这是一个控制地址和命令通道中数据路径延迟的寄存器字段。</li><li><strong>值 0xA</strong>：这个值表示一个特定的延迟量，根据设计的要求，这个延迟可以通过该设置来调整。</li></ul></li></ul><h4 id="3-延迟的计算"><a href="#3-延迟的计算" class="headerlink" title="3. 延迟的计算"></a>3. <strong>延迟的计算</strong></h4><p>补偿的延迟必须满足以下条件：</p><ul><li><strong>数据路径的延迟</strong>必须大于时钟路径和数据路径延迟差异加上<strong>捕获触发器的保持时间（Capture FF hold）</strong>。</li><li>这种延迟补偿需要适应不同的 <strong>PVT（Process, Voltage, Temperature）角度</strong>，即考虑到工艺、工作电压和温度的变化。</li></ul><p>换句话说，设置的数据路径延迟应该足够大，以确保数据能够正确捕获，避免因为时钟和数据路径的不同步导致的错误。</p><h4 id="4-RTL仿真中的特别情况"><a href="#4-RTL仿真中的特别情况" class="headerlink" title="4. RTL仿真中的特别情况"></a>4. <strong>RTL仿真中的特别情况</strong></h4><ul><li><p>在 RTL仿真</p><p> 中，由于仿真模型通常不考虑时钟和数据路径之间的实际延迟差异，因此不需要显式地为数据路径添加额外的延迟。</p><ul><li><strong>RTL仿真</strong>：这是指在设计阶段使用 <strong>寄存器传输级（RTL）模型</strong> 进行的仿真。在这种仿真中，设计的时钟和数据路径延迟差异通常是通过仿真工具的建模来忽略的，因此无需手动增加额外的延迟。</li></ul></li></ul><hr><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><h3 id="1-AC-I-O-接收器默认关闭"><a href="#1-AC-I-O-接收器默认关闭" class="headerlink" title="1. AC I&#x2F;O 接收器默认关闭"></a>1. <strong>AC I&#x2F;O 接收器默认关闭</strong></h3><ul><li><strong>AC I&#x2F;O 接收器</strong>：在 AC（地址&#x2F;命令）通道中，接收器用于接收来自外部的地址和命令信号（例如，SDRAM 地址、命令信号）。这些接收器通常在系统初始化时处于关闭状态，以节省功耗。</li><li><strong>必须启用接收器</strong>：在进行 <strong>AC 环回测试</strong> 时，必须确保接收器已被启用，否则环回信号将无法被正确接收。因此，需要通过配置 <strong>ACIOCR0[PDR] 寄存器</strong> 来启用 AC I&#x2F;O 接收器。<ul><li><code>ACIOCR0[PDR]</code>：这是一个配置寄存器，用于控制 <strong>AC I&#x2F;O 接收器的电源管理</strong>。通过设置该寄存器，可以启用这些接收器。</li></ul></li></ul><h3 id="2-DATX8-环回测试前的准备"><a href="#2-DATX8-环回测试前的准备" class="headerlink" title="2. DATX8 环回测试前的准备"></a>2. <strong>DATX8 环回测试前的准备</strong></h3><ul><li><p><strong>DATX8</strong>：指的是数据通道中的接收器和相关的时序控制信号（如 DQ、DQS 等）。在进行 <strong>DATX8 环回测试</strong> 时，必须确保与数据通道相关的所有 I&#x2F;O 接收器和终端电路已启用，且拉电阻（pull-down&#x2F;pull-up）已配置正确。</p></li><li><p><strong>启用 DATX8 接收器和终端</strong>：通过配置 <strong>DXnGCR3 寄存器</strong> 来启用接收器、终端（termination）和数据选通信号（DQS）的拉电阻。具体来说：</p><ul><li><strong>接收器（Receivers）</strong>：确保接收器能够接收环回信号。</li><li><strong>终端（Termination）</strong>：确保数据总线上的信号被适当终结，以避免信号反射。</li><li><strong>DQS 拉电阻（DQS Pulldown &#x2F; DQSN Pullup）</strong>：拉电阻用于控制 <strong>DQS</strong>（数据选通信号）和 <strong>DQSN</strong>（反向数据选通信号）的电平，以确保信号稳定，避免不期望的浮动电平。</li></ul><p>这些配置项都需要在 <strong>DATX8 环回测试</strong> 前进行编程。</p></li></ul><h3 id="3-环回测试的步骤总结"><a href="#3-环回测试的步骤总结" class="headerlink" title="3. 环回测试的步骤总结"></a>3. <strong>环回测试的步骤总结</strong></h3><ul><li>AC 环回测试前：<ul><li>启用 <strong>AC I&#x2F;O 接收器</strong>，通过配置 <strong>ACIOCR0[PDR]</strong> 寄存器。</li></ul></li><li>DATX8 环回测试前：<ul><li>启用 <strong>DATX8 接收器、终端和拉电阻</strong>，通过配置 <strong>DXnGCR3</strong> 寄存器。</li></ul></li></ul><p>这些配置步骤保证了 <strong>环回测试</strong> 能够成功地进行，确保 <strong>地址、命令</strong> 和 <strong>数据</strong> 信号都能够正确地回到接收路径并被正确处理。</p><h3 id="4-寄存器功能概述"><a href="#4-寄存器功能概述" class="headerlink" title="4. 寄存器功能概述"></a>4. <strong>寄存器功能概述</strong></h3><ul><li><strong>ACIOCR0[*PDR] 寄存器</strong>：用于控制 <strong>AC I&#x2F;O 接收器的电源</strong>，确保其在进行 AC 环回测试时已经启用。</li><li><strong>DXnGCR3 寄存器</strong>：用于配置 <strong>DATX8 接收器、终端</strong> 和 <strong>拉电阻</strong>，这些设置是进行 DATX8 环回测试的必要步骤。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> PUB </tag>
            
            <tag> BIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture - BIST Example Test Sequence</title>
      <link href="/2024/11/05/DDR/PUB%20Architecture-BIST%20Example%20Test%20Sequence/"/>
      <url>/2024/11/05/DDR/PUB%20Architecture-BIST%20Example%20Test%20Sequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pub手册4.6.5，描述了如何执行 <strong>BIST（内建自检）</strong> 测试的具体步骤，包括 DDR PHY 的测试初始化、配置和错误检查<a><span id="more"></span></a></p></blockquote><h3 id="BIST-示例测试序列"><a href="#BIST-示例测试序列" class="headerlink" title="BIST 示例测试序列"></a>BIST 示例测试序列</h3><p>下面是每个步骤的详细说明：</p><hr><h4 id="1-配置复位后-PHY-初始化"><a href="#1-配置复位后-PHY-初始化" class="headerlink" title="1. 配置复位后 PHY 初始化"></a>1. <strong>配置复位后 PHY 初始化</strong></h4><ul><li><strong>操作</strong>：在配置复位解除后，系统需要等待 PHY 完成初始化。</li><li><strong>方法</strong>：通过轮询 <strong>PGSR0.IDONE</strong> 位，等到它的值变为‘1’，表示初始化完成。</li><li><strong>注意</strong>：在等待 PHY 初始化时，可以同时配置其他 PUB（PHY 微控制器）寄存器。</li><li><strong>原因</strong>：此步骤确保 PHY 在测试前已经准备好，类似于正常运行模式下的初始化过程。</li></ul><h4 id="2-选择-DRAM-模式或-BIST-循环回路模式"><a href="#2-选择-DRAM-模式或-BIST-循环回路模式" class="headerlink" title="2. 选择 DRAM 模式或 BIST 循环回路模式"></a>2. <strong>选择 DRAM 模式或 BIST 循环回路模式</strong></h4><ul><li><p><strong>DRAM 模式</strong>：</p><ul><li><strong>操作</strong>：向<code>PIR</code>（PHY 初始化寄存器）写入以下设置：<ul><li>设置 <strong>PIR.INIT</strong> &#x3D; 1，表示初始化 PHY。</li><li>设置 <strong>PIR.DRAMRST</strong> &#x3D; 1（仅 DDR3）以重置 DRAM。</li><li>设置 <strong>PIR.DRAMINIT</strong> &#x3D; 1 来初始化 DRAM。</li></ul></li></ul></li><li><p><strong>循环回路模式(Loopback)</strong></p><ul><li><strong>操作</strong>：如果不需要 DRAM 模式，只需设置 <strong>PIR.INIT</strong> &#x3D; 1 和 <strong>PIR.CTLDINIT</strong> &#x3D; 1，表示跳过 DRAM 初始化。</li></ul></li><li><p><strong>原因</strong>：这一步确保选择正确的测试模式（DRAM 模式或循环回路模式）。</p></li></ul><h4 id="3-等待-PHY-初始化完成"><a href="#3-等待-PHY-初始化完成" class="headerlink" title="3. 等待 PHY 初始化完成"></a>3. <strong>等待 PHY 初始化完成</strong></h4><ul><li><strong>操作</strong>：等待 PHY 完成初始化，或者通过轮询 <strong>PGSR0.IDONE</strong> 位来确认初始化是否完成。</li><li><strong>原因</strong>：确保 PHY 在开始 BIST 测试之前已经完全初始化。</li></ul><h4 id="4-配置读-DQS-90-度偏移和门控设置"><a href="#4-配置读-DQS-90-度偏移和门控设置" class="headerlink" title="4. 配置读 DQS 90 度偏移和门控设置"></a>4. <strong>配置读 DQS 90 度偏移和门控设置</strong></h4><ul><li><p><strong>操作</strong>：可选择性地配置在 BIST 运行期间如何控制读 DQS（数据使能信号）的 90 度偏移和门控设置，通过写入 <code>PGCR1.LBDQSS</code>和 <code>PGCR1.LBGDQS</code>。</p><ul><li><strong>推荐</strong>：保持默认值，这样可以确保 DQS 信号正确对齐，并且在 BIST 循环回路测试期间 DQS 门控始终开启。</li></ul></li><li><p><strong>选择回路模式</strong>：在配置PGCR1寄存器时，还需要通过写入 <code>PGCR1.IOLB</code>选择使用 pad-side还是 core-side回路。</p><ul><li><strong>推荐</strong>：使用 <strong>core-side</strong> 回路模式。</li></ul></li><li><p><strong>原因</strong>：确保数据在 BIST 期间正确对齐，避免数据捕获时的对齐问题。</p></li></ul><h4 id="5-设置-BIST-生成的测试模式数量"><a href="#5-设置-BIST-生成的测试模式数量" class="headerlink" title="5. 设置 BIST 生成的测试模式数量"></a>5. <strong>设置 BIST 生成的测试模式数量</strong></h4><ul><li><p><strong>操作</strong>：通过向 BISTWCR.BWNCT写入，设置要生成的模式数量。</p><ul><li><strong>默认值</strong>：默认值 32 个模式通常足以覆盖大部分测试。</li></ul></li><li><p><strong>原因</strong>：这一步是可选的，但可以根据需要配置测试模式的数量。</p></li></ul><h4 id="6-确保地址-命令和I-O-接收器被供电"><a href="#6-确保地址-命令和I-O-接收器被供电" class="headerlink" title="6. 确保地址&#x2F;命令和I&#x2F;O 接收器被供电"></a>6. <strong>确保地址&#x2F;命令和I&#x2F;O 接收器被供电</strong></h4><ul><li><strong>操作</strong>：如果计划使用 <strong>pad-side</strong> 回路，需要确保地址&#x2F;命令 I&#x2F;O 接收器已供电，可以通过向 <strong>ACIOCR0</strong> 写入 <strong>0x20000000</strong> 来确保这一点。</li><li><strong>原因</strong>：地址和命令信号默认是关闭的，这一步确保它们在测试前被供电。</li></ul><h4 id="7-重置-PHY-FIFO"><a href="#7-重置-PHY-FIFO" class="headerlink" title="7. 重置 PHY FIFO"></a>7. <strong>重置 PHY FIFO</strong></h4><ul><li><p>操作：通过写入 <code>PGCR0.PHYFRST = 0</code> 来重置 PHY FIFO。</p><ul><li><strong>等待</strong>：等待至少 8 个 <strong>cfg_clk 周期</strong>，以确保 FIFO 完全重置。</li><li><strong>清除复位</strong>：通过写入 <strong><code>PGCR0.PHYFRST</code></strong> &#x3D; 1 清除复位状态，准备好进行测试。</li></ul></li><li><p><strong>原因</strong>：确保 FIFO 中没有残留的坏数据或错误状态，避免影响 BIST 测试。</p></li></ul><h4 id="8-触发-BIST-运行"><a href="#8-触发-BIST-运行" class="headerlink" title="8. 触发 BIST 运行"></a>8. <strong>触发 BIST 运行</strong></h4><ul><li><p>操作：通过写入 3’b001到 BISTRR.BINST启动 BIST 测试。</p><ul><li><p>其他配置：在触发 BIST 时，还需要配置 BISTRR 寄存器中的其他字段，如：</p><ul><li>选择 <strong>循环回路模式</strong> 或 <strong>DRAM 模式</strong>。</li></ul></li><li><p>启用 <strong>地址&#x2F;命令通道</strong> 或 <strong>字节通道</strong>。</p><ul><li>启用 <strong>数据掩码</strong>。</li></ul></li><li><p>选择用于测试的具体 <strong>字节通道</strong>。</p></li></ul></li><li><p><strong>原因</strong>：这一步启动了 BIST 测试，并且确保其他配置正确设置。</p></li></ul><h4 id="9-等待-BIST-完成"><a href="#9-等待-BIST-完成" class="headerlink" title="9. 等待 BIST 完成"></a>9. <strong>等待 BIST 完成</strong></h4><ul><li><strong>操作</strong>：通过轮询 <strong>BISTSR.BDONE</strong> 位，等待 BIST 测试完成，状态为 ‘1’。</li><li><strong>原因</strong>：这一步确认 BIST 测试已成功完成。</li></ul><h4 id="10-检查是否有错误"><a href="#10-检查是否有错误" class="headerlink" title="10. 检查是否有错误"></a>10. <strong>检查是否有错误</strong></h4><ul><li><p>操作：通过读取 BISTWER.ACWER地址&#x2F;命令通道错误）或 BISTWER.DXWER字节通道错误）来检查是否有错误。</p><ul><li>如果没有错误，测试完成。</li></ul></li><li><p>如果发现错误，进一步读取 <strong>BIST 错误寄存器</strong>，查看具体哪些信号发生了错误。</p><ul><li>可选地，使用 <strong>BIST 调试模式寄存器</strong> 来帮助定位故障。</li></ul></li><li><p><strong>原因</strong>：确保在 BIST 测试中发现并处理任何错误。</p></li></ul><hr><h3 id="关键操作总结："><a href="#关键操作总结：" class="headerlink" title="关键操作总结："></a>关键操作总结：</h3><ol><li><strong>初始化 PHY</strong> 并配置相关寄存器。</li><li><strong>选择测试模式</strong>（循环回路模式或 DRAM 模式）。</li><li><strong>触发 BIST 测试</strong>，等待完成并检查错误。</li><li>使用 <strong>BIST 调试寄存器</strong> 定位并调试可能的错误。</li></ol><p>这些步骤确保 DDR PHY 的 BIST 测试能够正确运行，并在发现问题时提供调试信息。这为测试人员提供了一种灵活的方式来验证 DDR PHY 的功能，确保其在生产中的可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> PUB </tag>
            
            <tag> BIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim操作</title>
      <link href="/2024/11/05/vim%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/11/05/vim%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>VIM的快捷操作<a><span id="more"></span></a></p></blockquote><h3 id="设置文件格式为-Unix"><a href="#设置文件格式为-Unix" class="headerlink" title="设置文件格式为 Unix"></a>设置文件格式为 Unix</h3><blockquote><p>在 vim 中，你可以通过设置文件格式来确保文件使用 Unix 风格的换行符（即仅使用 \n）。<br>输入以下命令：</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> ff=unix</span><br><span class="line">:<span class="keyword">wq</span></span><br></pre></td></tr></table></figure><h3 id="手动调整整个文件的缩进"><a href="#手动调整整个文件的缩进" class="headerlink" title="手动调整整个文件的缩进"></a>手动调整整个文件的缩进</h3><blockquote><p>如果你想一次性调整整个文件的缩进，可以使用 <code>gg=G</code> 命令。这两个命令的作用是：</p></blockquote><ul><li><code>gg</code>：跳转到文件的开始。</li><li><code>=G</code>：对整个文件进行自动缩进。</li></ul><p>使用 <code>gg=G</code> 后，<code>vim</code> 会根据当前的缩进设置（如 <code>shiftwidth</code> 和 <code>tabstop</code>）对整个文件进行重新缩进。</p>]]></content>
      
      
      <categories>
          
          <category> VIM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-swap_4bit_block</title>
      <link href="/2024/11/05/Programming/C%E8%AF%AD%E8%A8%80-swap-4bit-block/"/>
      <url>/2024/11/05/Programming/C%E8%AF%AD%E8%A8%80-swap-4bit-block/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4e95431e3451c4a47cac61eb048a3eb073f146c1118d7959f460f340d3f79e2e">bc784a9a828376686ad79bc9be5654d361b361fd88beba2111ec0856b1960915f938a61ca008a7d77c2c4dafcc20a13dec000d6e8dfb085dada8da63426de172c8d43ffc55b872d29be296e19b6912bfbf4bc145b62b5e3902781fa369346d2ac0cd153de12acc03908056048b3e24496c6b7155767cfdbe4527f7541f8ee1586638e2538b22c9ebaf2d613266d2f2aedeb0af7663d048464ab0d4cb687655b353490564c428e44e8dee2a2868acc53f0238f2bce6617ad6681d84951ae70e66239abaf093c7defa8a75ae902103d20561085469a55a56229164165b91d07464b9a843b083a4d10427e910f1d4eb2c6f07b03572dace8343912a7fb9d92cc1f7f7b9adb2dc594f01abd348e38f87b3c9d6c39d12090eb92af7d4cf66f739e48bb1c43f8bd9788696ea855afa6acae17baf6fd87c6ba237bcf971724e725efba24673f1941111d496cf16fa1ea10c248791adfefeabca682d7413f14457c6e5a97814265248e28fb785cc210c47ffd1b8b6356cc052ece5dd4281f8cc165742e303a353a7e51510db2d921196d907d75e9676b230a3b91a98f4f01b9910b72a90de7bd7be65fda8a636f568025c115393f7caf937a4f3dad00608fa5941d51d13c428c0eab6877da9e5ee96d3503650e30c2a541060e789e0567ddd8132a1afed0f6aaac0aad8bc22175521f656bf460384a10a41ead5de0c84c0052cded6f3770fc4c63ee1469b66ee53b6488920d311645b410aea432c07d03a22270a48506c099d0c1cefb7deda259cda6c8c7d9e7d43df4fa067ec3a32362ef89ac913d396408508a8ee32bba7400a52aef511d357fffc9b9da056e44c92ea7a47e6448cb96b770c3e04ef062d68978a06510f41cc3c482228faa1f1789b828db47a2acc184e947312aeae0de8ddeaf290f2bb0d5cf4cef29bb3c2ed1703c1940c4f3bfee4c726849fdb9d9d3e0522893daccdd622b28a31d1688d60a083a292b724ba687cf2549fc1058d1256e3bb54a278dfb048a7e7762936b20d84aebc3c814ddaf395c682523217afe8735fe85200e92de95a9ff6fcae418747ae7b7950bb5f4abeaa579e811a25af5efd21c0f072aa85b9112972a7568558d51df06eadb3b5bf3311c6f9bb2bc0e63e71eab55e0e8f6afd94f5d13209aaef0a26fac741d3979b836e67dd27da8afba37c082ae2da12fe2d15ccc0e4aaa1504a4a7fee4d22b5de7ae6e1d92ed22d016ace30dd7473d99245c98d61c220dd34a0a980308949b55ea7fbd01987869a70c756c1bfb502c4440e48d74af1da4f1792d3f580c7013a6ed769e584c57e5b29217825b8b627a540301ec10a35b50dd8efb094bcda477c1b6f87c658b6c7b84fd461aba87a80aa3e3a0e2c0d870797f162a19cb32435b6366a52a018004fa2281bdb184551c88d2408b8a37d09c3a648fefb58bf525ce29841a312b44a1e356b31804852f6011bbb9ca5e38d87541e6bbd01c845af346d4e07422f6ab83dc63d0ce23af7ac983a121f3a851639b0300808ad5671f2afb96c2f723e262d9f580fdb080251adc0758246b3e94c9b575bda3b6835ddcf2ba8be22a2443a62d3af16f724e987c7fae4d2cab8fab0726e0ee4f233d3c9655a84b7e7ca9ef05b2b8c1a1182013b9f082314cd22c878bc9c0e551f30e08ebe028e3b40fa9cd3ba0ba8ddd7f6a6665ca03cf8d00e19e8b87cf7e431583d16b42a2921930f5f298a964951756262ee21fc714b77c364fd0b1c347d9b3c708e7a3486124d2e2ac014ee010590936df494bad3c2a470bb79dd81a672ffd5a78c6fb7666a8eb1499575b3114887f95eb843098504db7ec0122800c498b1b82ef26f762cdad14ce809f34abe0b4d40552d9e01bae64a9a513e0a2c79cf40e7547ed496429fd693c00b6b1c339eb78b3e20b027feb1b83b1ba1299eaaecc70ff481642cae2aa3039e7bdbd6b179ad9ec8d42f81ccf23a05bb9101f95bd37d5eeb3e2edb2042bdd9731b0ff6c4dbb66ac639e66ebf3e398e23e1ab558045a99fa7377df298d12386cd9363b8d91d0b5e1139240c72bc5646e6bc253e608576559224aa38945e1439f4ed74313b48c6c782d5e8d2d56d9663f581eac1905c9561b49b6ac95495e3b364cc26ab4a787ee8578b12a2416d7fa7fd6edbeab2e696e0bb9ea4fc8b65d577bbd3214e417b54a246ab6cd9fda3532f04382e47d058fd1268174802a6fd8a27dd6bf0dc5a76988421e2475ff7ba03aacd61eef89f8bcf5db1730333bcd36cdadd293fc731acb3e3bbf8580721bdb90e468309bf3c3e28df1ff3b09b9916fd24f84710b15eacf3d9ad71a4540e921e21b7af13175973785a4c3840f68f65a3e9c22a5bfa3ffaf3aec285487e981fb54cfd978f46bf091e0bee32ff5c92e9193b55b94080496e27da76848ff1893b305419aa29b61e83a2b2788393714b6973fc6ea61ca031eb1298ba583afee45346278c11c06f042001d8eb5a93639cec89a72919137ff7ef288a0b2985bbdb752d9bfcd53492c45f9cbaeaac863c0e717ba35ee5353c5e2e401e407f63ca5ee37890bc92b478c2082ee57d522c3d360716b74a97a9ea651ac6603b9096b5dec21f32249473b704dff17dd63e634ca320efd37c95a4f421668a97ec29736c38d13b09b4127d5354a964deb78d55285be0cac975022f9c9ee98954f5b1a92a56cea0794e4879a7e6e5132bf83c6b820b4d1437bde3f5ff782ff7d4f72d15ca3c42348de0836ec59c49e1d358e4dcd146803758d6cc7c11bd7574bddb965c7edfa756ac3f831c4726d433ee42c45b01fb45f9d50ff1cb7061b4c69b8b4b2e2921995c557662e37d3000658eb7236cf830cb66e2d690b0e4e617901081fa8b3fabddd0e11c2842e1ce09aeee52c91004aeaa31f6c6a4ca8e051356f545b565d3f471131111dabeaaa599ae9b91ffdaf3897f804d95ad6cc25acb9c5fc936241d2957ec73847911c0f04aa9ba3769923c18050874989ddbdbed51d77a37c3227f727059f1360b6f2cbd44bf669456fc2bdb6c54c1013ed8f1ea61bdfb80aa6aaa1bb49af733b63adff85493e3aa730961c2cab18820b709a0f84ce981c2555cd48dfc0a980ae9212b2ee7c4e3f56de51cdb76336fc145ada79bc248862f349094aad5e4730640d3f45eb8478f6b3c1aaee4a8e30c916f7b7afa3503f8a1d3fcb27274d82984ee65085c6f027f35dc10cf883b6fc946a68e950c5c4f28e3124ceb3e07dfd13d1d70d97922d0ef72a45e272f46fb4f511b5ebca9a51b4e64ff55a7997fc6a50ae019c97441b39ec352159700831a68daf7a3c691da22e646178ed8944dc92f6e791e0812aa8e150a5a3b001faa360822c0e4376cd16a9c14a88d184a3ef11ba6db3e7ef55311ba87557e392f58a065474c9ce05c559c2f4e33c4ee815f714787a4d6a4c789ba5fbd218d7d6fd9bc1a9e923a7b02ced7430e2f6bde1b72e150de19ded699993dc4bf52dd5c9179f56160a5f3f515843ebade91f544c632c806c6c9138a7595d7f1e4de84174e4dc97d02d529aa5780ac2c2ee6a9a2cf7f325558ebcd9e1d8f410a39fcd3b4fe76085d6f997e8fd801cfd8c16069c00c0d5620756edc74e416f783e68ed15538c19877865cc363e2702b8e8b70a5f15c77e6f1326a3d97f5dbbef5978d51831d62a7768b9cc6a43eb8b5fc9ce1903917eae333446aabce25568335cb6884fb412784ae5d9c11b4b626590182b253f8636993f2c4d223d672d09ee06aa72929c356207ed6492cba39ea03f2d4d90bcb65d56b539a5872ddc7b49baf2f226017d2c63ddeb89e87c7d4bc408ba66b551d3ba270093850f674c770582051a8482588b1e5d7fb0e7533666f44a9bd6d593abd97792c68bd4bf5ed21bf6648e2c7dcbe165327b897bc8088ce8e0e20160f1a1649fad2bd3a53f37687346f8574646b18a857a98c7223b81d1569dc6b52fb1e3ae68b669934ee2cd4257b0aee8dcfe5a627a5069a0993c177f8353fff104af578cc125cf7d4f75b42d6c45db45294c9417ae544310f7c52af2d1a02d02bc9d5c19ec5557acdfa2c8b3bf120ef3783cd63feacda3d7d554ac590d9955fc019c3644046880a3169306456805fe8116943065566bd32afa1eaa8e5858175695824a3c03ae038cf778a796812942a2f0533441588cb529979f784254628a5d23e0666bdcb209893507c67166c02307642eaabe7d3bdf2cff0d277be431a077b547fb5ffc5fce17bbcc02e407518637ffa171a0e0280101ee8ac838fbbf6ea04d6ce5ac35dd6ab4048c5ed0849f002134f3d936c29df8a84ac604aa8cdd0bcaa7fe71db2fc4e6490eb959de5d45880ec5b20355b86c7a909827d6d76a287fe71c9fb4e82793b131fec16289382f006d6544cbf31d10ee2579ddb7c0d308310e9478e8d2c48a25197ce17dd664a667dd7dee8a6c067c383f86b6a86f4fdf6aa35d8f069f2cb6b53ff8af8dbf002b27f28221743de53f22de894c6c272c24eb6c515da40c53e528811c5072401a23ebd55b994f3d65e584d45bde538cd87b98ef7b1e67f6540e493643556087ac53626247d4f6aa97d0797fa2429e4a7481bee0c629cb6af47bee5ff629418f0a822b250cc1c3d8ffc79acdd00e53d195c0a8b57ca24bb08415409377abdc9ad45e32ee496c758a9602b94b89574095e2b0a5708f271b1e6960c5444ce06830e45dabdedc705a2394ac475c0861e55e5bc96422258872f3b03c31ade4d43f1bff90e6d0de0ca3cc1a494dc6a4100bb340cfca4563d4f4f02e0bc9203a19c34725563e9e83300f984a17f1affff130b430af12252b67ff3bc8dc040439825539ce0e2efb41a38fdc94b6e3dcf109fccb4207232097a3c7b1b570fe6e63f244e4f83a1d21a97e3c56b91e5ead37d75308b27dd7ce57b492d009733f858d9729b350629730d961c883d977e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不是哥们，你谁啊？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于C-Model的验证方法</title>
      <link href="/2024/11/03/DV/%E5%9F%BA%E4%BA%8EC-Model%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/"/>
      <url>/2024/11/03/DV/%E5%9F%BA%E4%BA%8EC-Model%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="84c95a067a469732ba427cde4507dac4933a2cddd5ff38054478d8419b0eb057">bc784a9a828376686ad79bc9be5654d3969156a2cc4729eb4409fe266c6a49d821a48ad5e7f4c037362fc643ac797f9ad0eb115845ba4a36ef250aa534ec2a1decaf32b71425a12782b02985bff2627e296955a7b0b2ff766b53db46f3eca2570359c4f0feff11059b3981d72ddf6bd9a0b2f05fe2e4eec6b60a67c7ed3f6a60a6aaf7ba2a009abe75c43097b3728a3ad8766655b273cdc3d6e539bc681b731587df7c5e34e0615d9f832ed8421fd35f7636c3d7c6f4b06647ff22f7f72663c143b94ff95afd83fba6fdb2f30c3bc3b462dee06de6bfcbf0245419f3bc985a0583bc0d4bd03806666861c34844458626789a03168ee97fef0460e96e78854073ba1915a31f02ab4f76ee1a2eb9bc694993587744d4db3e919b9165133759acd98e5d8debd59fd3f2108311f6d8071bf025cc2a1abc76ad6edccaf32a6a2a7d0e5b9a175c02f2d0c46923f901eda055f588878a18e1bfc002c21b14ec8ab2f17afad77285296143470dcbc4087a161684f7fe01d4605aafcb8327a8d17a1d5c8e41463ff04b8a6fb6e2b763e97e75836b56c82243536bac5cdc11bb1a5089c92ea02a33528307774da7ba1435c9d817e353ddcf6a1e10d63bd32359bdea82e4e3e5562c3c1e2893de341e67a0faea8e5e677bd268c76ed7c32f0b146b6404fedfd52b2173af7a7d8cf95b01fb0cec54b1f8d4fe8545dc61c04bab1a8d78674d9c8051319b21c381a0427346bc5118a95990811fe5ee48946c2bb23acd9f530c8987085ca110b4ac9646371269da17d1b891026c986c066c8cf86f30956014c110535ceb6d749849b8cf373475b1d5bdf99322e7eb6852c9171476fffc491773b77e34136aa6e46c9469870bade600492a04a37cf55d6ad00e59aefabff9642706a11e97de55e1320ef5dbf4396f66d08572c68704acab487e041fb0686d33a2f3f12c02c21fb4d6b4360e5c4c8c0b3d9d10d04d88b0bc84b97689d99e465f8974880c681a214a9b8aa5654441e7c1724a9050597af028f253a1b76abea348628332d5fb90341988d2a4eb443b1dcd6d963814be86d4ab269ab4a4ea1d817174a6492f98acc20f45a66d4191eb95b34a28b5947b762e9546e398476072a77a6a27513a66c6a5a9705a95db1d6285dad3a78d7a6c03b116323ba4e394a01735ffce0f427fcad461d2c1e9ef25c459956e4fa6c18a9d69d0e6aec1a864d90746a4c2fae0e76fb34fdf48e5a6bd57a0afefd5d28437bc6c6e664a9cfa40a78ed989fc27492e4375359f4db25bed28c4611b530a435cbfc9849d677719c711e67ab63c2c51767c2145bccac9b2795e81e7801148abde1756c87d8de61c4d1e2c6c54d2a943d843bd1a08dc97779afcc8ac1d5be7b253bd08dc2ec1aedba976ecbf9d9be788c3cdf5d762243ab86a4edac7a239d1ccdd5c3f34f95f1fb890c8b8d7e96e4f933acbc89cc519e9acc1b1a984e5ff721386e00267fc9196573767a30576492c3622fc71cccd595f095d72057560a92f02b04f4f122d6e5f1b6548c155231e1f02f980b727ba6734286dadcc3b05f19c56614246ce84c7586ee530906294a726c7531a3d25143d501c0940db9e7a3e1ec5143d6d722e3435db1302336a630ce5111f8cb1a1feed34d05b0770bbc19f8f809fcce7f31595029d33289d03e2d044cfe0e69c4fe2a0213ea25fbd36c56d15589ccd8c31e9a9767ed5f38153e499bedc30fd0941a695a7b693dd1c7460443cb05de5f3d0a66bb9899350d0dd5e278205515d5a7ee689512da3cda3d1bdd3f2562836002651c8a960c93d679dce7600d0f7fc0e2bfc3f8a5d89fc91977ddd1f2ea1a8793acc5b82514a69929951bb8817f2b6920d84172a9361080e66618a7dfd068ac861a973625fa0d6871490ecf61d44f5bbfdfccab9749b8cbb555f8c795cfcb7e94c5154d122b5e06243573fcade37de220744789c624ecc7c96df380a57190f6232423c00a7fc156adca128f924c23bd0daf5be1dab7faf83c14be1d05bd0d5a5c101d2af580c36f343ccb243634e0a930b58b49f89b204aebbcbbc368ace0987453399444d872420d6da8de20bb8350df96271904c69089b36ed72dd006bee94ef734204b84bbed807a0c10a65aa4f465398ea1d81ec6f44d9572e29968eca4f19111f161e190b16c104520a6241e5eefe2864e231d1a2881427c7ca7a6253d597fbad3f006cbccbab31348612fd6760c585d127ae97085a861221c6dd49ea120dbbb7b72580776f5fb83f1bd5e647a1c4f3033e4c3528b285c320820a9c87da9089b0c22115ce9a573d5d4dbf15bacf3f4d326d68433c4e0020966382a26b02b78cfc2fc5901e0f137d929fddd0bac236bbd54dd8593239d41861a906afd4d257dbdf00f909a0cc1c98fb6fc837e0e81aa273da0019f43576ce503221ed8438ee582471d4ca3e75a2db14ddb06b8a69d49a88f37920c40ac2846615da1fe0516817b49766ef38269084aff54685a0594dc6a7318cac5d3b66ba8a69304843741ded943be3d7fd8a9c747215ce1be51c19a55a5c455d622d50db679641f11c70ab4b36378c0a69f1ac2e73d76cd12efa2742bfa2954ad4612e3155c9de371d58f625cd373608e65a4ce27b71cfc75ac282eb4f151d33ad66ae3328e330219e9e466844bd273b71dc4105247cd30fc74ea6826b67fe5be05b34381c1e34ad96aa3ed128dc4ee61a422b894c079b0d9beb448e4e773bacec44db5786396219437e10d084a87e7952a61e1195444215f4dd648557db0c3b73d67ad108101df7c87706b9363e7946c83e08fdab3b97cbad7e460524620466196e6eb01403055b2b8e4d4f4a74ea19ede180f30a9bcdd571218b37909dedbb7c2f7bfb3587b9af224bb5366671bb5a1bd9a83e037eabf4fdfa38a775099115880ce17283d191896679b2b6c582fc0414f01c75cbfcdb9959ef90900509c52536eef878ace50c77bf42de46addf45c172167a9f34f617144e1f86158648b046613b2e8e871a6654c49e8213cac8b4de5e4d6b9cf29f436cf51f5dac66f9608a8d729cb10db91c50c7ef9bfbfe2450b5f61a9db1e6f9e74ce851ad2284eb35a4ab9fd4b9b2cbe97b09e89ecbe3fb3e3880e9cb4ccee75a0ab5e3f75a6bd86d3a5c43c097674849638bc8311560ed01f72af03463fcf3deaedb20badb478ea6346e5cd6383dc63338e9630fe95d601170045f674e64850f229eec0f05f87d142e5a39f3ce9fbb79eabc133c8ee7930d7a08a2a759f09352b59061cd055e366b8cc2bbfb47cd6b7c31254c4e46371c54b0e166e891dffb11e3b312336abcbebf20a90be8e61dcaaba6bee29de85fea986c3c14dcdffd9996976c715d6c1f51b4a698b1dfec6b7a9c36c4094fe1e1805288e9ee6630336a62b87c71b83a0b57d3e8437077ea92d470abc5bee7e0778ff2bbbfd1087f32ed1e021934ec294f99c48d134359578bd5bcf6c2d065923d1dbfb8f96307158ccd9aa8ba91163da5a0e5ac965b3fa66d53e15fc36a1c30930efe954b124fd4b0f439a89e54d21da9991306824eb5ca6ae2eca09f15439369309844bff517b61892ad15b2a55cbfc16aa05ccbc3dedae447eba8312db2896480fe38530a7a69c6c0ef30700c5994b86a3e72a295a5d86be2522ced91d30338c37165cc97cf379eeb80ad7d1be830cec294e24a3d016b626f70c7802cad27babc61e345b946811d95a8458b30f76b72cf91d043f4a2405e074dc267fe8bb49d2129c8a68d7e4e6e86b0ad08459948b35464bbb75ea9a51939d0ccec5fcdd7c517802e16ebb1065cd7f35bcdcbbf25e0ec8a5567fbdf70038e6053720320cccf1c3e2dcd08bfb5e6849040c7544d241badcf02bf35806d1a64744d030b1f18ed924fed9a24bf7d8e19ec6e2d57a2c8ebbdb3bb2a635f6c3d2eac25d139d25d217c157a90f9bae1034206292d80aafa035984b56e9c9aeeac0df9d9350c213afe3736dbab3cb62d0dc698b70b4797372cb47f1d83dc80abac7426d2e317a236e0396209ffbad2113658de223a8020c454a0d68626dc0ebecafc8509090cba0048d65eab9006fbbeb18378c33632a3182b72a695e066a0ffff6065c29d705743f0abeea0afac9c98c53a9dbea141027e079d99fb365e3182e0651bd75ca48ccda4dad274db6d39f1829a64bdfbc8d96124a02b8e7931149d7df3bb986ad88eea05267512242efd555aa7246d847b37cde3568f3317ac4ff90eb638e91439eca03c3f368d020b3836bf33e14a01a2d02429c822d067ebf7d3fd86cd17de336e57f348b38e2281d68a6464a771cc5e356a58fc1e6675ecc378ff73d51d02a8d9ca4454c28a8caadfab74eb377c3e5cb0e04c2608064dd3796962cdee68de2d1060b347355a855cece97060579c362e6dfeeaf0ab8dea259ab97b4091a7762f8fc9a5404fea989c39435423e3ee078b4c6e329db6140b809d3cc2647ee3a3d0f62be92f611372e4fbdd7418258819c92a1feab13acfd05dffcfd9a7ab5c0f94ebf512e45d90dc4465f7ebfe5e9bbbaf9722d159996e2a93466b74c3ffd453bba93d615f72a02c4282e6ba0ec23060464e5a1d4ecac0343e3975c02cea647af37f8428d300cb16154b59bb924ce272c9115c1fc948dc300f032d8a1c4c04f650959bb30b30d504b66c74327cc915b9738cb981cca6a07203bcbaf80992c0f08b454f7bb8d872cc918881d9662512909181da5ecff04b387263c889f82e25b38358b4c52e743f14d8f4385d197fee105a900599e994548f24d2d479564efa03e2cc917133b00e942e41bff27df6bb1c88ef56ba7af74ad64e72cd07f252c49759106b12f5d8333288aa754e70462c62c98a2b0b57be86410863ff955fd03f672889d34c8ab84519e1137219a337ab755aea470342d9b6b4946995a33d4394d1206862346072f91dbeb842e57e658ead30d724f97ccd094db920be86aa7625f45a5543233e609bc8d8c59c2786089e903b47fbec635f0ac3408b56ed56256eea90b719075581517232ccf19506b32b987687e32bfeb5a584d72ca1da9ae611415da967241876a18c45d6c9c9b26873983a4287c485d0d133b22347cf89e696d537b8198c76ac2ef0ed93e6183d79606b89e3cc5b2f591648ca7f318fd9473aaa0362fb5e63f4099e0e2411fa4aafcb5c91fa98ed17ae92cb30318b6a44b169c176ff5ac03e966759490f6cb82ffb2f9c2fef654f8491be6efb039819fdf64aa35a444f35e7e71b1a351be2ff601fa69c65ef398314bedf4c2f8f483f69ee9eb5b760d502ea8253f7cece3f27c0fb7b378d4b2e26c7684e8c340b011244c2a98ca0e78902a0a8ab1d2191a5aedf99ae540753ea8de8ef363b2016c11358c3e821070073d140b06617e7b40955d9845794cfcd27d208b3883462a0bf081fd0295765cca3b5efa6a58ee4afeddfdf306891107bef469558c8e248bbf5a84105f16651c97d36815fa88d7109178e0daa109b9af03605c532936d5eead001933d05cf301be28f81d31cee16587082fa66f1ccba7fca876b4365e66a0c8a676bce1f05f49827fcff2e82f24f5110998cd33ec774c72edbfd7ff4fa9cc52e73a473152406939689aa382fa9daa3570bcfb32b84533101e3bbb4d937c106ab0dde7ccde46f2569efc03f744c3b44e266501c96a917334d6ad47cf2780ca51d93ee737416347a54896e9be0c7357636cba4afa74651c243b9786633c2ddc5d16e775e48a434949382eacb3e2cd5b4a5617a49dad2796d4049007d35c3cf82709bd9ddb12ce518bafce37b84afc78d4b629bbc74e0c100666347c54db8618c3aea7169a2fe5299b0bd94646b2861c7913626300835f99cd589f6754d523d49e1a17d2748391d07feb025490d7bc1060f2d289c5c31c61f74e542f0ef37f407491ad16ba3802b6eb7eab06d25109d29075bf0c8044096eaec346c305fe6f1e8bb89b21d601d3fd012d228e819299b603f2addb6ab7809a39c1c9164fa26463953628f6a7f25a32a088a891478548050c563b5446d56fabe01d7718ec9ffa41e90f04af903a0ca2be099849c907e95457ce0f9badd155521906ab596c4dbaf2372d7813f404fc2c363d28d47069776fefb9fc0e5fd4acf35b050ee0e1b7aa9ccb55ed6649f03f223bcf70f08737cff033dd16900693fd73f63c3627d9232f043ded22ca13a8133cf92f768ca1756bf489c5daed54a8ca55d479457be06affc51bd8b636e75b36242ad4e5ac15b3bedf8daa39e2018da8313563d398da33c056bca449405c7edaf270ef5c3fca7e2dd3eabba0b39f5a7476638669a63c28fded46f91d50f2f0548d0a1ef3027482cc14297406c78ab2e379f0fc45d70c38d19925273713e0f3b3ee0bae22510cc5cdcf0bacee9889969f22a15d01dae4242ffff3593b7aabb9a80472e01a5a60c420af70d3c44aa565cf5a3407da3ddef261280011e07ad5ea032ea1bc0d9fdaa7b106fcbac5924bc0219fc104bfd7474a7a7806a78361115e75e57e88aa79cac739a694b04ee548196d76153799a4bda3f13aa80f1f705040140509c9fd9496d2cfa8aec38e70fbf4d82b2caf64afdd7977a03ba3fe3ffc33e5d0dddc27f4b0e4822c61d172c58cd67cfea82a6c05e9eae75169ad6b7f5942a28ea2f55a4f35500e2706ebaafba4d230bce23677d864d18c504119cc340ec73e42f8fddf8fc4d0485c86f08bdc3e31c3986a2fc2f9a58e4481c061ef12da3c961266d5371a38a2e772536783f41806f9a08ba241864b4f015337be27b13b5a195b84181dc39f5d9e50757c6f3a1dadf78f7a1e43811fdac71f9df97c72e4dff038e50cab5cc5251857a7b78809cf13a9110d69fb453df4bc2b16bb127ff245422c17a12f6f5a95c335cfb077184f4b736eedfad4f63d70e55e2b0ce00ff68150322b60bc84ea115e9a2068ac92f3b5b44ff4652a335a525f6e78a471e1ebc463afc56553199205745eb6ec69fa13fde5aab207af0a7f18c33f8b9d790ed682dac26a0e22e57c8e3cb0346bdd3327de474a39eacb09bded9a7df3bb48f8a967c0d84464684c28b7094801318b4f63561af4bd3f188a85e9ce41ffaf9b3b7375b17234c32014f53bf4848ae01952b94f8ecfea5ed209975068c70694cbfcf06ab8848588c1858164ea7e74ad462ae8cbcf43f7f946b7b648aa94fe9f46de631b94941dd8fee89cd30cdaa5189b07b406818f7a33085f5c776ebfdb81d40270e83950e1a8ec0d4d4039c332da9e0b7b8596c791d6a37c2ef22cc70846ff1730bb7b97f4e9db64cdd84a25862390dae1b9258e4fcadfc0d2138affda914f9c2cdc310577bc814d7726ba891343786e4df6c6bff7f8b9a495b5e7004281b166705cdb60df44e39f6d9f9456f67be8620fac3c8cc96a9ec2689f23f9505e9536618f8f813c687f9c69d0ae98b6441a92a60fef33eeb04ddb934cf58738f87e8709345569b6b1ec0fed32aad7c40fcf1644c9856f74b5623b7255b57264dd98c7b321694db76550974553712c7b661dcaef7d9dd5b776bf1ea693d73387b145713962812a03da2b37027ba97b3eacbd8429cb7ccd12371b1b0a8abc5a3932cbe4a79fa130a14590bf815dfaaa30bb7a119702f4feb4166e74723c4d0a3e95d719895b331fe1739bc7bb361a19eac49442c47e2da4a36468946da4603fc226cb9e97b60df801669423d78f9899c00b91a491c0bb2113e4ac1f5ea279ab8a9e07bf8dbeb18b7d564e3e1807154e212b37a11a9867613b5541acd0f8a73e262803b4caf2665daaab7cae9b6a269e63ccffdd0e6c62cce17be07a1d3a0c79156b08ce72f05ef59d86a3ffc05a2fb1cc0d7893e43cf3da0e592a3b7759e6e7d569020c9fba4b971586241c8cdfd57fd84cd493908f9ac5d6b8f2ab3616b2603ee7dd632dcc58b0625e7e3983c730aa84c8a990ecd5c86f6a2c6d4a36dd8157ef54ed9ec1bfd7ae5864f6ef3d7a787a7115134ee3a147b85c30f3cf370e8be5238f185009562bfe77f4d6a25f66f329d0aacdd20bf933f7032642f6b36aa208442d4aaadd87bb1d2875635a8d0a3f9149e822f52aaeaaf7ddae0ad0fceb2987e41785469ce91fb14a4bc060540d4b55bdc621007fd33aee3e2036a5911bbc4f3f8834546a3fda381fb529d76506e95bf46ed1964b7e0d18a529304629e828ca3ff337e919a1beadc7882596b4b651221faff8ef9c8ac8606066f31307e6bf0afa3369033f34fcdbd6c04f9144472fdea275a3997fda92809aba55c1ac163446a9b577486f74f5ab2cce6ecceccfa864eba8a62e4601a2baa6b92cf3a6c2b98d6b196db459c937f0e581dffac495375d0450a875fa7904549ee5613b280aa935e2bdfd8a16d61d496f0876a986aae8491face5e6877ffcf3d71fed3d43bbf0c8c23d4e634657d2abab6b5adc06079e5454a85451a6bd459ec76353b554a526da8808672da827921b349ab696f99b23724aeecd001326696b515091d7c4fc6138510a84c92d1b7058cd1500f0f50fcea86a16dffefa4ebf7a03c6fcea3c44587a44f0d6bcc094415bb1244601e317a8153553a61a4ed7544bc900d0b99ef33ea894a5957acc52109be0a5d847fbabb6852e83cb50dabd7773904983ebeeb316d24f275535345d42ebf25fab2299e3507b1d26e6f1bc66433836b42d7a38362dca296d17effb4e24ae9846b3aab0960571d631458e9a78a9608a76b84e13b2d294cfd2a78bd5888d2460846c230a328ae1da1ef27a98c101e9b7ded9945714d0ebaa4d1ab2015adf0cf53d545cee88b614e1311b34f140ae94e2c1955257732addd4d9cf9dd103d13124739e542ed2b0f4a5ee2df27a7926f1cec3e9e508c6e41d0b38189fc2a7a0ca43bd59e6055a7679d0888af67fe8b798fafb493495a8dc95ee81822fd04cee832c199e92b1f20b77e56d1ea9d7bc7bb1e1e8c54e280db89f2ffcc9e0cb292eea610505bdd4290cec52ee898cfd1d18bda4a00af82d1845490c6b8920f84a66e1c74e6adccdd69934c5a2655f4fd04517297bd356f7c9bf4433f5a48f837af64aa70bb63d9fc660ef70c67b479760ff969bb3b594f83a88ecf09a509bf4761a9fa0fe5557f71f0cd5a13e2c959dbeb0d648b72f6cde6c86b532da01d1a1b3d7180c3245c5a193903e90c4d27e45a8d60442b76bc85510773e9b55c54727902ab6080f1332e1b3120f05f9f5ac06a5dd0256d5685e2268e459666c3b37a0aabbf386d444b12bb6bd72e4341ba9caabe15d82310add8adf2b79cadc67e58905c5653412717f34785bc5960f02b149366cc792c1b32b38e1b67891e5e0a840ed1b19ef0d863ffc3f5a538c2d312e9268d8ca82fa894ab34ead5fcd9bd0f3bde67a3ee5675399b13fd1e7910e0f7dedefee44521cff29bffbe5396a1fe18f6f84a77d3454b6720d8e1fa3b4dc445bdcaa822e485ba9db3efacfe42fc63fb55dfe520cf5793a9e06b1911d7e0146ea6043b1e91c204d0944256185634ec8bd72a257d03ca417ac16ebbf5e5e933dec51121efd080c9cb48a962a8e688733f1ac4818d8c29c02372e13554f25aa068f33de4dd9ae8a27fce530156587c16c147b393b243e2e933159001d96ce26d7e137cac76216147cbbb294a46cab7bfd3f84fe4f7c3a33925e3424f14b7132f29b49a677031d47349d31add43aa5405150c525df1b7d9fdf19bec0097ab4beb6b792407801945b6c3990f7730ee6e6a2cdb2eb0ebed732016f642d57d2c56c5ca9bf023056ad108e331b7d8eeb314968edfadde2feadc138738383bf45891d3f676f025ae8847dc6325dbca275505e9019b1a257c7dc4f51d21e5d852b9eccd234868ddde6aaa29dd4b5ed1a8fd9b60a06c2d7c46782852611db25f49d4ef762849d80632160e4ea499cdfea7881890475547a90dbe51a490daf2b9447a0cdd5261ee681e2d1bd63487ee6021cd21e089ccb070c3e75518ee9c839e4e3743b8fe96f7089698fb5ae451cc2974ab32687d123f81472c42efb4c2ebc5f9e8be7950ec28075919523e2f8061fba1d6406ac30de3ed207fd186f2a0dd9b18e7307ab25346b7a82d7b4a8d0fd7761cca00f2d6d58ef6f474f900ab8bae80bc3902320e6c8d4e3a559e5a8d535de8fde3369bd7068b519b8279679f409b5af2ddeecea8d50856c3acdea0e3c62ffcff63a84265c539dd73f045fc16bdd5bf7bfc848db350259253304e8168fca772350465506781af2455dd3a9c7df8b78e0e1ad0978dc8dd41517785ede333e6fd441fccaa79134be03775fec22960ace9e2d40a052c222056b621da0369b3f0c28016b859dc5f7a70926a25b09631a86efc9df4fa6d660b7a547aa39bae3651f2d228b5f701756cb8955014a2c7dee899c0db71f42b125380aca85bb572a808f897797bbaceb1a94ce60c6934942d27f975f20cb78a4971a7e9586aaf3711dad77e66cf3f540fa11e604ba5a475d6db15f6494e5bfb8744e799dba8c8094a2d00a6725e09a1dfe102e157058a1c3f0543501faf7b43c04f1cd8af44f68c889d1c1529adf67d7475a1b8ad1d3cfb9756f3954c84e08bca2322f0edd8714fcddb2721439906898bd39f08bea859ee816e79dcdf83be752f212920c1d0c5a7aa29e040087094f321a4210a4212e506bd87ca2608cf96f0a28f8ef31a15b2f81c2576afd15bf972b7c150ee93564d4be45edba107c3a638b78df1111cbb9f1790bd4fcadac93ccda51e56698dd1baee7f2ee989eee4ea83d98b1b0f9a107e0808f2dc8691bffa77ac15c0e18f02ebec294e5b4b42dec6e69c89688148e282dc1ba6421dda40f2a888cbe42d0692b736c0d51fe57a2ede96d3e52040ea10f377e72b8024de172fc2ae494382b0dae1de46381305ac3283e27bff1f3e9fb89d2bc4420da0413988861ae2c38f6024faadedef0eb9cfba3cf3d71627e4a245a61f52e7ef7d20b34c3e33d0ceef809d203d1913dad402c51003c2c506e6670797b0efdb9d5be023b2aa6ccf9b37359a15b04804642e1d9922f784464d7732cfed76d20381a781c88540a708ca92507440583e134965928b5c1ee67fe45194796fc5e7a83008c15b1b1639275e00b2263d2386e9c567c1e900e6eb76d42c9c61cd43e4636fe0d2a577d30863a02d553c63f10cea62bc0f609d8ec1b08cca9e66dde2709ccc172462db17a880b0653eb585b9d7ab1e5177a11916b21689c798cd7c514277b6277f63fa0ea0203d03d0556195b44c2e00f18429636d63cdbf0bf881cb76030f288387cad96e6c2d2126dc90883b5afae53cd1d6e6b2eedcb308cf4666e2e59687d76c312269940bfbd6c1a539cc647c7497b779ff9c32f23e88cb28bf16ddb7a49160d730f82d49bcaa07acddb6c2a392fb7094b50bb8266ed6c2c84566fde1d7cde1790f8c7bbd0be650f9fec0cb63086704e523435c2372a5bf27e7e794aa668ccc8d4357473e29eb2acc4a4b9f3c87d8dfef8692a9feca14c76c2d39664a0bdd7c6f26c05c2be8304a2dee7fd79573eeddc0ffb7d522a1c2f2d5897b145eb5f403edc0fb87e56e04f3a471bd9b200c7877cf264a08a48bfa7066c9122881dc9b5913b2369c965af8e952c9f967dd6fcad945065c21fc1f4960e99f65fafc6278e828717c0882f2b93fc2d3eaa0bcac1e422e192a0af7552702e70a7eb15ff876cb4804fd02449394ac5761f0f3ff7ddf31322b80cfdf079e341dc686140e3df618021fb1b714bec4bce0fcf9c19997d3363db25bec3725ed0c77149b979894f20b4c368adfb50435f32c2bd0a0dee6a6430be282d091c866d8bae8ed4cef5e914e7fbb661c8f28e5308e2e84602d2cd41e25e22470a684a35c4ceba2ea30cf6890be1fc0c61761a90b958a1116a6d4bd8373034e64cdd5d0da6ea45b924359071919cf2975ea0b311eb85d06a1423a8c616c39b8a3c06c13910bdd7a8dd276308faf5254b1525dc007aaa21e255ec8076d5a7834e07dec3b0c612cdfcc7eacc5819c7913f46eb32c25dd01516bfeabfb9d0ba4fcf277c684316b626ed0faa384a08be1a2d62b247a937c21e423f355dbd12398b9ebcfe9d68c2cd1f0585e59ffc9e7ac93d93f8ae4e2ff4789753ca203c0d8e372b44f9fdd906438b34a27b9b961e1349fdc5acfa96624aaab53dac13758898b2caa574ab596a40243df56909c6c874dffece9a97177c15b895345079a894540ac00df15a344d7706c496b758467b5e5f7c66528050a285df075bff3199f5e584011d625006a43b427e9631893bb766557281ba6dc65a6ddb35311bfa35aafde27ee5de8ad4146d677df37d83934e9d22d2b4633ccaffbbfafa2b43bf6d2aa05ef01f3a25842613ff399d79732a1ea468a7ad6f4ea8775f1cfebae0d3513e5d4557e76b7597ce9e68c81682bfaae3aa0fd6511e493ecc85047cbf8427ac3a212fbaafb88b85c1761d17fc197a471a322168ef20aa959ffa3ab24c75e624a56147da12a7dfb3b668543f7148a54b35fc519343074a9bde0e68f1eaa6571a0f61bb65df507e62614e7e944ea210d4c0d4f1973f171723b9bf3e20b6e6417d9b0cf7e5b0699e1fb8219d1104af6aa120536c8403a58ab3b427af751e2381174553f35d0a2affc430c25d96c16330d7e2b52fa79ad64067b02e15e454e06594c69e5dccba3d62f744e8b8905e9601d329e4b914c356793616d7f1a339098d1ac46478342de4e0e25b410e93bd91da7d778bef3cfc869893449ce89031d4fe49334abad79d38a420e3c25b59d0a9bfe8edf389b5929cecd2e0cb18285be3046ecdad1627a4ba28ef809341977f1a8a3ecc70c35d7522891c0859875ddaf18795c037c80926459678184221f1c18ee4eec29b53a882e88e0dc92584484b163a0b39ed43d11ace3fac9b40637b9ef8335568b085dd10a9ea12770c34a3080529c2f4950a0a0c5abeea0bacfc3b93e43e44842c9fbf9cf38f5a90e1c467b2c9f1eadce19ea32ed2e4d66980de0837dd7ab9880d18384c65ca9239fda78128f80fe1538bae42d65eef8e2fe981a3c38d5b97228a9facc6edd131316e51d42b95be9923c2c64dc64100507abc72b81adfe338816f521126ffbe5b107529408406dd9caeac0a1a08ca9f767f83818365ef690962fc7a56a0fcf09f5b86a1bcd5b307f81c7edb2e0215edc71977cc9cfd46df08c0b926c2beb6cc7a793e2799f3e5ddfa16d9f22635624aff805913713aa34bc53e4e22eecbefe681a4dc44acf5996a9cf04eb7da05bd9ec91ca79273cf27c01ee4abc0552bc9db45cf972a18445fbdbebee0d867d1e8c3f25e4db4e481ba56865daba2cbf878faa0fa6a6bf56eddcac669cb9636499ceedb9d6eeb277381234305b69447c3fb81b7e989e108e7e3219d6d726c6722bbb1f92cdb4de5cb678abdec86de0945fa2e831638bbd14b206e33b3eb61ee5de681d28820bacf33e72ef2b96dec5de8b8bca39e105e392e8bcc936f3e1e819b9332400cebce088ed95acbd5f8340640ebf96a00c9733d3adc009e3cdf7c707b274ee04b0d2106f8dd2efa3b88384f9be3c50ad39366d7ea38e58441d1445f94d973445aecb3725e6a88d44bc92ec739154dc3610758d1c9f0661adb928ba268e88fe94c47b2b3e437a64fbec64675866587feba7393d827af335d0ad71018168c203f540a1128a9dddaf1e5e9497258c3a55505ef5e20c1ade7e8a058765462317802611521f8f6fec59a3a47e9deba3bba61c5f368dfdcec6a372f832072d2bfc43d4214d287912bd851fe0e250a1c577cfe22442b73fe46a7790d98ee64c6c846591b010532f85f659a07f5ef9e9c9de0e5f0072fb6947a62d11d0c08befaa58c74fac3c35925397389864c2e495d56293b539f8eb9d993559d5b92d6926a7cf61e7e49f3a7c02300dc28f09f94849cfb164a80cb2bccc7c46834f7fdc915acebb0a4e6684e40a264d19edab1b0a825c28ad037dfd83d7d9c009865e2e23bd02f366719056c5760020b4d4882713037d54528f88fb80df43972f82809e44fa650a41614eeb104ac86db5211212ee19a8aedc108e81c719849c1fa3bd240eb0b53eba4d76f023cba99eee04d46965fac31046e7e6b52f6259807966001f6cfc9eed6727725e2694bd48eb27d7c11cc0ddb6d06ccf0f515f147b6930d4f843c95453c9f9ff771489e7c16434e97d214d0caa99110cd1b23c4797261cf3c6601241b84530524f1f020f0a271b533cd02b4389d94d7d24f27edc0bd11f07b5dafdb914d5930dfb1a2989681d3df51287f3c47f1ebdb90da2019e684051a70ab77a682f4fcf0d0421373324790f6e338ffa091ed1f4c28118128bef5e30c444179109b54fe9da3ec31150f1fddce689f1055eea1c012895bc9c105d88b7b7149d4e9dd769e49bd3fff177cd48a76c9b6fa33aeddd99778f9c66828b5b56873d693e7b5492db1d2f5ba77cf629412b3316be731c509123fea8246c646dfc5d0326cec76b4b0c119f4ea8508b8dfa7fa3aa6886ec7bc081dbee2b8c7d2643fe771d85a94f684a6f390f5ce3af6a738917ff74fd18c4955ad9541feb2659c2ec3a118258174c4d5410f0b869495f47af401233b2dc1fe96b8a166197a12faaabf2fadc46e5dc31b67ea0ebbb48fcd8e7c2efa19231e33b9ccac97bdd9ddd65598035be74014caeb3a1d2737915b573673d1d1d226637acef6bbb6756a710a1837aadac948149644b14f1031232bb50bffd32a238654cd7f69d6c462ef1d5f640247c85805bff2edf54e23422b1021a8fefb4770d29b2ff02d4ebe4e50cfed1bf7b1db53d69f01a000d1463275918ffc36fa2ada4cca652cb6be18cf4b445b8efc48a4ca38a7e12b35aa70492f938a980c80a54fe5b8b94b835f1135e610a94889a492429ad04bbd5a71d88200e0c421fce2554fef9aaeeb13d88fb9e695fd26d70f32fde6c8928f68f76262c6486f82be0bf0f01f568eb4dd8ac8512cdd2541ce77df0599c72e60382fcfb351f61e1942d0f60579c7694282176e572e4718bf78157c547d29f88a83d7cbce82b6b8193c055222cc1e1e9a546c091600f5e732996ffcae22289230f723caea98a8c09ab8ea1cbf1d33327f1621420b9e5bc91804e9e097d92b56921f993a99c678eebe761b2a9306a2db963101a07eaf12966519ac694ec030ae93c88c89b3f873ce3f460d6f4b8e2340022238df82bca066f7cdb2f74768876ad0723e96aa396ce649691e7d5aeac13e807e71b39e27da8497d21d6c3dda4ff60ff726158fa61eca363b7e1dcf75104d2f04d7600ecd5ea0dc75b906f8bab0255a5db6fa5fe7337b5532d12464125fec53d52cac9cf9ea733b9a22e5eeb9d18d091c3c9232097a5a9d8b3206487cccf5b3e5b1720398208ee430c23e743353d1005f14bf3e645b4fdd67751e2aef15c62b9f6a5d1fb3553246800c3998f25f1ef9ec42ae0bae2e727f3953f0ec2f47cd506fb90ea7f05f5db1a8b7dd19c9d3bdf4a04b343f6180895885ec9dac703c987173e498530f95a64bd59fe1f271f32c1bee89f6135b29197ba7bbf0171d3fb65e84e20f28831a3e610ccd1e018e44febd90c9c0e76818c9f82eac6ded113cb4981ee494b2dfb0f12c7a3919795e1134ecef67b036e0dd24952531df8143f95f3840933f1d8487747f2b40f9e1579a9e9f141d08c5188d775ec60a8e10ab7f456064cb3338206de73a30752f3e122b43b628f4222ae5c904418d8b3fa35c73ef9a6e2414fad70030a22d0d3022de67fcde3037924130307c7c2db48976f14c9b31616892985a585a90aaef6566dde844cc4fdc8a302322c403b477be784b1c7e618f0bdba5a791a009bcee55bdb9a6da7e00640840c943654eefc6910e55344a3e546d0bc6b64bc6800725d613504d3363cf6bc8f7875d21b83067f2fbf81fbab296fd86b4d1d3ba016bea39fb441026c68dd59ec1b4add348a639770429c9508378a9c01ef4c91067cd7c0cdd82a85e14d2187af6bb3ac9b070d2dc560efc494e67a156edfc91756501bcaf59f85e5e853749ab13176b9327fff0190c001e25a56fc20b5d1094b19996537dad9330353c50d169292387855a9d9b124ea534e7746fb8eb63e9ea97fbb126a61fdccd23b8552af83df9d48de753f8a04d68482bbe2fdebc3c87be3f206df52fe61aff3f8c8f85964f0b17e7c6d1d17ffad701b05c3883597fffffd04a1c8934a57d327aa04edab69a8994cba2cf439fd49e074a6d7132c433441b38a365089760f7728d4f4c29828cf69955fdc4426cbbbcb66aa79e0007ed0f595c4e9c4534660bdfa056ae034614be559e20ef89181b16edc43225f57daf7cf9599bc4624103b4a96f0025fdf8111b30236abcbdb4e5ee7556dbf37c1bfbf1eb116ad7755817cb93a98dd2ed97192995483db3f37df5bf48fcdb3023b67e04ff2ae738f630bf88c873231eafe35a10590907b0dff6bf8e4eacd044e0452cb63c12f63e832eb93b6044a1fe81df41cf723edb239bb95cd8111ed9a10180629c77b4206beccda6dfb6234f0f9eff20b4600e221fffa6363346e6894b92513e0de78462ec35c9d4be020224592e795e332a355d3fa0dc24d1df88ed08cc6abd9a801375adef3ee70c1400efcba51e8a1f993f342499a6b4b9b62c182c896e58d7015b20927669b115bf571eb0c83ca296f2f75a2770cfd7cc693eea73847c3f7d80eb504764a6cb875bef815559304b7d4d91604723ecfd89cd79fcc430f80f58bf9169953c0715af774f57b774b5801c7fdaad5fbd997f0cf6a736aa7ea45920190a24fb6086fd36c1d6dcdd336f969957b48a11a90ee457436f7c78327852497c5baf6ba2b415d8da4dca42176d3e50b0783b966954578e4f8a65087c4a9aab1b3c10b8d682d327f7d4d04f03893657bcceb09be901f7c59d2235e6fd3ad81a3fc3defb9055c959f09bae4107392f8eeed3fedac125dbc7178de53c4610861f11ddf849bd4bd5bca0d594c2f657a2886f6b968149d808598b8529f4f17a9040121e13b09bf354ed61fc123453e7f3fe92956d661b85dee3afc8b450db3fbb646888201f4bb7436df89e76d9ae88d7d6b07e7a079713fb995d774d205d62d25fff333527e5f3ce6faffd7d506ef74fe4f698ff102d75ca705ec26e6e4c87eed0f8b08daafc98fb5f4b8da2a373354c182e10391cfecb24a72ee220fa5afcbac1370583b09f2213a1817203b4103d26313a9aac9357d8301c90576b9f24c8258ee8e88fb8b62db2a9df9663180f78c78c7138f5671562eeb26bc6500ee14ef4f4d971f1465e87c4bec5a4e5ce846c39cc6f0e64fb10261bbfff89515e147604b95f573bdeaa372293496449c14ff194b2a9571532c9fcdfafca52f86309955533d6599ea0358661b3ce2f0a30c0a7e0aae87993ebcd82532fc6e63d946425455d2b02517c047448460b41a4d8f66caafa23d21053f854638a9b6dfd756087f35ebf173b6fcc53e9d446f1ab84900d17112e60edcb83c8c46a438bd4bada7ad6d4fcb6809b2e57a2e593cecb21c39340d24cb120bec57ed965688921524f90caccc09891c39bee49e7e8c01c94d96eb6cc28752966c33757dd65724de5a2502e4d0db6a4a720d44093e73bf71371dfd51da37519ccdfa5039e46452d396d068f6f800175fdca5f3737f5d42a307ae8a2e6be2cbbb5934588114ab6559b79489dc2160af058d732748a259b165d254b6983224abe55c156bbf454cc36a14972c9e2b0d56b5dc6a9e5f55c4e12f56759c50367f692ea3546469faea238dd601b4e2341ecdbdf5d4f75ab471a2e4e1c919856f7a03624995d14b27cc57a423599aa040d027bcd6d40fe0ef14d8bca55cc546cc21a4a198a71861d4cc13ac7c881b58575dcbb1a44b307d79e493928a8d8a1fafa21acc7bdb37402a0eda0299a8b35f0b90b5f9a4c7ca6067fbb2d46ce2f01942195f87de306be64ead77601d81bd17e9b4dd2ea016db047b4f5d8e16be0227a1005aaa78cb190f5215a05a421839108efd6eccb9e548a06d2f5e5d4e689ee3b3da98c537847ee0056ea64d56f3ce833adee31e3ba88a562e0a2fe26780bedea959a47eb38cf5e64853e8bfb4da73a5f8bd659f9d279a1e9d915fc0150a6c37ad479494e05267c0b0d0ec07844cd7e3fc1f8595873ce5d3e630d56d0817831aef0f9ff7536a2e0a39baf551d1febc6c0f0e4efcb9a6f0cc24b1caa3ea93c33902ef62e79b5660ff19464e2fd4a0a75c1941f0ff40ecaac009e28b6fb75228d940b46b73505e1642a2dc3e72237033a5c261eb9faa2302c57f74b2f4a79dce385c2803c7e347f978bc71fe868116e28a074edf1c9a3f466762f77cfc0b3a2e4bf5495875d83f33a3197cdf646d0014875543b547e4fe09b43ee88d831cca8eb9fe97797d4a8ba44213a5ae595e32ccc1da7490910410335b924d48aa60a2dd723b69a743b768c031c1a817d6df66c2a8a41a6473f560f8ba350bdc732936fc842de396ae1772b9e41c8dcd31635fc5f47873489ceb56b994fa386f1f1c653dc96accd9305b8f07e0e652d1fd0ef63b4d1e014eb44929c8542199b147bd728384a549cded12841a4c8c3809450d84c497e51bcb44f9d6c3b4f608d99fcb2073330490316f8f7e9ab37eb33acc83b86a6311a0ddeb9df0a7c6b56cf4c218f6d590ea3cf8929d57e28cde7bc2b5032874f87652ba496ce9ea8fff9f9f97b38360593512aa1edc6269cf96204d97d59a3067d248ce5704a963e661d934397534712b83946e7782ec6a2b96ea832a05347e04a7d5e8467353193ea031c231c135dc5901767fd311515eab552761473aa0190d3000f4387f7892861d6519dcb08ef5ef7e9081101e61788bf3bdb811e736360f64b49d892a25ecdaaf8e5a52f5bfbd01799bd8537c6b7361ac9870932a1e03d8dce4043154906227e48ff68136abf01ebda9e77ce3f35c053b8e212997c1c367b03cf631a4fdcbd6098aedcede4635e8019fe65a3004ec1304c8be00b55e3868a2958521e23e31f7a5330cd5b658600c66dc8c67fe9319ede1299eba3e6d85d655123d2214230402cf2714bf9af1b23d4841bfa2340c83599853d163e8c28f86e9309c17ab08093f0ab3bdfec31515b5a0b8677d53e1c36016c21ca926060ae9d682c77a485d72a571bbd38ab3866fe5e15a0b5b9235a6616690d86b69c3958c92022e2c674b8a4bd0bf5aa4cbf70002038171f50149a91b8bbd89cf78716e58b269a80f8673c469470515c676cf36a88aacf1486f423a9534f3f0f7553531517437bfbdd78e8dda6aac79516b24183c3ac1ddf17e72d41c6f14317b45ff240e1c4afae772f2b350eb1193fc618023aafc9a56930932d88226a046d5bf4cc64d61ca0cfe4cdacf369fb7a72147992b0cbcac3a1efed2d760a4fc3fd4e72a962444f82292f0a19cd953819fdec3929fd99a9051d8fe0197d392bb29b1122540adf8aa6a22c58d44842f6633c0d23c7d46cfdfff8c4bd6cfe154d2de1cdec6f0b1a3cc851ca90a06b1ef126449d630b5b9db1e0e483521d5bc19f8711d19ea6a2003ff26477a85b3ec29f7c624af7c8443f116332fc298b63e815e9168ad441c41be89aa1f864cc27c00ae1f66b99751f156c56e5876537041f15b3235f0e27494f7615be6d26334b21e357425033cd148b9ffdfefa631a0f417cace31e42de6aa6af11e2717da6c7cfcdeb1767881bc8d10535ae45e2591ed045d38bf83689a5b6567c588244a356362f74db909975a5369146db8577a6c0d69e451f236790ec6ac77cbacb582cc55d7d972fac47d918a031d3ebab72fba34e86132ff828dc4c0353bd6acd062670f3d9ce34bc577db0c4b8d237184214ccc3c7d2b2288f349a5cb00fd73aeb1fcec258fbe36fdb15a079cc8b35341275856cc0b71074c3d17a93a264a79c59a9a08741f3e43656708cbe75d61f3d153536214d0224316d30922d1bee5ed801543be03924a3b157bfebcd7746d217e495df5eda6d9d8500a54b0de2d3336e91342284ec3d1971534edba2199b4c450799d12d8d0277f5b30b59cc7a9fef0d1d848e86329c16d7d11a3a048760edae6cef49e089fe4dcc88a1e66593e16a4047c03ecac8bd9f10af99b33932a74e70813e19a8c1bec3fb5e5db53aa1342d1da5bad66980a55ec8cc1b856cc857257028827158241e4b3a919d01cf9cd64954349824caf781acd2b53ffd3fdab6aa95479b0c6ed863772d24e33ccfa2bb14e1a5ef48123840841030eaba24bf8f3f8377e4214f5725aec2175972f11e2fa9eb793011705937f288ed97787385268be1cca4c4645aec58486f5f6465377d6428405af99b81b4b6857e5695c412d7dab2e0faa6ad9376f750303b118349c9b48a404a88bbc2e3c18cba303a4bd2999fa5a6adbdce572236a90410aed11205e660ff12a9429d250584e2d98582f6fb451ac20e1826be3d185cb483aa9e8ef25b59845831f9cfcac3619389f8c442804d1e285f6235bd6146a42dda779c3adf4dcd9785796e34c6012a891ec2f19d97dfed412febcdafc861e3010ad87881d72b466a6f3a09efd5da04e058129f399755fbe689908aa9c51ff4049fa471c62f0a1e1a7a2fad86bc6bbc024dfb91b3376a40c8deb0327e0004f3b4872aedb824c09f74015c37b9144321119d40d403533159fc28e557884e56906b83a3b952f348ecd2ec560a7ce3c8e9b387ae751df82aa2cdb9738c5cf7544a2492675c28b363d921a5d558197b59d13ee8c3563708257ebf2606cd3e89d38f3b612ad092a0464491565c13d19e98a7d76801bdef7c07d31f5cc5a8cc1620435e7f479ee1dfe85fe86e62510d0d1a20711b22eb2b2aac4bbf9bebf339ec27bb204de2119ae4d1f66bc1cc397ba1c5983da8e4e116e01e87c01a720f32545219bf9c4d04e020eb30204c95ea05bf514694cbe1f0ad2cdf146ad59efadef3633a18616cb67e4a2c2862b2baf9d0af3a9de3d6145c0109fc449a9fbfa27127de57b5f6f674b277d8e89c8b26dc19178b0de27f9cf5c73e4db92d4a8d826770ecb8b71f7780c4f54febe61543d7acfb0d11a6dba692906d81842d50a91c826a303a11bc6c809ea7336fe11bbe09b3fbc420e936d5b4add46217b182bb61f76fa837e18efbce50c159a22bf220f1be9652c2062b22f812769d3f763fd932e9500c1f7afb748fb05d461f3e88eef8ef8740b32d2cdf473377d1872486e7d0f4d08b8bfbf54cb59b4bab7fdf33c955268b15577788234ff7fdde1515e2099411dae82e29f92f559f46cedcb26fb3dae04ab888ea333eb45aec97f3765b830a02198f8d1b407f96818d14ff55f77236278715e76bf29fb7e99105ba31d713db34deddbe986679c3d68329562b637abf2ce141cb20b1ebdde8771b1517f01cee833fdb75a6f444740958fe0da461d2766fb058e9d772a894947c9074d1511e78ebac8d33f0b9f9f55e518da4025d840ce05d458ba1580621711190cd67f661cf0a36c2e0d66fef0cbecd16e5d7134bcea8f96bd89e78b73f5d1350d5f994b71bc81bd36587b9bd7425b82cc11bf1fea8fbf82cf3f4e60a2c0481322ea7036cbf0e471400315b68ff44ea9f0e2e7e182924fcdd59be7145ddce25a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不是哥们，你谁啊？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> IC </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> C </tag>
            
            <tag> DV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本-delete_output</title>
      <link href="/2024/11/03/Programming/shell%E8%84%9A%E6%9C%AC-delete-output/"/>
      <url>/2024/11/03/Programming/shell%E8%84%9A%E6%9C%AC-delete-output/</url>
      
        <content type="html"><![CDATA[<blockquote><p>This script traverses the current directory and its subdirectories.<a><span id="more"></span></a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: ZLin</span></span><br><span class="line"><span class="comment"># Date: 2024-11-03</span></span><br><span class="line"><span class="comment"># Description: This script traverses the current directory and its subdirectories,</span></span><br><span class="line"><span class="comment">#              searching for directories that end with &#x27;test&#x27;. If found, it deletes</span></span><br><span class="line"><span class="comment">#              the &#x27;output&#x27; directory within those &#x27;test&#x27; directories, if it exists</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to traverse directories</span></span><br><span class="line"><span class="function"><span class="title">traverse</span></span>() &#123;</span><br><span class="line">  <span class="comment"># Loop through all items in the current directory</span></span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>/*; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Check if the item is a directory</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$item</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># Check if the directory name ends with &#x27;test&#x27;</span></span><br><span class="line">      <span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$item</span>&quot;</span>)</span>&quot;</span> == *<span class="built_in">test</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Entering directory: <span class="variable">$item</span>&quot;</span></span><br><span class="line">        <span class="comment"># Check if &#x27;output&#x27; directory exists, then delete it</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$item</span>/output&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;Deleting output directory in: <span class="variable">$item</span>&quot;</span></span><br><span class="line">          <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$item</span>/output&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      <span class="comment"># Recursively traverse subdirectories</span></span><br><span class="line">      traverse <span class="string">&quot;<span class="variable">$item</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start traversing from the current directory</span></span><br><span class="line">traverse <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>editorconfig</title>
      <link href="/2024/11/03/editorconfig/"/>
      <url>/2024/11/03/editorconfig/</url>
      
        <content type="html"><![CDATA[<blockquote><p>EditorConfig file for github <a><span id="more"></span></a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">top-most EditorConfig file</span></span><br><span class="line">root = true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">all files</span></span><br><span class="line">[*]</span><br><span class="line">indent_style = tab</span><br><span class="line">indent_size = 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本-check_process</title>
      <link href="/2024/11/03/Programming/Shell%E8%84%9A%E6%9C%AC-check_process/"/>
      <url>/2024/11/03/Programming/Shell%E8%84%9A%E6%9C%AC-check_process/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9cf873942620fa4ebb1cdb4f2a08fab0b2047b05cd5c32502e3ba72f37ce0dd3">bc784a9a828376686ad79bc9be5654d3a22b15b1afeb54116cf6fd646f3f269e0adbf41c9a58fae7cceb635ffeacd251950c08839941532676c31774c06305b07dc61c079b8fe4082797c91eb5686b8958f960be5521fbefd802b3cebeb26d8016124a6b2b012342b66d7b83fe8d5b360747491f3287c61981c927c7ce207d02a2f5edbafbab10081c9b384ce716e15cbc49c19af6dda3731c39aeeabee900a2de265329cd129072ee0e645c6f342048437d102f0382c5ec6ec868f503f0d051d16ecceb359ddf97e0e258dd7b8dfd8dacf640e94a7a4208a5071c90745e02ff61793187fef52dc3a903dbf60acb3977f4782b1dd31c5ad005b0f24538fd0b93a609bd401085cc8120f2fa066f9f81ff807f275573b4e7d426455249ea99ef491544a177b09c689f17ee1fc95775b92aba0ec2de223edfcb24ca24f85bc0c8d123106a750eb92f8ccbebaeb6af226706e5b0b796b7ba1a6f539982c223d23daba7a8940099cf7e2f7ae90704bbf6fb432abaf15ec215fa3f63d963059a3bfd641a6574a0607949752ee2e5b6f88a365fe01dd8e921a95e4b699bb5278ba3a2832a2c45d3c804a2aca98ffe367ffb7655689ac2caa047498fd841945cfd1395e16c05b1d7868f3617a0844525be764b4ee94808a80d0f1b6f1801032d0780a6b5fbcd5ecd3019ed760ea46fe19b36f00e56141b1a436fb5298c5d9d93f317eff2e6f6ff81ab7c60f99adf73e10e3438355f74a57d65983640682f67958970efa4ca7c5958c2965d451e1f579b761c7e8fd70599d0506e8329d28eb246e7a2c3db20091f7b9ff028c507537b0fd5a801da8b87a11ee30a13074c284bd2359f4d1a5dc6a4d0faf2555accd9ad6763b078bdb663c64643a9d42def460b3b31d8316763d9f96ca0e2e4fae541c5c5d3c7cb9a1957e9a21c14964dc1d340462ee1931623d78e784db110ccc6ea5a5ce3e53d26903ed7bebf5cec6c237a7d476dbffb6a6e6e93d7f8249bb706278ac19627832fec0e08cc0f6b49ed161f181b1824f48b93ee5dacc612ebfa24db12111c3474483c661749f53215e79317a5dca15be255efb02fbc336affaeb29f460c7672356a11eec25e46d20a8bdb555695f9b3e45b9237e43b103857206b47a4f3aec9214c067507b5f2db9ed9fc94c5ddee6e1ce898f819b9ad2e62f216ce6e92c8bc603908cf0ad6b6cd83debc6ef0a525fc9d6081d598ddacbae33575e0ee7a9527b299c98a0580cd7e6557f8f64115b53fa8f478910c8276295ec176f5a61a88bf1f5c7c644c4fd9fc991e6fada541081e1fbe3c6c8aa7e59141961e28545574c7b6d9af7418bf96bba6f418f56228ae81f4979bdbcb8b913473fd018ac424819ff42180e6219a3c71de954b4d3276926134920135f626d710ddbd76be7682ce06915a4e80069021d6c1e7b1fc939f8b70514867c76342037e08cb1a7a5680e21bd692af8c3b94e605d25c831911ab5459c77ba4d75a99fe6255596a8fec592a671d42f88e3b5ba7bbc565ad06eec4c22a4add83d3fd21344dce71b4de061c175499afe273890277707bea6a2dc6f1823e58d816ec636c8fb89f84e913efb417225475911aff7faf5fd2fd252fb556fa36b1566af1a546595043109366f2437b015c396d728e385d558006fe6c5683d6e71012dd4d5c8f17938c10b2524465e107aad8368e30c948c8c962d3e3d2c1f8a148b561f39ad2d429ff2c23cb5be33529bf71a3febb6340ae210aa277144cfc04b213fd50ef147155aa472680e74f112865086e171949fc62866e8623b2cd91853d84d06e4317122fd4b4378205ed17699927724e09853969ae2c727df98625ccc35897c2454435dee0bc9b9d74e0a24339433fb1a302da83420424648d7059b1e7f96e9323a6476ce22c7ea5692f2cd511270e21838aad66bde97578ba86d607ab08e3dd24018b1eace989b2b3d0d741b1d26aef1f9b5df65b0358c23e36b0f8d297c299a752beaa75206b28630d771ef91a5af6cc9146811d84416f801be265b1f1f5a7f397de02eb4f1bfa8010922e734981b1139b3efaa5698dad0f0dc1dee04a1857dbef6ee728a92971fd34c18539ef241b6d1101bc541fc42c84ef7fad8ae05f17b3651ae6b179d482535ffe331f41ca2e3d6d1efdbd58dbaeabd976b27a0baf89200bbc4a839ceadbf875848a8dc5b530e9aaedf5a992a9c11426f7eb1004ff2806f3622ba60870a6b203cac9b46f16e77b44263b347c62e950c7f3ad9635ce2147ec7b3d25fbc0f0f6f543e27216328b95f0053271080eb0ac9ddd8da1ba5ea976f1eeb28ad60becc3b26cd6279587dc054cf13658d5c0ff56137b2a50df02210d20a6e0dd078a25b2f09afe196ba932a6c70fcd3244ef2af44bbb2037ec6c283c35e086952b23cb6b9a13797573955dbb68e38a67af1de6d0c79172c25a33d91e3b5ab21b64c806dcc4c9bd8f6e518944f891c46c74235d35cde69a40e3507ff408755f03591075ccedf8dc2dae87a03c44ae99e0fc7ee4eb79b2e36fde75d3fd05c8dd0e90f2221d9c06d0c718a48aa602f5cf3b97a85ce303eecf4b18929c2759ddc8eeaf4833f19525a4286a186e1d032e35858694629620b5fc0ffaac0d016ecc0b2d739073ac7363566c3a411ff00e409460931b849343d81fa261e53f5e530b4816d0e64b8cbf4babad84963be7c7adb203d7f89205742e3a5472ae5d6120a3f2ca9adb884b7a73761b1a555ad9469151cf5ac3f5fdcd2458adbc5d3933b0c2f1c3c22c1285e959ac5451dab18e759d68f1ba9f54501f6226d64d860c22e78b0e2e921a32b7b41c654992c7dc5b949240f2bc7d6130fb3f11cc652a1f1a29ebd80d2807ffd5e86a3dd1e78a6b922096f51784e869276a4340d336dfeadb7b61235de239c1f303622829d706d851c2767ad420948e54c3686584f0286dc7ae80ddd1bf510ed75819701fd7a2b06ee6002b94136f59981df63ee0469ebe25524030c6ae9a4e86bc39e0d946911bd4c83fc2610ffb3aa7f14fbcabdba742b15148e0b42acb3abcaa68d3717e257f468334f64dbd9d001a57f20a5b0735a7f1f9fd9cbfc910aad5528283b7d0077cbe69f31522d333e77a70359b626952fe0a259a2090d1e04c35ba390e3ae12974793d1dffa1968afdfd963f39f97aba292a1c829587ad13d61d15c47d574a2787bd910add91f14314d4096aea2590b7bb87482266fbaad4ba136c8636e5777c4b8eea0e7fd23de3ce05d52e52661aefa65c3b6ebcd3d52c1e616771059a948529ffc22a1b0ec0689b00e27ec7f89038c7e44045217dd3fc5c06864b8a044264e9f4acf5174f077d79ca05d543f67edfa48da3f80fd8fa9aa384e3364a3e7b44b10868981fb6ed1eefa4a747c8ed4796efbb509e33b16baa17286b66747be4f81155128049ce7f7b908d83b4dfe3d2f3e830e169e39f0db6b027cc6d06099e99e7b60514dad067e4a7736d56e45d4d5b0a9bd10af7f985a4c346c13aed948335c5ca08080195d4fd6bd9ed9a9c979e2ca2d662e4b90fa584e4c2bec39501544257c7b5120384df3d37c434b1d340bea701a7b1e12860c690c4aa19e4f63c9fc89c719db5c501d858e649bb6dd4650c766b1527a39a32c8209a312e6b51503fc94f5a0c70df4b6b3a04bfadb3a62ba23407e51f1a713dcff04b350adc6356e19b9f252a4fdd5066ab870854a410a5181ce62a1ab2aa8f6f54c914abd660bd607dc480b99ce2b30380918add1458a0aa265f8123a3555e74a18c475b32c3e4357b0cbda36e14bd67b4ab5231f83f510c45a6a768b1f07c35dab014f633a5cd64313ac736e2920bfbdda5e8367e5bf14bd263dbcf47eb32b85f03942d1c124fc472df463174c3e3cd9b9010180697461bd28cbfbc93a569a5e21b2724f38efb3e9f193d5aacb4a30e6e8ce67c20de46f145ed25414d68a5ac34078d525552ba42f263ef7a59a7569b9ababfa46512355ae8c84756cee598de96ebea805961d6446c58539ebc85126947a077ab32fe60f99387f985aa35198b42b91e92400591a76af81a5f4fc6fded1c3d02e18acf2d201c6952855bff20523b1eb5b0596208e971b66829aa1ceca551d91d4c29ce0bf828573f213fd78c4fa77b18bc9575cedc5cc546d4b7627037673e228b9ae9e964d5cdbec85f0e13c4359ae7f8a4468146aa25f17be09b1f75593efa4221402a0b006053d72e6837107aed432e4652389149fbaf1f44e8d3386ba06f88a5e79dd4a04d86741289fe372f2ec6b38501291d7b2a5403b7f56aafa281ebb627ea9f31e8f9e4bf5cef933a8eed7ff56453881d3bec8778fd26bdde343e2d7081a2a8634c1dcfab1d95ee5b7bfbdeeff03916b8a8abcabdb92c87cfa214f095049ecba073d6ce27ee33afc292d79674671af58a9a3a552c3756f9667ef27e3c8b245cf992ace68a396729ba2a120e280cfb8ef9233835edad4559743a76c04a388754d9d07128a73c0134fb8ea204939cb7b70933990cd425cedcb8a919d648043c411362cdc98bc6ef7937dc640f95b7319e34ce019d93fc0cb2fa71429b6e33ef28486adfae5e9685804c5af132e16e02768486af8675bb06eefc0d8500949203e0dc796500dd1c3faff158655e6923fb2dfdfce9a5472e947c416e13316597552fef4427ef405ee72b52296bcc9937d97294f848dbbb9d3dae612225445d1b33fae99a5f4f18f75dd60a14338eb028569363a4d18ca49ae29271695b66d651c0e5cce84be6cc5b8b2f046595fd27b6c33a647623250f1cd55a21dd8c5a015250b6609c433db23b6022a6ccde3811908a8e8e9d28bfd83e9c10cadbb05792bd4c6899ddad01e5e18bb169fb3e4de22e923521e1e0504a81a6036cf48fb2253596fecdae372302e312d13101cfb4a69bc358666389560abb9147fe5a664eba82ba24b4baa7240eb72169e380bd27b254992cb497bb893ff5c87bf7d18951df0f9014a362cf442baf0af7be3e1215b677e406a21fde683555327b6eab7838fd0ee2c8e1592ff279214acdf38afc0450eba1785956fec6e2b4456834e90b7ad4cb2a3bbe935a38f95bfc96b4145282a0e3985c0eb79dd91deaa3e4482432f131195d6313bb5069d2180d679b4c186a523c2a5e3a074a732ed79876d6fc1a9a67d1136adc717140626306b30ccc6d2f7ccf31de4bb0b749b29502a6a52dd392f69242c5da3f597a593847de45080a3cf5d9213b4105e2006c5e02703e8f02a91c2737b19c74d11b7dd2253bafe0dd8d24fd8fcc0b54f2694efae1465bb7f0091d78457d30e55dac4bc826b5125a58a7e56fca2e5d2c2226e82642cf7e6f39ccd638839d7c6c4dd213c13f5e77c4832c0038587f633f594cf7f50c3bb96727eda63475409d45e0304dad8af95044fed38e953a2932fa12c36cd2e75f52616389b1efd34cc2bb256262d4230acfaf2f8f2856ca31dfdfea5151423e42bb378d1ef04086dd01466cf5ea7ab5094ae59999a99c62aaca1ee09168a39bf293cdd4efdb8415fa3d952669b557490b41c650fb3f43048f8ba9493007d89538fa247d8f1e9286928cf23e690e87a909270e03f960f3d8df7e9a7c866d6c589780a36dc511f6d7625e2215ffec6b029a8fa083ec962e78c4b374fcb59e839b59bdb6ba0df9e723f5e68f493eed863a754afaa20bad381dd06c7dd46f556ae79b6aa1417d5216b75873c3c0074874bdf77e1dd81dc75c0917a5527d741380e39ba7d11c2ffedb68d32e683bc4e06d4abc7e4abf5d5de0f7915c6637e06f7e90a0fc7b7955bc3db3336e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不是哥们，你谁啊？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python脚本-replace_script</title>
      <link href="/2024/11/02/Programming/Python%E8%84%9A%E6%9C%AC-replace_script/"/>
      <url>/2024/11/02/Programming/Python%E8%84%9A%E6%9C%AC-replace_script/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e3f3debe155ab7fe8eb7ee619d05d9074c71a8ac7ce9e4eeeac1918cc93abbe5">bc784a9a828376686ad79bc9be5654d375c1b1a7918f88d63999cfcd832bf8aa3931eda224e47faac92cb32e39b69d03ec3aad5397e049614dd25b084cf84f7ca8c2e304e5aaa2f037e5cfb00e4093b81755ca9a53157387f837c50029837685029851bbbf5d6f79e19b032db1ece2750906de61bd292c5993bb91090db3987b5882abf36d5d2a727209d339e3228830ba0017dcbc62669a079b709858da11a0ea3adf3cca38b0f6bbc192c50d8be27d30b423294ab5ff9f09b33b6f932275541f30e5a6ccd04abb93f0d5c3857b7097e93e9d338796866f631f87fdf340821cdbba4b584d867105f714f225ff5fd7af1e5292938b5d25b3b6dd95de7fa300b1845c460b5126c016e1fb93b1d8b30c9c14572d9e140034fb470ba3e429aaa940d40c9734251e9f14348ec5368cb1854e5b6e1dc61c68ebeeb82132e39465f3830f8f4a3ba7fb3162f207c4288953b046a2bb0833c3feb9289add5c4028f1751ad011e564bd8a5bc3ae8171317e099f6f20be694367b42bee187bc9614a65a116c0a6e2e2225b584946f32dc6f6b5d4dd9db298163c6e5360fe6047c69b96d1cb0d70990531a30b29e8cec16bb93fe24524d028590c1da4f159ba6ec5df545e9770aca4a39150f55d97788536a70d45cddd73496a4d6ffc85a6ca45d3ccdfdf7b08c807300749a6cfca6d66c1c76ae27ea17610a32cba4fa2941ada04cd9b2446282d669a78fe784101348885a34ea2f42dc3f6ff5d6b6f212cd2dc839661dffe981a48e4ff8c66c66a6acdafdac74e1a245899013f7f3c3f84ff4a286b5e28166d3fcbcfe419db4d1000aca9160c6facaac84ad9faba5a46594d2513b0d4e4ada42f1991f1b504f952880c2cc1495d134c7ebc0e84cf61b3bc674aa76971e56fb67d7fa2039bf2c7c81185983ec084f1582ee305145b209d953e199b434c39100908221ca368eedaa2faf0f56264f2545744723cf2374dc40ff35c5cdae998b7b2c921621532148fe07a078619eee8e2204a21fc4158a76d6c0025f9988d9dacba57e8770f6035d6a5865206b9f4303e3af3739bee3c84442f6cd588f8e6d12df64d5245f3e0e44375e9105eacd912975aaac5c92ef099cb230999cce95e41191a949e9ca2765bead3c40d8083731f4c50a2d841c437614a2361c903214e39358ca9da6491bf6af18e2c1b32b6672153ac5fc590fb1cfba6e407f5613f1bc1dc5616f90a238824eee0f78387516fae514038b94910cefe1a55e7838a127178271ef7a444dc8064abcbdf39be3eaf81e0cadc4d1b27df846b8b6d50b7d2ac2107e9877034e2c6ea5c0a71d35f41165788fd2d25f558c5845647c79fac3a81f67d7a9a455cb153990bae7a833010bdca8e371e825f6f134bd6ee38f074a25e6068eaca8e2111a485d6a9da594eb61ef79e323d687252fc862efdd2821c1c6d733ad93f75c92bb10786b8c43e38a348f8b28e1159a6eddc3de918cafec53263dbbaa5a91a543df6913362745e4bdaa87a3897b47885bec4bb7e19f52eb535350ad862b53d4aac9f2c096048257dae23499a922b08a9cec7056d741191691e5dd0bd5cfebaf506642efa237c7b71fd2ce37b52120e58797226936ef1ec8d343a1aaa7eb1737dc58cbf42e7bcae5e2e2cb738f843cdb1272e7e739a3ffd432df85d929c4fc12960d608acd90262b8f7e1d4fd56aa01f046cf60d8f6edf149b74180d0ccf238fefc329824596c04a97e10688c1960e71edd6887fd44cf5df0541c7f3984e46264a391bfaa7c1ef87c4b7b7241c396f3540c12ca9fb488f6596e632ed9b3d423622739c29fb58853951ac35e6300f78474b174cd03af0143b7a51f2f9c27fa0dd7a961e0e0b9a379e1fc21e984d751ff7092b6f5d1812ac7486f647e7a3bc5ef379816da3a266ff8b58e9e89e9ca2c4d07349dceb92972d7c8cc28d86ee9a0c8f7e1dafeae182a938716ae4d4813a76ab42f39dee74a6781acd8a4365a5eb07b61f1ddfb6020130b89c5098e2d56406db87b266755e8579cfcf740839424daa0fa677e53ec2c53054d620dd4cb9baecde08ca737c14c85b5e5f69bc038b057706ef540ab63aaee767ff4488883ecfb59d9ff1ea0d3302833bbfbe228d1fa7744e976352cd33c169475577f1979bdfde31f6162c1eb16aa44663911396a167516822f713bd288266f51619a8e0225bc0e683443e638f8f8a067bd34effb1bf3808a21ef0c9f1ee6b96a5619cf62e8fe1cde2ddf7e3376c4c08bbf9b04ad15246be1b9c14a7c7511e16dd226298869b3fa3911e6c5da4af3f62cfa835028b2c7e369f59f2ae14d7ff3a61da5f83156c98690387b8f8fbf51578c211675ba06262af31da61e217070448e4428b96821017ede6d4fc50b7b768d144fde9cdd402b14d6d838a7b7d69853d3d5bcc03acbd2c0016c101b19039e32df818e910c2fa4c7fe6aec720ab4fc22a1bcaae225ea6477300d915db0415c7b2d0235824fc13b3de80688f2fc6db1c2f56a87488a2c4629dd49517d82c52e14b6fe865376dc63476ea62149c60e0dd9e1fd8928f5f784aadd1b42da1c2d73db00fd8acab8555291c0ac4cf2a8b2b0614e8f30b888e8fb6c42c36fa2707351bbf8fc24ab48a9b2a8997fe2ba2d9f56a4937484d141ae9536b831d21397dc17b5742b7188b1ee79d9018ca5d6a6845924249cd9c39aa47a2230864667e08268f6b4ec790bcdd16d5a04acad54c584a4b3a69981d36446741b105e6b223b90cbc0937a541bebf1ab688bca054cd86ee4b20506a9ec6393680f2c03ee65a4795a11fac0406905eaaf653affc0aaf7d40123382717dc8853ad0c45a86d4ed01feeca43f6a5ca6bf0a8fd065bf0c1ab3417e3163d5e060f56910d2e90079d7c23785803ebcd11cacb7a3a8fc7aaa68e4dbab29da6343cfb3f1b72a81b73e5549b39cb1839c782d19c4274ec62d0e40971e46925af8025d3eb30c4c2f85dc49508f84666edc8d2d4e55c4796be78c2b59842059d02ba2252f00a2d529bd5c936faaceaf050ce66677b8e37d553a3013b209500b4125bd6a8f4cbe80dde3064c18c74c530e2ac1505db997ce12bb947a6195b32d4b50d7f14d27e11c1e18ee8f5fddf60bea50b03f33c90de11dd13a1e36f02341ab5da7654c647fd64acdbdf961678e6967a4c32d565a5c306520d868d52f394d40bbab48facf2c3fc2c48e5bbc65efa93661156a7f1135f892a74b4a117ec5d9281e71c24ccb10d028e8e2cb8aed7830820ed170c02ac4706aec3344ad346f2be1bf5bb79f5f4376f2df944e63d42764d5f0d0585b038ce2be08673337200b30c8c86502607547102f0c46f5b543c0bccb5a1ba266dfc8528fe6c9aa7f39363f20e7e940a24f8602d92610920dca5b40759fbb0c7d8ac507b8e798979c5642da3a9ad0e89cfe25ba5fccccf45066826b2f27fbac86776fcb186576129d7ba42bbe16278a998939d0b5233d2e97bd72b03a95cc55e2eee26df3f84cd60a03194ca8d15ed87fdd118f9983d1e6cfc7a8a88e9c2908775970bd8b45f61560a5c973d4fc42f456a3fc315c7a4f6cdb16a27d375bfc2288ab56ef95e98c457246b2226ed369bf4c6278a2085f830ea02c3f68003c44a1bf7c068ba75902b7fcc44651a038ca21352a7795ee681be7497a999f9d0eb8f832f8802fdc002ab44bc365b47e6267fe38bd9f47b7e6d06f71310babc799a21ec90b9df514f67e7a35f2eeee06c051acc0b045fd5d12f1035581912849cb97190ff151e19b3a3a733e009d99adac2e64b650f73f14bea8551da4cf757b1b300afd723b1c3d3d1cf7e267833f88e11c9353f855b8527d9d6c5a44b6e16d01670f3ad8f9d2ba4cafd875dd64a756dcf1830fe80d04f8d799a6277c01bbd8d996746bb079857d08c7584e01c4e01e8d6882ccd9c4fdb7bef90784dd84a8963138e16d1a55184acfe4ce7c15317d413fbf65fb0d77b8a12e93ee6af5ad0fdf9e8a19686a54527185f8681f91fd6945fdefe11bb4900e79060916779fbbd758f60cd5357c67211b5d8036854dfc57ab56fb18dcc0a1f245691ebddabcbb31fd514ff49602b9592fa253147a0020d7bf6d294a8bd8e5d15c78c101095af3f4a73eb0da46c38255d15433bf16d1b57250768db407b17b7bcef998ab0f72fd8eb269bb4bceebe2a1da8cdb21838c9001dcd1efe439cf968debae0d87e7c8b38ae19df2805ce71f3bd372152dfdda9a64f673afaa5a82483a5c4bb51f167badabe07149f37c263e7cc2f22b5cf9c7b34455736ae35d15846722b47afe2a45f315e90103368b40dccef4a2863fb1410504d87325c1939a93859c6dc9c9eeddceb7721ef2f485fc29692ac6e20e58273612657915eda68c748ffadaf60c60a943fff34d582c8cc791d79ae66e0c3a105f578ad1b4d4f02fd3e294058964f09a64b51cfeb11ee8d1a5a634f3cfeb96d6876f7b5cef0860e6a6005b2f794941ab2336e3a76586723367336e44eb6b21f51bb65feb0ea056dbd09002b49831d213dd7eb40dbaa439d1e654d4d21caff19b8eebb7a8a607297e3f2eeda0bec81c40f7be1233fa116eb244ef04b45e5c3b929968a99210dc70afceb6fa1987e2260097d057f56193a70d7692a29505a85508663413cabfb30b6a2b2c72a895d18a7d35088ccc5c72a675b15282ec0c1dad6c1a113256bc279eaaf0e97b4cfac4e2d216c6fa272d34fc016a0a1db536f9d77498fe5cac722ba55fb79a1c65b91087e5e471b414336cf0ad033e5d07b32b8c59b1cdfe94be09c6a6b525e0aaa8645cd61294c60b273f5ea5f48d9145764dcb2ab8eaf02d5caa2b2e3072918cef324e1f1892268679a05f12e9007bc12548cb52d2956a05322fbc04af588dba31cf5583d0274795d7a93f3a989e38e93074368b827e9ab3d1bbdaff79d7d8da686f4b2c2449f645472e82b872a53fa7597be0fc326c35dab414f39641fc721dc9ec0cf7214b10af102d787348aa06e5fd68c085cb6b62a3a78eec2c691b2b24c9f7cc842c29198748f45c7b5ba3792cd7bc554486139587b5a0ba6670b2220f074c5b70a94dbaa755b63a733013a5ce47180b1164abdb4a342198e2017f216503de9cc8f93b0864d71978ac5e6120484c1b74bc455d6a6721b281280267fd20684f1fc8917196db575a90355bb552e8b0cf5a18a9192f9af29ecb1b7f3f13fd7dba4cec63f7e94dd34b67cf7b8366beb9cabbe48e3862d1d13ce65b40c7c976f86139b388babe175d6d038fd8cb7da1aa05360d78bcb7d7f431c41e440bb70f078942d555f00d52acf7378e3620efebef6f47c2e3210ab9a494ee06a9cd5e52cd19127e7ce175cff4dcbb78074d3347a0bf0f1e5531628303442174fc376b6965a8b3c268f6961a06f54570718301e8546e48198efffebae716d678877fbe6ee05fa9a9d0e19795f71554e4a17ac7ed020035454325377bf07dd077d5450cb98d26c0ec35d7174e25da7ff8021b698d941c825f75e6808a8bbbffdadd0c0a5bcb67b348ffb607368f62a1682c342909955ca318ec57e5cc4589e0942fc29392d8afd6de629d36d61b59e1ea35934e38d95db8da95f1668341d1ad90883f309383d566e3fb057e4ba7b182d61c663390b899abc50f628d092da07ed23f8c85c4e258967efa685d58887233e732f430dbc8c9dc05c506f14fdb4196d4958862412cab554d62f807a40a0edaac67548cfcf0c98dd1162251a106cbf7940f30e06c1354c6d211c023ec544710b218bafdbc3fbb30f997f2e1ca52779ffc28c7250a77f958b32aca14fc69ca79519fc4dcf1d1dcac14028fbc5b56dd27740af80af02f48ae3c3af99fc5bcd5b1de1bd42d396b3ba2b69f62200e29052f07faa0209ab500998f8b75185fc9a9ec8b0177063d28010665ffd3e17a17a452b6985471c68b0b970bd6dbf7021e6eafffe0b30a38b7a1a0a4ee708559778fd20fa6bc3485b5174e09c9c6f2bcaf4e1bdf30e9634325fa8ad69b2a4dba2f4c2c47712692a94f45f67d609c8dd268e09efea150993ec2a3eb478aecb0474c7f135b320e75bee07832dc622907454500fb98ecb04606752bfc2dd50e968fa13fc159ab10c76cdbc8d76996377c115e9ca486255abae4af674e986d9e6a47f4f8c91e6b8003e7fa50584efdb5dcbbeb64c33061e2ea975203d8d3841f19eb5c0e67893ce26a059b2197478e363f0fc36e6fdd6eb8e8af1353fa1a6a47309859696cf1960282e7b6a18d20998dcb7e3ed96987a6bc4e07269aa3cb0173ae1e535439b927a5cc45fd4e89d40f13f07ab4a19bb0ba80658b99f1f801de1253e2019771d001f650292f7915060ad80e43bbf9c6fdfbceafb3f035ba229f0696a0a5f7909e7cf9793551020f451d4db40839b7d59105bffc0e367d429db080663fc832e713bb1ee6a52e65ccd0b44a835265c83217288eb1d9ce5d13fbdbbb9525effd27d03db475e64dea6015a6d0b4b30c665338841bed196030383fad30bf264da2988465b82b4f11497e501d849892a4e58bc527e8663e0fe739bb720c132e6b08d94e93cf83b6d39824c47cff833cdb3d6c4c0307b9177337e20436afcfdeb31bb52461464a72c2ad20d536b63c520e8b5caec9b5b9f179f76447c03c4dbc97ed9273ce7434eb0c5f62c7c6380372c80ea3568bf41688c2fc90ae53503c1faaac2fae71f8e4894e4f521e5b51b0acd9a6a8ef270a2a6e3d06de6f8a278ba5cdc6e071690348f846a66aa3cad728463828fb00f7f794a64c6220c487ea2712ad794330792ccbf790b4b1cd6a2be723692dea7aefad69dd1f2b651d4977b1766e985606c5256057e602917665e09cbc83ca2e80588d164edf8cac7ea69b8e6ba34fd4705bb7affb53c7843ca534639ff89782f7cf1be7d4f6740f7f3043f6c81d61c1d80d71a3bfb0342f5bf6f52f3d13cf082c7e54cd8dd4f1e9450f51e0776aa4468f61eff06b7c1eeca1c2ecded9d79c551ec6d7a2597dab4bfcc0ba1779021ad3ed744d93182a13798822ea567ed28ddefa5c4494dcee53951958b903bb5ecd9fbcd43479a8e26cad223e31fe1064ba7565fbdd58af1184c3e49eb0a8492ccaf738f8afddf8989134896cb1b114b0106732d224e409001a010e99aa69fba8fc5c37229169f95212b6c294ef814bac240ce2af7511c28171a945bda221b212b32fd3754044d50d77892139bf4d6a02e71a46d377171630d48e114eebc46fb9a65c258de43c137543b0fad93e1797c876b373043c027755587262f73ce4e575216a1bd604c1d01b013089f826c4bfb91a7a5a79b794eb662629e523dfcc8f8b10e7bd3de7cc6386c2dfede09b88f87a285e1e7e505bc9ab4ac2e950ce223bdb7b89e8a3eb19fff19838435ba14b39ce356721244d914c549fbbada3b7eed57f9c47627ee9970b068a948de93b3e849167923050dea9367f93e04c00adf314403a2550771c1d139af5c233c7ce9658aa409609547f09dc68a976c2fb689ef0170be48d20d6bb29639bcdb7068bb43935e8d6eb9ef292a90a49ecf80acd2922899bbc184b7c2fface8ddfe1fe1f64625f205055fb266fcd9b5167fe9ea8a868f784e9b1dcc9a640c094717a0f523d8212d866e881c8369f6d6b8b865ac9e0d80d1063d5f5e14cbd04c97022435c8f9b3ca460d3200ef8584e0821e94fe149c3fcf84ee71c748cd2356528dae0792c26514dbf4795129e4ea6b32522b70f113135b2daae53cba4c322c73df7a428e2216db82f05ce876def36ee24dcbe223c2a03e8f5b704c8f96827a1d4254ea4c116d2eee9ac4e17d82c3f653beb812aa9b6ccdc7d236c422af5ba226b539473f27e326f002ccfb629a55c39eb7926d88de6a4f268b2a71a3c27d6e7e1705f51706f0e805c38940f0506dbc6e48e7acc4c4370cd62dc44dce581bdd7021ceb04ef223d45e4fed929e1ce44e0432fc8d81f7fbea14f1d3a0bc097cb0540dfb4db774109fb26e47eafde301a0ac4bcd2f9b7432b80a8316250952881dc2b5c79fa34417bf6897f324270ec9a781442d34f5a772c87db1263fbed9e721cefe8a7812906ea2e6ab01255423046197c7ff3ea5d18cc4a39836809ce06324793b14bd62b354ad3325b5b9adf8c789ab047061e6968d0444c2ccbe44ec9c1b3529005ce761ee5bb97823dc24d35d7052e2118096715a15f6d0e60b49fa0cb677ad08fbf0624dff37cdfe9759d659e2a80ff92910c06f361ad83cd0fa36a7c9cd5fc7422445d0bdc305dfeb36dc798f16be056c35a5eac58a6a8cf12fa579b4522b915bcf05b8aa0423d6bda47a64be9367c0b3c70a1d2ba4f69aac7b45284fba712da03d20c99a50a6124bf2de0e24528ac5faa157b1a1e97ba140f9658fe21895d6a568d8c1f4064bd7f720578e23c659aeccd34801c129accab8edfc7170c3c7cc0c7c7cb48ebda87a15d25107c8463902f37885792f553bd5b822c4fa1a264eb36dfdce1441d4ac389704cdc2f947b0dc0960a7d5991110d9475964c515bcce581e839393528edcee49dcf0a620f8b03095eca49ac5cedcaa40a1ca8e5648d88f28ee348ad48c50773a3443569b8785a916d6114e5e6e8926a4cb9fdbd51cbf9e13e6234569b0179cda74cb37888f299b012fc54034d8c02107721a646feb3bd9df9173e27b6431b18b5ac6a3dcff94500fe15450901bac7c8d70a86eed8c4c85e5a64d8ec127fb8b4c62319dee619aa51fffb4ce2fafafd2cde7a6ca9c64c7779d5181df67fbf919e99d69700ae86f9e071bc73c06d0f73116e216db5fd65b77aa4c0a7431778d19957b878e95e8f6e870e0be69fcf0dc5b4db306bbd0f81ad935ed2581d462cb61ad5cadb8b2748024503d769cc6c0adb9e022cc4bf5e45d8a38314b4575b63c056f2d5232c7bf3d29f22e5fd60638a6e48f8301b1a474af3315d6c08c56445b75f82a0fe15bd27323de118d6412967dc50f9b0eb04fd77657d9116f81482324daf4eb483818d42e68967feb0ef022e1713c71032f18617157fc94878371b4ee47627418ac7fec8d16268edf9c5739bdd7336e44bac9518f96fd69c5edafd56efd4fe962f78e32190fe6a42d2323acdeb4aba56bc80787dc721d9378863be8d202258f33e7e51f83958670f691e19b73952f88126838111c8f58c4eb2e14ed7c60e0303f76e83b2ba6364fc45d55dc54bb0d9360b836acc667003eb4bf0afd2035eac6901b9feb02e35ac41dd78929c24bd8ac44119f251550742282e126acf7e2aef060dbd73d9f222bf73c9ed12b6802d4f56ea73c23a2bac28c07d040bb6e77942b172aea64e1658e739677417af1b6914ee5555e79e8d0dd28c503b1de69c5157e0072fe628f4aa1bbab3db47e2bbfa3c482f8d1453e88c149d6b1d1eff7fe367062305a8875d83069a4b0c672b718e30a7f8e13364546323af3407be131f4216407020845ad1f8b39083a1dc9267066689fd45dceb5d0c3fbef3623b26a72428ad7e72fc8016f6455b5529fbd5396f00d18e9b6efb6bd3129170c228be942c1b7a4e98a61561219814016b74a3c2f79539461d06e0e3889f194209f939e703ceb17c3fd0d702af65c70b20d0defea7125614a7e6f3900a9108684eab690994a470187cea79061df039c50445701688b2c5be20facf841593cb49eb40b4499fecafb1be227f2f4343f39239bffdf19ea5bfd59d6c1c866086e1d8cecfd601b47a3feafbe7365673ec3821945b634846cf2420707214501fab691f44bb06d5263c62565a60b1748e634eb3bbb430f596724e7e8a339749692cdd2605c6d1a7de62c8147af030ddf3f4f5292a04554412327af29d5cddf70f155d01bb784356718b586079b3a46f0139f2ee8e8fd6891d2830cd46f72d00a3c26ca7d146d9fa6685823965299232f916f4ad8fbbc8e02a2aed2aa4ac337ade5154fdc0f089fa63dfc7c89bf4b6b068064f575c436dace70a87bf0786f0094c1f398185abdcaba29d5093a586584b1196f7f638b4992d4a24ae028abc20dc3a1fb50b5dea85840d29288be8d1b2737e606cab655c50d04c2c809200a3e58e32b139b8f5255e4eb29383a377ed6a721ea4508023aedafe70c66f677e709f684685e2c09b024445d0e52b78d5f0ebca780adc7bfc599a20a9875bfc0d3d2074285c9e2388a558f807cdde95f44ef165a40f78f4982d4103655437b830356336126a93d8fcad8ce4cbdba5abad14f8ffbdf082adfc6399c5c8571e44959183b85cfc8ba3068872114faf20f5f200b652bd99e6fd16d375f7bc50fe8efd6a51f0e450042ae1c7f8291d057c412808a1e0dff80a0beac6ad4aaabb48ff756ed670d998f2247bbd9a947f20721810fd5cf196b96836dfabbc1fc9a65a619536f57fdaf37824555333245148339ae7a7d671339ff85e255a8159b5d8a2f7a9c5b3f52e8167b7d48ccca578d915feefe32b836862f848c95704545707abb65df8f3dca6daef8fb9b8d35da0d4f78d5e58c3f69725578968ff179cd349d4dedd5b92d6a12aa8a4cb3ea408cccbcb980392876838c2f34d2ac76ea64148a253ddb276aba0f603c8acc1934304df6b8297efc282a16ce8d59cd01a9c7dd57669558253a31807ce37a5ddcf909aee7bd22282e71d237d332920b13739b673f3a2dc5ecf2da7a1601cfdc0daad9798ac0d10bee11a208f0e3ea375ff671d97efcfcbef00229b2f01e8fd9a7886155f4fddc8da4f37e403d0274e5e26e2620c5a70d9b5e86e938f59eb7eac543abc9ad49c627916f80cd9ed12c5e0e7dd2af73c9c4036497d082fd1867596e3751a1cafdc2724c700ee7cd0129e051e3e9e41c3423d77bf9b02bfca5b46baafba6f7c881c54ea6964063ad926573654c9921a48ee845656dd05e09605132d3fa64295829a00933bdbe992919a1e22558f7806cd4ed80f2948e94d6fcb5e9963d37f539e0193a8fc560467d2deefc3d76b799f28298055555e5614e75d871258f2a102e38c2398f050592f4c802f026979fad3d8b2870467397f67f3f72749f7153f205cb79eda72dd8e2b0ae7ece3d066b10bf5aadd1e129080a467d00726993607d010cd6b364b58b20925ba16d41381607c81c6ef2b351e1f44ac1fefa4ee026e31be18945fb001dd29fb9f04c7a8b076a215406b23ca5cad2f8e386907be96cf3cc9caea172c1106733720eb3ea68d4795554b0eb7f13e61e6c0aacd526f7740f36b31220305d2556572fc6237629a382c286f89cc59b951952fa38562ff9cb362a4bee97013299cd401cb0a22749e0473d2e80b34866b34b6651c4398f611086effd3951bdea7383805d7f12738e20c461bf183f2122f88c7f8887e49b847a8e922ebd11862f8b7acbe67d2bebcc3858fe97fbddbcf5d94f21d77d903ec18ebcf1fe55a687c41d615522f887c935c47de16ecc4988f9d9004cb746cb5e83dea912ebd070721733a51748de8cdb32ab0ac070ec2ab6bff05112413916cb21db5332a8806f5cebdbec725ea299120eb51e98baf070c430538b7ebc54c586e2eecd9067cbcbecdcc08ba6eb9788739984eada087c55601752e84d91b8e1d4292270918f2bf5f2b8247f582dec59cec22415716cea42dd1bbfda00cb43ae9b2427df84b699a4f023b1e02c04a98814f5a15158f5ecf46bab02e19114b7a22678efe4d6857f5872f6812d44f7710012355aee4f0d8e7b7862708fbd80cb87c8240aa94eec41bdf93c849123254e1c4bf17e986a71871df55af98bb13d32db9d5d7bb12d2eb992926b5b169af2111e6e859a753c7843f15bb518b3359bec2a29b4a54ed0346a8b078330493b7da7fc37e0903ce4de04ed1462f1c364af20fa97015662d7c8002300fe29bfbaae4b1b0b41ac1de768d4f3b9ed59dd9a2040315be8d83c2b61fa138831f4a12faba8869f8163b3d8169748073b7461c435fcb9055023cefa12270b98ea16cc80e664ac31116ec6f42707a2b02ec03eed9969441baf9c3e38dcb4963959f0f6594167204087b82d1557c0ea36cfeb478fa15fc3ec3d8881dcf7c8f3582354a426605dbc00c0ec87431e0eef1d20016301b2eaffd8acbe9342c3b86e19088dd973e208c60d177b792a505e6369990351e58d44c51d9d9864f53ffac1a83b965947ccd311f82965a868253d57d7455d55e5719bd5b74b627e17efe4e388006ba9a2ec239df7dd64b2ef839f558566deb3516bc6c63c4532f098f8a9c81fce9d7aebcf2fd966c6e5d0edb7a07310666f56a48da0a51213377d1aad86ddd604d1e8cfe225177179bf62433635a408752aa8af230bb6c086929c31528c8aa13661d5735e4e9dbdb8ad38d9a8fbbebe1e3818952dcf9e5639650598cb29c152bce3c637932e0078cec546f827b03fedd5d13cdc8c4d90fc5c1a0f5d8c1aa06082040510af7996259e79373bf15d79c131b0bf299c2befd080115f28098fe1c90079b9ce16b94de6fcf90316389869b658c5fca2a25cfd246af010bd5278eb39977435686c8f38645662f96a3cb3b594ab28cb9174f29d6b2355a00277de0fb830ce3af1ce5ac68a9c4ffc981ecc5adf79ffb7c3661f31da0daa1c86f431866115f6bc583eff6a0153663ba08159a094ffd2b9d71e4d90899edd7d6cb8b864303cc3a436c59bb21d0aadfd420f8a483c55f8692ce10819423417d59f428fdfc7063dd96c4fa6c8605228d1fb78d5f64238d9dca62eda5f0139f2b2ecabe09907bc78fad215f5d6926654fc0ef305cea10f2ef98e4fa595b5e5eaeeb5dbfa9ed364de1b04d6804113893cf60a6906ac704b78a9eebee88925e80a170797f1be3ff9db45f5ff991f48171caf393835be6662f9604bc578b731a4fd01d127ca148909c877e58132095ab78a217551ea126e2ae9d37a13ce83d2d3a8f779c19b84dc607d314924b6f76d772d149f6a617345d8ecb9b6e50b59f7c266fadc1b66dd38b6e3a9ca718f00027867677bf1f5acc569655fad8600e6589917d85e7f33db90ffac12bb44a817ea139f4878bc85262c4dd08cd016988361c862a05c9a0ab88f0b9e477f09823d8e5560d8d9b8cd47d278f72064b08b40d43880faab410de3f8b60ff79a2047e4b987ff7525d489a3cb182feae79328874f47799ec85272dbf5c43e4e4c2c85001a7cae5edbf61c23d751582547db6ee7fedf2c9964551523f6ab61a0a4e3ceb153ee1dc484821fc2853bec33ac26afb1e08433040f2bb6aa67010f8efb315931737fc98c92c890dc5f00a0bb5119c05a50d4096821b178200c040ed24e0c6d5f7e28ec06a11d9cd70f0e0f9e404823a67891aef7b431f412cc4504c75da1d773af713bcff14f5c4d6e3464b214047c8fd64a99046d39ec31b11ed998b8bc18f74c810565cb2b6e8f2d513d703b5a2bb4a603e698025d44f08f5ac70b6b30ae0cb1bf99be14c90b7d0fb7915d263c37896d099c4c307a35a244a687f5e98ff6aac591296874c176cdd7a3ad4ac2d73a4e509900462cd491be9b84ca20294e169f45e9ab5d45ea3723aec75cdcfdc709f762cb53b4c08a2f30cfaf16875f2e524327ea1d7e4b13a4c9bb7054f33e355a1a39724eddfcfdfdbc6da4116a74325b655aed7b61574c08ecf7593e8516e6e0397292ad1737b5ff4514d57ff7940b7c77ccfacc59f6f11dac195c279ad60dcf826f214ddb11997396c02bb96a998ee55a8a91905797a4834136f6719a4d265e7c430be83274d9ad799d848e8484cbaa64de893f768a7402bd1751d548984e82b582b086d8c87e724c01a194e8de7247d07fd8624eace3fcc1f7efb23ed5705cf520de9a137ef8cb36caca94a26a6cd13debce85607f7897902d96365dea73b6f0192664b8124236847e2f8fdf31a7ecbbc436dc2dd9e39745a3a9f0c83297645962c09235f5f5625df407aaf70be1b9c8fd7f9f03098820a746cb24aae770a5097c63e0104be055711f41b54e13370d6ac23b839327b4ae2adb331c76099cd350f0747a4beb9ded4003b97de857382a0ac884fab55d672f8d06ac202c91056faa81e4f96d0a430dff7fbf9ebba3bd94c0fc66d7cb38e1ecaf9e97bb2d52e3b40ab593b9d704996e0f470b16e92075548b9cc8ad3ef581038ea5a3138124ec3c0282c98bd551d560d7580e023a38665a19910c5cef992e553bef5bf52ebd75ee2bde027280342ebdb82d445e29bf2c681e507e564f2e0071b6d495ddc979c76160b718a6cb58cf71d2ebe80aeb7f17279a05698b3151ddc8bd9bc8525a19b885dd23a17544c70e617cc115c492de54340e426ebba806ff4144a5221c11fa0c0671ee9eb1990c506d905d50582bec2555bf732d248f404e59285633970b9da594de56205e598aee176039e09d89564c8011ad0899eee86434bee5e0802c28fc37055ae89f5859081dde07fd98c7fb1c1e2472a62ab1ce9155867b5c331ff5dd279df42445b981a83b9ba4a5489b71a5c09e97ae08d60c53263ef97df856c067255e32f608e61c8e6d2bacdeed76f3dc5946dbec10c3205d53bd2f2e9465c67b747a4ada31427ddafe3c7b8a468d4ab39cffd02b0dfae4b9d85e583a4d72e57815afe309b043f5b64da7a00c19a661cf3c81d2e40044aced7267141b6ec004f8401b02474af4731c42c48de45280cb836af4de0f2aea9e4bdc3aa2166bcf2748e84474b1f4a03b2804f9afdca498c6b10eaddf8f06bf50171e1c4906139d15551c699926cc28d9541bfcee3a7dd2e71222899b47ccc6df5d476dd6c3efc87e80cbd2fe447dc801db299abc02b2a021b8cf860fd25c5932d1cfbf5eefacd70e0dfa2589c3a492102af02756e25c5952a8bd9a341156b264eb755056b7e2674ed094ef952e961c43b1a0b481021a7a371d6541ab6499e4f6f194fe14cba9b6252bfc5cdfedc8189df31c59e9d5eec81232182dac519802550be5513384b7bfb477abc8b482599724c5ea755861c4a8dc2ab81082ad7a60460dc8fdabc4b572a6bccdf25de00afe5e1fa6b547fd92c98ba618ef6c63b26ce5c833ef248d0439ea2740ea3d7ef7f3a6c528129fc5fa4c6483176685757b3db2ef95550063b64426aa3b3e91fa2c292ba9e8d4a2bff51ad96b3fc8007919c4cdab95a80fba1e442a4d9b45560ccdefd6e8aaaa0bb0e63bd4e163e8ffb2538bf3ddcdfa93b83d66855004fe4a20a5c240356f14b211856e8433a09022107214f3934eda0171faa36ce831893e97ea772d7c7383d53e8175db4ec752fe43d35c5318094ffd6d5d45ec157b42521e95a994c142e538f510b4c8d5888a1319f7912c4ab1822d9212728f1f4beb05d5d7e13a1c3bd79617d4989c2b2b92b681bad5cc9b1baf19f91c1dab4f6097a98843a9c46c97847173ce0acd0cb7fd5b38b8d1d01c19d21f52b924a1d397587eb56dba285a3ec2fc7e8cbd252aac6cc6d106753678245d429e8c964c8ebda8521678adfa85358b837d8010d1d7b19f9404c172c9d34af4a9b31b38a523569bf2b282279738d9f62a69ac126019f64f301ef1d4655ec4c86df106c8483f1b4fb52c80944b66dd8bfc6a2a8727d2fdc7836985c817a3e333c6ac4f78f01cd9e841c7fe6afee6b406583bb431122418dd7489ef7831ea7052eb5d698fbc6d4fce79ac311585224822bfdc1ce1b04d39045fcee4a2f59eca7a8344d65a55ed081f6d162e2e45db6a594c2ae0cfaca2340c4c27f43c84ca08628de2b3f7eeb9fdaefc9169fd8c6e660e229f367ac1ce54851c6e29c9d10634d783937308969bf767a6629225ba5787604336eafcb9832c9e368405182e3c8bf242c5761230efb3c4c00d1a71266d567084450ce4cfacd0c07fc728de2066350307ff00e779b417cf3e34a83a60a078eff696e98b6d80cad7128c33170cf710f5d61246a21d784e27ac5bf1c02cf06cf92a878993b5845037be18e86b0797fa13ebba09f7b9fa1880135f623ae33629053bb0dd433ceebed135127816d09593b5172209766e94848775169c4eae00b32a79cb70c22618a9ae37e3e5a09671f66448bbfae87e77d7f0ee64afff344ffbb6aa3939b8f1bbdfc58b43dc2c5ef87e8294b307ef291ba30a8a545da9f5c1d0f08725597858d84b1ff059ddf242380573ed055fa5ed8bd2e2dbcf766c0fad7f440494f2b3b19d19e6f4c136d3018a5f4abb84565a973d2d5bdf2270308d01ff0a3710ec1ccd5d3d38aea9e34a3d7dcb3ccb032066fb839f54da0627abb4c69bb9d3ffb457e05c08ef49ffed790bdd62684687de1122bbc4edb1e8190d0339103a80e258ba7f693073c93023a2380c127166062b214b9f3ec6ad24467adf6d5ecfd3d2de8c6febd3b91daf2166a37c84afefc96d45f7460ca116b8a03bb08ea268d5d5a0dd07fbabb28dba8187c55a3918d094b40ee0bc67e199a9cf7e76163f07b5bb7cde8e08f84a4742e62f839dd7b2c35f918c6a81428ac32979f8d63957afb98d7f2ee25cb30a7952feae0adabb182874597d4ea23ba166875feda02477cf3ace7bd1b7442e579c9d1882f828ab83220c5c2bedc4883e79785481986fde3d6bf1cd8d29c157eb9e8597d89e4035ebcf928567f5f3de806992e188f93948a7af721ce3704f02f5e97a22f7794ad33b8b63079641745087b9d38a6da4afe424fa7ec0c5d9a2918b7a52a80d7b4fe0958f55c4ed5f8e4844b19f398a5e4df05e13d8017bec57d7505f406f4c241ed15c521b14dc147dcffaa049011c8c1f96c24cca67521dc5723e01ab9d1b1b22c1a26ff084a5d7184ef2c7096436d911339eeb6e7ad5d370d71ce54ad97449a17a58d29ead33a1d1377660c4da490e0046d06779edea97b12c3b999200fb2e06a0321102879c40c8a3e1571d4adf16b8cd2bcc2a6c48ace8bb4327707b8526a876947e01f163cb8d9d301be0f57d3f6c7649df425f65367424a93d7afd737dcaa6b32a7f92814a0d3210fca21ed267e5c695796bb387aca05ae47d3de00caf09bbd85acaf8d8de7876b2fff73940e586d9ffc9f5676a3a5076c85143f241111eebaa633f766440ef2bd2e16402129f42553e9eff437cfb89a8d099804a35b63db59224185c778590b378e48660a5e73630559b87afca3b09397d24760adc4b29f17142b19470008e5bd1fd98b294c88503a69a0441fc34f85145305d04acdc80072c1458df528d18f570834ea553b66f214525135922ffaed1bf4a70bda5761925df513288342dc051ece965e0e78775eace3e7bd06c79f662171b0091e24783b64190c1363ad6361cd0ba67335ef73c6627c07771bdf4b9995a7e5101163a05bfe5d94da794c80277fa961e183535b9dc1693c23ed36aa0a91726b71ba196d282dd2c535191fd38851582bfbe0cb8b9ee3505cb97205c31067c338750f1d4c736e9aa283b74a5c3f0b762f1a29b28a7889fd6734a477e99130e747a9b1cbebf9ad93e9b421166817ae8f035b5b5538b0540bbfe3f2b3a060abf40161284f154bbd5aeafdb7811f8ccca0973e8ab42e40a5499235d4c1202d0b2bd90f0b0bcc69a64e32f66698df30b45c76b126ba1f7d70b3ca4d582a05c5a50930b025d23e7934444e1847f6e194f29b028abec829bd8b52403e96945f567b91acfb8ffbfb9fc29191ec8e63255de28a2495b2609d790176a4f7b4763075f86ba710fdd49f276561f4a185d80a99e11ac33fd4a5bb66e486449f8c104e49a443b8a7cfb43354d233eb533f1a89fdfb16f4cb3f02d8962f013a36f5791dfafc3d310200bc12a4dc50fa83a63129dbd0429cbe1e970af18ff104a3eb366bc1b69969fdf643b294be29f08c88a18bab9d233c402c9c4f822cee62e3ed4da5c84eff885daf8b525e0e4a595a957e469bc52874997c04ca0ada88d884fbbfb8c36a70e8aafb40e188bd0ec85cfcbf6d207ef2364b716653b2e2e6dc35ccdae2c8b858edba5a8d7dfbcaaeb24538723b63a78084205173fa72cfc5e50280df700f830ccadbbe19d31dd7565dc1a2cbf2a1a1d39b3ef69d7738caadb25bea7e78a398b059712622b2c765c5ba8577a8b642655d3c18cc816b618ec85f2f17fa4e20f03d2c57575e92a904bb83e4a8291ba8201f83bba2108396f33617fb112fdb5dfaf3d69bc72180e9dc623907163c8627c5d7463afdb3c61907639965ee9508ef8d1b9d0b9bbbcd20c53a010d55eebc319b355d2eac9c2b1500fff460cda8a748f03d6760cbdfd5f2dbefbe5b216a68a31a8501bf82177366d8e2ca02f16c6fc0d893c44a9e2f9725593e84aded485b2d99d56db510bc60038dcf524ad31ea2c651521ced8c6bd085021b8f6cbc66813ce3fbd81684166f3b0609f035c5ae07fc8316564cce638bbf474913d1219a55f6f9a338b542c8531df4a01e3cbf1de11637e622efc159abf54d73b624109e133e73e27522c350954e81789997f6b33887f9e4fba8eca9a3d30f7265c7b3b83a634ed5dd41b061071d8ad844526363b10bd20f612a0a3be05a827178b05d26c36665c98eaa347b8b1925752a15f0e89a2d994ed40f30914bd017af2bf299702f6d7d7ec33668caaa21ff1f0659c6c1cb07d25d46ab8e3278256b7db380ed07e93abf3a998d306e83304563fd8ca15c5342b9eb78ac280a5f0a0bee4b268b05ba4f153ff99af57f893e674560bcb86fa2c1627f799a7f5fec7bd3c5c0b175d650c9678cd9b44ee894d73f29d34ea6deff3b3bdc6dd0ae01bcef758d6f0eaef7f01a46a99c01ae31da1b09d28932757f83d96e49f11ed94a1b7827eacb4d5285750eddcf2cc2f6a9140418cb07548ced5c6dc7224b03769612ec6c9ef9e323abef86ab13be249b3bebb1530dfdf19ce02a50d98a08d811c9161d6dfcfc4ae4e49bc2b35c5d3f22063686e8cbcfb89bd42e41f93f3d7870f587f7e3a9bb210791de9a0daba5d696c521ba6653ff29d3922a753bd9cd29196e788c35ea3cc631e9da3bfff22205d210fcd3c700e3e2d450bad8bced5eb373f8e65673c110d6a3b67666633bb1c5ad2652e9f3cbef1e046d9e3dd5ac9f128adbf5acc5089c6925baa60ca86eb05367818c370e037e5cf3e73e4894ef561de34e914c3b6b791c3589711c4e46b0ea089b08cea1fa08c7672885d93187c6db3eddb940c99bec1e89437db1fefb482cb9c06b11105f7014118db41b60fc4ebc63b5199bc8db3fcc65f87ad61edac03ce23451354ee1ed8112148ae715c9404535611593aa2d841cdc1eecb5e893b4ddfc41de5bc9d6916eedc75591c371ba60ec4682442b442a63cacb635dc4bec6b3f2db0c2f6fe0270b93a05326f267c65003deab5bb28b84eb152bab2dffeb64d9e2db128d8dc1acd707faa5b672511f56b101ccf42b2994f3c757c96c4f247b80f189f676166b879af39828fb292bfc1b6a3cdab1a3424884953a4c98c63ffbff2f43a5c1fd82f991cee93b78a7f06603ae0c78751f9b3b7c641093283a2dafc44426c862ba01af44ed2b9b78f3665182c14926fbd06b3b6fec38cbf7f083673864298becd400a804c01fd4776d1f2fa6ebb4940e992e8204d460d91cd84825024f494d7856610df19e83b16f02e0bbe891a7f800f1279a2566e61f8e6fca79a16165aa2690182ffb4221b6f8a9ef58aa2ba6b72a97e94e7408b0e17c7bed667c77b1147f6e6d1bb9643b77d356073241a31c7419db0a34f9a105e0229ce2016d403043c59c33ee55c48eed9e5acad888064694e608f08f70bcffa71dd6623d320dd6ee27635710e1c9c6ffd4385948142c5e3ee21de633c8a5d5dca16a5f45e900d57dfd56bd2dd2e309c4dd5703cfd6a4e779a7c2ad753c12effba7e40e3936d07f51db8fed33e6f33fd617586e86e254d22cac603548be8912e800e0477c86c4f512ef28f3e233e12f6180648ba62e6c0adf4d57ce22b38ab5ece882244dd8d9166c0fe709f25448e7857d3a20824f632beaa5cdc5a7d2dacd46e6f11026569db6ff4ac53ab2dea511811279ea0f67273ff236260723ba19df514c0411801bfdecd8fe545ad81916ffef9fdbb3a193a407584050a15ea300deccb95e173f5027ff6edc6decdc5bbf93732a961279f5c25521a759885fa330f8a0053eac38a084d42e6118e458dd9296335d986cd4dd0951e6d83ce969e038503a8b784b1d60760c99823ad605d77c424d3eceacc99e7a11ab0e11f9e882128724ad37b6092f54a98aecf3f98ee3199edac5f39f1ef492741a55a5eeddea6ab55190d8e39884e25a4b9e7f628e4fc6a14b89b563adb131873d149b099739249702da8069c1a262bb2b5289f80074b8ecc43cc23c06c2543fc427b68cbb201481326bffaeca157ae93ac119a7e81d01f08813e43d28163ddc767ddfe8bcbe6b432a1c391df4ccbebdabd6b53f5c2968c60ae1684ff726c6e8a587685f5a9e9405e7621f9ec89aafae9578962808e63d0d2cbb1b08e767061bb9bf3e371c70d91830da77e3dc2ccec981ace1ff182406edf43349bceadd11321e42068b4a9f433268de774094a7872c54b2474a721a1e04c076f00f4d700787a4772cd0c9653c2e3fd5e4754bae32d3f2015dff46f0aa8e190d1983f4222256fbb2f804ff524e3bee563c7177218d7d8d698f9396fafb2153a5e3320704dccba271370d0fed3679440bb5711ca62349d1dfc49070c2104bef936edccfb8e93d675999508001e09d650a46c1e77419cff061d855b60f852adb3bb1fb3dd0e385673a22030ad5088c8e4512c69fa244bb5d1d6e87b8a5835b89720d3be6c7ed943a87886c4a3028ecbdafedb51c009ff9e78ca27905042bfdc3a19964d1534bc4c1d9718fe3ddbd97b9fadd9190882d65f4dfbd57daf719035f30fc2173046ea69a7cb8ac2505dd80b385d980b1d698ce72ce1d3d655cc07689792b63cc7cdc8b54f769cde4b233898163f3f89b958648ff25d711823300aa2cb88e4e88793ec21a04b9559f013ea4ac5dbe45d9967b038518a0f1f9b69e6500ab956bf2d1db5671248d2ade8fe81fd7d6423d163ee10cacd76f3d041d74f7f88d6702bf75ed11339c3a06b979cb276ce4dae81c8e6bfc78902776d7fe4901a6aed7eb605d0e1bcf7b9710cace09f5d43010945c7c8ed1f265c89f5b321d49ff17d5ef46cb31b8f586427f5f5b35e10bf1991272a9b488076a07fc630bf907764368b1955c21fb86a00f784836be405a87f4625d763b2d3e208eba870ecf4655267a73e3158881217fae2785940e764a210991d9c9dbb1abf02b05ab44f521d757e65824c21abf73546b3acf9cbebd6613582fa6bb7406d4e9fcfed78c9983d3716878f9df390ee465d813b97052f1a739d8a78aa1c4dd7c9a640f1bbf674600c72e2aff252f97fb27e4bb7770695bf309bcb0f4012cd5a5c8b8153c03b75a18fac6a453a7b11028f44fb8f862f97210d3fddef55a6f77cc2707d8b7ea33b3bf0095a593aa551ff1a156ca54cac654f3be465da3c42ad04ef5a728f6f12639fdbf9eca82765a22723e22340bd19ff64063a172dd3aad8625dffca365ec7f2beaeb4794b0c93958636aa37d36ea1b32c1d36cb734b34a678e60d82c21aed1a9c613ecfa7678a99001b5e2876b3b2cd5ce84e0e334abf419bec0f26799e88b69e1dcceedf3b7fe18282f96a9a2055c8c4d4d07db05a2fb7fcccbc5234b7e4d4524c55594b214f97a132fa437606748f72feeef4b4605d25230eaa9afa53dd55810b2fad1f286c8d53ce3c9b11ad833f3c8050776da22c3e91508167dbb74caac6a575d738cf63d2e5748c2c7accc7956c9246ff446fdc457d2de40a05a916e186cc655ea1b0100e95b137b4b85c842efe1dd5c2c020d40f2742cf89d866d9cbf549b996fc6f62cbf3b50fc9c8ee55343b14a5a581cd4008148daacbdbcb60e3b679474a6195d2127b0841eb2c3d70323e693e8f0458ae6f5e3063f5c5abb099569f5a57b07942a2459c887aee780ff61dd67ccbc81b65523d035406947ab84769bc49a31ecd7f834a12d4afcdbf4f59a7401740bf5bd138a8fb285025e7c0bfb1a86f50b4869b2709f7a053168a8ed529ac91df517c31c2904071673d23bd876d08a0a4745aec3079c0f777b9a56877c4d6f4a1eb6e59ac73d9dcef95f4b00ee0360a9163b255a03a03db72cf4d98e24f2e5dd4dbee581e1f7d0b2938fc4c831d914502ee2835a147809f84c984711f24f7f9d80ad1f78662afe456774fcc153533896930242be9b664a07e90c785cf57d796c1fa6a0dca30e0d83ddbdd222a6ad22d1e619ade20bee919fb11319423e64634de5eb278e172be0403a42d1fa85973b08461c84a8eca6322c588d6c2453255b916aec3cef259a123f9e09372575ec20d2c0ddf37b20f922f0a957efd0137db37c3de1fa362a1ba58d8e640e21425d3d9f790a090267da7c0a4c8b9a7fa28d81865ef9dfee5209d7126fcbe21aa9aad13a59db154501d2f8cabf50d5a4f52da6230e5f2f1d093a6199c29f800f5609cc5428c1bf70aea9c723c302ca56441099957d28a488a102e6d1d457a4569385ffa458d780ba9b1bd79d4af03236250cf7c71ca0b9168ea95aeaef1dcc402be31b52c728c7340f8c3d38bebb1000aeae28a42aaa9c9a7cd404cfdef45c27022910ff5bd6def68cd334751ef9881029019c02f863a3d22007b61c59d982110abbd255900c14975d5bdba126482d4312c69020815352a52072c289b57eceb150cd9bc9775929110131ed92e333b3d133c21e31d4358de616193f1714a342129032727ed3d704010e1ca460d6c3a5585d3ae9a78a20550d3231cca68d6d86e67a65790fc8d56a15ad1096bc9c377b2f35fcdce7fc3ae62c09eb3fe9dcae8c52ab14f1d3011d5aadabefbe697b5ae3954a03480407c881ecf7ce7ca63da84b237fdd3be132a01ea3cdbafc2fbe4bb2892f7ced9914c18bd91aa6ff0c0d5cd5b7208062b7ba95debbe4763e3590cbc47bd690e22e07b89029a1464d6ef52f3a14de4c334ccaa0e39a06b6747ff5e0131b66183036bf5146a85cbfa5d78d2f52a080420a0a67dac8dbb9cca96bc951482cf90d4a834f5049049a172377f996baf4cdccb5ea020ae27caa4e57eac3a2015a295c6750cb4aed5da7a1f2700364bcd19225d56d6207d75e83ca7986fb82c32844fe786a6dfadc28a2bc082c5e4aa14c90d3a21ab071b41cee4e800b9fa86a23daf3437d391706986016dcbdc3c9a882733e4b7685a00c35d5091aa38f56f7066b192c422ac2f84abd26b4352314cb68f1ab715bffcf79c4e9a26497216c9f5dc0955641e74669561c59dae87251fb4166b97ca782a3ba1198e7c47ecc686fdb29ad8283f950855ce70674eeef6541af2aee563fefd067d256673adaf6c55d1c9ab2a33376d534644b71cf0d9d32a43363ba3c504f131a24a1d57c55e09ae4e2c24fbc1e1a8a190cac509803375cbb6cf804d32f5736c9c5c3f45d92f8ba165786c00cc4eb114cfefefa87d4d0a587ba872c8f958de1f4672bb5a4b0f7f2883bb88f6605740eb85f6d937c0f8ac4db8383b656a0fb02b224476d8c43540e3db7e0cf5321cc8e1650d723c62f57fb1585eeaad6b9150522bfbf246687143f2f2ecf3a97f3ec2fa81bc9c20e0f9442e992eaf4f748aa664cc98bc8df1cfcc68482c720255ce34e82671d76bc24a78d40c29b9b0192e915c1922127f5df87c2e56dddde8452179f25c07bf28394218e5b7ce9da517f0ea8a28380987afeef434442296a2b100051632ce2fa712c6228bb48f8c85890e62fbe5c01d794f2a64e109f6709a8085adad6cc106916af7b3014460fad8a92ae8cc5b7bffb880537a7019fe25fb0c7bb5d580426ee54242d2c5a846ef0edf1a0844b9289fcdeac19c68d1bde9a34bef3144ec3e17708beabf871124ef820a1a93920b347ede6d8f6cb873a8de63b3498df382523ab5e28e47f247e3cd3686d1bb07180d2d340e894f86391c164b287d74386124710a616c49685ae0518e595cfe9dd02f252d97b0ff5cd346346ecfbb13f7d19143a8e4cdd58d4c1bd78ac0ce32be31bd410a5a5238eb59a5fd678de86442c9154f990484ce05cc9d0fee28c9ea83b9da33bc183031c54dc994292baff2a469cd7ee3f1e18de36c38bcd556949f8b32c21078309e67a8049ec721c3c740fcda8df1de4dbe1cf0abd567d2f6a72b5ea19a7bda981556c2bb32686c742744432e163ca8b9d9d8cffaa2cf128431d987a3ddb1690d169562072352d5cf641bc1273849d8552b962a4c86b69758c92481c437311a537d92a689301e0298ff3d232be01977b7736a6e02c108b2ee5b3694a69728e08c41eaccab0936cdae6b6d73bb2cbe95a0057306bb040ee29c0daef1abebe2c2d55f9daae0c7abd5c7a5b3285ec4d46dd70ec44b10d6bf20acea6dd88c76a0f51342733d8c9121cef90c99352a63a76a75b919e24be523c83007bb2cde9d117841cc9e54ae221aed9834954cc1f547c3fc47042be186616ebbdd6dd22e4c2fa41657a664c057b61b6c8bb11a7cf293deafbb809080e63989608589eb080ffe596de49b8c64e894cea9900b594e01e5d642041174153b01461de80459dfadb938e543435db8f7ca6e16f8f735451b1f5cc1114ab5981ec0b757a82eff4ef71dd594b992b6f6885c34b349f0b0124821f13bfee9ec20514217a602048ab1ff5e10415b1270ed902983050649a3a5f896271e997852164722dcb0661dd094bc852295f328c1d368b9d5d8a16d688a58a3d89321ed87005124e9f4a513537d96b36444163a482bca5683610d52638615c196a9f1f6a0b50fa3eea24247e379701f26a3f67340a4507a4ba441eb5c9988e1fcb4459ddfa75852e584734fc6b162b883a883d075108d9e2569f3846e9605486ebb27eb0df7c90ca2e32453a01935099bcdac80a937429c5ff0a2d5fc3b8bd7c4c48bc2dcb96fa7bb77d18e3a8b7317429aefb74af972302662bebb3a4e8d6bab2797158d9863652672436f4d0128921c0c2db7fe17b75261ac66950fc590c0925b0359c58c7b4ca5cd1dafb2c5f2d2467b4b624daf3f5d47dadf983f317ffc22fe28d71f0b6b532bf4f492dd914bba0995067cdf6e11d84d6d81fa5f35c0cf13f8d5c14709aa62ecc023b22a08965e3e0fd05730b8f4741844f6e74087c2672a6c9c66c03ce1db4717f036933de34a0b09149f1c25e8fa7157bd71cb3c67cfdbca32978d0000fd6b465b1b3722dd12dffe61295bd1f38000f0477ca1e79da1c1fab9f964dbfe8a6cad466fedbf85dcad9888fce5767d935a14da9ef3bf7baebffeaae8551d3d086899252f2128b173c8309f18af5a762f914fdfdff7ab3b43a8b59568afa4076c72c7b3aa93cfaca6d51a04bb8bcd3172162f936a053a0fcab0ffd188552b56f90dd364a49bb4b6a77507accf328a99d84bc8beb08caf01aef795ae6f3ea52c259f142708aa3ccd0b371faf6a54d7ecd2bde0ae2c84267e043ce001b56e4ac628b604f16f17a4f29d43aca781179f27fba8db96a9214bf0ddf1c02cc9ad241da9111523a178fe60805bcd9f2bb8655bc5a86163268ace2904b6d70cc0cab8187f44f49a41b6a7a9413fe7edfa3b386cf52210c06333c039d60281df0e2b7794abd446a688b7622e740869ed3ee1a5a0a680aaed146ff05a3db7c88780ded9f6bd23b5e3b5995bb9af0440de040feabfe87c94545d920c2d9e0e3aadffe116f53d0a08ae650817ca1f0f719afd89044edc683020e7216e2d159c5a12d3d867999ef273286a0f2b125bf45e97fd532ec6f9a2722c026e5b286eafa78d6e6a364f388b0065f08cf62cd4072657bc556566da1a40b1c0fa2a3af3eaa2aad8c5f8b8fed68363724c1384ea38f0ef0a8fa540fec8cee1db4f09425f3597231d475d49e7c6ad5d4cd905f3a079263c42eebffe85fddf3a20db2ebd7c32077334718b6f7eed8173ff26707ff003eb771a9f7ced34ecd314ed22293968df5ef649d5825300c54d7b10946420acd87d0d4dea76fff9706cd41c2710e82185cc5be9d54d43f92e1faa8e93dc2ecebcea7ccbb156d23cba791b160d6e6f83601533c312cf3bbd40e72c427359f70127999559e466a59077d7c1c538a885c05b58ebc7f56c5f16ac3ae3eb019cee994369165e3f532c8ba2e7be473b32fbdd4f4c4b095a93dfeabbb1ce7b3c276534b9bc7188ab860b48420cac4e81cb50b4fe47d8dc932c5d10967a96b444d04a07754fe966675ef79aec177ff27b57b33565a23752fd043ecabe4f32a1fe33c32fa55692f2a42ca4ec340df1fdaa1c7b80eeed919457d3da1f735ef6ecaf501019611482a88330415e07774b3069491d4638f84b93ec1bdf0cf33a875b8610706eb18e34bf16b5e572f3f825658009d6b79a2c65150ceeac364c018dc4dc3b3feed252d29c68d18df0a1e23b54b0a524591959a9dfdc27e7514589b36f2a1ae7aeabf3417c92029163b2e40e42fd9a596f5039b9eaacbf5f2adec4f55a2c8faaf3037fdf494666e4497bd2c2dbd92e857f7f7cb4945d23a3890a869bcda0dea811ef8db0ac28577543565a37b0581409c4877402f348589ccb09cf2e6e34b6c03516664a71fd964ae9c55bffe321652fc5df06a42922bc79bcf93d64350def60753121c80043020bc9f51cf6fb7002ce08e11010c94dffb3591cedbbe3fed7cbeded8f33d020de4a4f451fc3d27ef1d46bcb85b6c5bd05695f8f1596b3620216beea3ee321e646e85fb4ec26764d32161fa4ae0cebabdd03b95b1e277c06c1b83e07d774a6eef7eb0eba3abc290f9798bbba61efd2ac286535b720932cc1c9f00d27d4bed426cd0672b2d62f096db5374264fbaec104d4121c4230f8a97c82d0681f7aa2c0d89d58ecbee6abe66339071655b59557a00e3b3eab1c1e306ffc75c3bc67f68f88ef3b1fed3378135b1765b1d7d333b195ce46c460f4494ad7e5dd0f3b7a06f0ca72bbb6d32899467c3485b7d1b881e3476b4f218a20c913133342a3f306d9216f10274e644672e71f49e385913bc081c0fdd02fcc253ec8748593068f6fb2c16a81febb2f9813165ef7df5934e682377dd352eb76f9e6b4da39d89de8d4a23994a912c99c212f98c730fb3e8e2d3e619adb629f2b9e43c60ef01db0fbc8b21b32dc80a3ffd654368c9ae2c5635fd344334083860c5e073157422e32c0a17ea71a66ccba6b6b6a345608413a2a063fe4371f12269253b93c3c283772b1a9dad041b1afc937987ed1c783940d41ead63d34907fb99e0d174bad0b4d7797c95d98a0337df534d7fad7b5948b95efc26d8b8f84dcf4de4d8b14d78b912f5749ad2c8c372d3d52f9ba282abd304d11763bf49215f20a84d0baa692d7f8f318a0534b0778d9751c18c1bb28827f349f54a85293b1ebc3affdbdb023ea32a63088a2f6b8341927974a259c319621b09428be15e81f9dd9bee480278180cbe29fd298aaaf21a1392a15847b56cb3c727504871c237d7fc69e8228e6646710b0fc4527c193bf1f0b4a81586eda6e995458cabe4a4769bd24b83cf1579e605f03c3c60434dee447c1d280079fc51c059b692d4ac1540a9c470e5f226c0e9092b7b35dc5a25ee30c377970131bb53b15d226bfb626a3f60504ca8b4dc2fa3366ae2274fea2e69d3e20d5c62358ab6d2ec05852463dbf794aca782942d69adf13fd44ff6d2d6ee718642ca949d865c9f73f81202166ad48cc1338f4638132d6abaf1fbe61a04ef0fa26b008898ac9825e9bee0c42b8a246f5403b86730c7e6fb90686bd92776404f755466d1066be186618bc41b7242a7178131e8f59e664be0a95b71994d06c5f7cfbe9af5ea6645fbc3a80f8db1fdd8e8189c47e3163365944c2be0e9e3dc05be37f8c6e8d1de0ca4c623a2a667559561fc123becd92d7921cbdd82c3a4c7ff5d021e21e0d34865feb289a1c21faf278905a042d3a4130d1f82a56e4d53007ba2db3b837250fef57cf5c35d9f5e262a190fba8824fc20ebddd0a9ca095c6b9245ffaf31253fb39b1dd7e6f1020ac917f1884236bcccbd25af7d5fa747fd3ee02324d8722cf18ad7984672e9fecd493db2b764ebae1fe3446403b27173da25e75d9a667a14b2bb871d58ad725c892e10a95a0a8c5f33556afa01bf8685791fcb5258b416b3856c02b0117df34c2e6984f1492de846c78751d92857c321383d33657ec38887890da3ccd349df6f3acffbad3d9a42fec8d02533a52672978420fa7e32dade5880ab5740d607d40fc20fa2a509f1157091319b0e1c2c54c5f83993f952f64c7b47332d533b15a19bab2904a5badff20f54a35424f595a7e2f98f69191789d060d78e70093fe459b8b61c34191c47e2f72e68bd7d0d557ac1de6d3b091a53e204bff3b28e6b7523226a012ef58da0f524dd3e437f3ae10661cae4aacc49e593a39fc89173b5bd6a3bf9e0bd62e4dbe004f7ddd452169356eefa991dc08587f250d02e162753716955d07845eee647e1c9dc2e6468902caedd73979c25ec04ea1ac4ef625ea1f620dad11f2899d542754d94762c32d4293ab3bb4c45658bc26348100629583d6f93121ea7b2f6ab4751e380ddb4a15035010a891d7680943889655acd96aad73ccc5b65fc2deb4a4edb7d610579c656012b296ede52ed31c5394ed11b6880beeb4999e543fb88ab15beef5c859efb5794a65e70c63e3224481deceeb45cfca561c422964c234331227f542aedcc74091582521ea28f4e91f6377bd4f2bd2aa13db5229a95dfdb4410d246f56ff9da91ecf589452e2e5a86878ff02ea08ed7fd5bb2c0026fc033015671d37b0ff1e484d3894eb77af813e2762486ff12370e57d07dc251ec48de74683e1968e6fb6737f41357d3eeb95843e633ef7513be61789bc002b254e2b13bf3000fa082c2efbce7884b7f35be4e88b4ced8a3b100889c25cae5cc849e891be5477cc1c710d82d7cde10a64325b1eb97ab44d9e6e38b637591ecbc28d1388d89f1dc48ca6d1dc48288d813f9b55107ba6c59afcf3de7a3af11ff54bf320344ceefc65c49757b6cef907cdab1fb65059e8e160516de6e6b3e426071e7b75ab147e1d3205f09031382c733f589f10c33c95c619c2f60e6678d72b493226ab83a3bfea440300ad3da71d73eeecd665cac2e50ab7027cbaaacf7d4f514773a0b2e5449aea9fc759ec9670212a2fbf23c12379ea5f28b63100fe9285a3802ef301c554776e3353c2b9eeaaa4e27f9fec01e81128c15d5d3b818a188a03e620eeb7f45c6ec963503be45ff47687446d4ea63dffc7e9833e0edd61af553b1e68bd894cd3646f21bcd01527d2b472162f59d347af14a9a84faffb0ed593f4ae446e13cda8f50ac1f80136c8ac6545f153aeb4f2abab4f5bc0d1feb2b03ec6125a518d8526f37a5150aa2810cb9a1c4234a0c5535ff59c7e6d78e0c180214aad04fbcc9c8de1926f3bf9fe8147a3cee5dd21fec1801a4eb4d941df9151c6acb1a81e0841297f4cd09fa8cb4aa449aba9b4deea6ecb9d6dadd13ad6738d349272e778e4170216c4e3ca6a68c38c0f101033c79fb83ebcaf6c9690367670b4aa30c72ba560b228bae3208d3f155903b1def3235654caa79be4def610d5fa37b7f94144ec7dbe68d6fb77099d4391b11c14aa7bf699a49c391c68be4c16280b6370efbb0226a7e2a70744c5f3ff87bed16d0b01936af2d4cf7f14823d8c22dec1fa559ed0b9327a2efd6ecd680443b653ad6a75abd762985c267df249ba0ef5937aca0d10ffba2d57c25ea2423ddef522ec3345c51e6298b921333c945ccc5960866f3a823ef70eb0bce6aadcfb923129f6652e9ca1dbd514ae465205ce69c2174d369b2f464d9352166f1ed7c77424bb25d39e457d9104abc9e2c0aeddeee3cb4944e897bb3b662071ae1ba871d08aefd7bbb51af694315d773e542d2edf1b7abce5a4006d094ce6df51777ba4502fed71bcac81ebc6491ee264241fd52eb4c231f3ae0b73fb71dd31ffb0f311e864e2b20fb8883040ba9313460bcf3a94ec25a67b0121a58c50ca8b18962e0eaf229659c1077bc065b87d322348f121accbb07f1e15c5d1540fd788af25ad0e784a8b2b1cb51ba4cb8b9a0e4f49fa4fa27000003146bb8891833fd01ca745077203527d0ea78dce6602963cc0bf3aa11b300c2a04e6cf43d702d256069c4c5ebf4a4733d232e230fbddd59f14d1520422ae44dfe64fccf365c279c71b64e455a83e0b8a926f8cf877cb79519bc6d68697734e26eaf1e992ee460f7d3a702a2250c7e50023cf8265f4dcb40f670ae75a2ca44686cae29ec3d487d210c6da2e45a48da4424267c450483cc8522c0a7bb3b74b52c3c3200b90ddf0d5f3349f6659785126555cf8cdc6010318399f41e51029bf9b1cabe5dd6dfadbe99720c8bc5235b18f7ea1c4cf20423ba12eacde82c1e88ad1cc47d052536538cd1d724325be235e9c94e26e4420a4a13f8fca7f5e2d50a20416be51c4f09d5181cc329e3540e78a5631faaaedc96175d7fe30d186507dc66bf752b88e6fb991f424e087029c6bb2a3dff6b0b2601167b38f0b64d06b27d8cbfa24e009befd925803aeded4940fdf61797cccd2e6ab54df4da51842029ae91012caa92ce756dceb60644881494c319564ef298227ce6d6bf777cd8378adefee8d310815e985753a539cbc12c010eef7752ec41f1005ebb588be727ee353075f27c1207efdb5f29b0f18fa1cff893a7fc26244f0d60fabaa11d56f5697806d3f09f8c017cdb70a16f19706d0de9ea012f9cbd8a4317d34b83fa1645e053aebc65b91901af399fda8457d052a1efee0321eae91c53802aad462edeb29e7ca066cab3cb115b873447cd70b9661d34f013e3ea61ce0ff7aed0cba8e03a878325d14f49c1323d753a69d3620fcaf23537368c9d68fd1ae617a74b1551b76749fc947ee68085f901dd48ab800bb312f56958955af66741051735c906de954629102be66d591b0e1eb1f9673269efe1651d7c66d48df764a6a660b02d47887a6a28029e0cfe88727e344209b2bc9726f648b3f88e8cd12baf31476c8b80f55c94a307505da208bee2e82e85a610a3660abed7f27f3f42acd50763efa3f1a1e66b972907daac373bd002d012a94c529c6bc5a97f50a199bb8752ae23a1c263b8888032f8bd7db5ce8840ea58c9c480cc6daa87b8120fc94ef15ee86ae</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不是哥们，你谁啊？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR科普-Eye Diagram（眼图）</title>
      <link href="/2024/10/30/DDR/DDR%E7%A7%91%E6%99%AE-Eye%20Diagram%EF%BC%88%E7%9C%BC%E5%9B%BE%EF%BC%89/"/>
      <url>/2024/10/30/DDR/DDR%E7%A7%91%E6%99%AE-Eye%20Diagram%EF%BC%88%E7%9C%BC%E5%9B%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>眼图（Eye Diagram）是用于分析数字信号完整性的一种图形工具。 <a><span id="more"></span></a></p></blockquote><h3 id="眼图的主要特点包括："><a href="#眼图的主要特点包括：" class="headerlink" title="眼图的主要特点包括："></a><a>眼图的主要特点包括：</a></h3><ol><li><strong>重叠显示</strong>：通过在同一图形中叠加多个信号周期，能够直观地看到信号在不同时间点的状态。这种重叠可以揭示信号的噪声、抖动和失真等问题。</li><li><strong>眼高和眼宽</strong>：眼图的“眼睛”部分的高度（眼高）代表信号的噪声裕度，越高意味着抗干扰能力越强。眼宽则与信号的时钟同步和抖动有关，越宽通常意味着更好的定时裕度。</li><li><strong>使用场景</strong>：眼图常用于评估传输线的设计、信号的放大和调节，以及整个系统的性能。设计工程师可以根据眼图调整电路，改善信号完整性。</li></ol><h3 id="DDR读写眼图的特点："><a href="#DDR读写眼图的特点：" class="headerlink" title="DDR读写眼图的特点："></a><a>DDR读写眼图的特点：</a></h3><h4 id="1-读眼图："><a href="#1-读眼图：" class="headerlink" title="1. 读眼图："></a>1. <strong>读眼图</strong>：</h4><ul><li><strong>读操作时的信号</strong>：在进行读操作时，数据总线上的信号状态会根据时钟的上升沿和下降沿变化。</li><li><strong>眼图的形成</strong>：多个读操作周期的数据波形叠加形成眼图。通过观察眼图，可以评估信号的眼高和眼宽，判断是否存在噪声、抖动和时序问题。</li><li><strong>重要参数</strong>：眼高反映了信号的噪声裕度，眼宽则表示定时裕度，二者都对系统的稳定性至关重要。</li></ul><h4 id="2-写眼图："><a href="#2-写眼图：" class="headerlink" title="2. 写眼图："></a>2. <strong>写眼图</strong>：</h4><ul><li><strong>写操作时的信号</strong>：在写操作中，数据总线也会随时钟的变化而改变。</li><li><strong>眼图的形成</strong>：类似于读眼图，通过叠加多个写操作周期的数据波形生成眼图。</li><li><strong>写操作的关注点</strong>：写眼图通常需要关注信号的上升和下降时间，以确保数据能够在正确的时钟边缘被接收。</li></ul><h3 id="眼图分析的意义："><a href="#眼图分析的意义：" class="headerlink" title="眼图分析的意义："></a><a>眼图分析的意义：</a></h3><ul><li><strong>信号完整性评估</strong>：通过分析眼图，设计工程师可以发现潜在的信号完整性问题，比如时序偏移、过多的抖动和噪声。</li><li><strong>优化设计</strong>：根据眼图的结果，工程师可以调整传输线的设计、增加终端匹配、改善信号的驱动能力等，以优化DDR接口的性能。</li></ul><p>总之，DDR读写眼图是验证和优化DDR信号传输性能的重要工具，有助于确保数据的准确传输和系统的稳定运行。</p><blockquote><p><strong>眼高和眼宽是眼图中两个重要的参数，用于评估信号的完整性。</strong></p></blockquote><h3 id="眼高-Eye-Height"><a href="#眼高-Eye-Height" class="headerlink" title="眼高 (Eye Height)"></a><a>眼高 (Eye Height)</a></h3><ul><li><strong>定义</strong>：眼高是眼图中“眼睛”打开部分的高度。它表示信号的电压范围，反映了信号的抗噪声能力。</li><li><strong>重要性</strong>：眼高越大，说明信号在逻辑高和逻辑低状态之间的差异越明显，这样可以更好地抵抗噪声的干扰。如果眼高较小，信号可能更容易受到噪声的影响，导致错误读取。</li></ul><h3 id="眼宽-Eye-Width"><a href="#眼宽-Eye-Width" class="headerlink" title="眼宽 (Eye Width)"></a><a>眼宽 (Eye Width)</a></h3><ul><li><strong>定义</strong>：眼宽是眼图中“眼睛”打开部分的宽度。它表示信号在有效传输期间的时间窗口，反映了信号的时序裕度。</li><li><strong>重要性</strong>：眼宽越大，表示信号在时钟周期内保持稳定的时间越长，这样可以确保数据在多个时钟边缘被正确采样。如果眼宽较小，意味着信号在有效传输时间内的变化范围有限，容易导致数据的时序错误。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h3><ul><li><p><strong>眼高</strong>：反映信号的抗干扰能力，眼高越大，抗噪声能力越强。</p><ul><li><strong>电压差异</strong>：眼高反映了逻辑高电平（通常对应于信号的高电压状态）和逻辑低电平（通常对应于信号的低电压状态）之间的电压差。当眼高较大时，逻辑高和逻辑低的电压差明显，使得接收器更容易区分这两种状态。</li><li><strong>噪声裕度</strong>：在信号传输过程中，电磁干扰、热噪声和其他因素可能会对信号造成影响。较大的眼高意味着在噪声干扰下，逻辑高和逻辑低的电压仍有足够的差距，可以减少错误判断的风险。也就是说，接收器能够在一定范围内的噪声干扰下，仍然正确识别信号的状态。</li><li><strong>容错能力</strong>：较大的眼高使得系统在面对信号波动时具备更好的容错能力。如果信号电平因噪声而发生轻微变化，但仍在逻辑高和逻辑低之间的电压差距内，接收器能够准确判断信号状态，而不会误判为错误的逻辑状态。</li></ul></li><li><p><strong>眼宽</strong>：反映信号的定时裕度，眼宽越大，数据传输的可靠性越高。</p></li></ul><blockquote><p><strong>通过观察眼高和眼宽，工程师可以评估和优化高速信号传输的设计，确保系统的稳定性和可靠性。</strong></p></blockquote><h3 id="示例：DDR3接口信号"><a href="#示例：DDR3接口信号" class="headerlink" title="示例：DDR3接口信号"></a><a>示例：DDR3接口信号</a></h3><blockquote><p>假设在一个DDR3接口中，逻辑高电平的电压（Vih）为 1.5V，逻辑低电平的电压（Vil）为 0V。这意味着：</p></blockquote><ul><li><strong>逻辑高电平（Vih）</strong>: 1.5V</li><li><strong>逻辑低电平（Vil）</strong>: 0V</li><li><strong>眼高</strong>: 1.5V - 0V &#x3D; 1.5V</li></ul><h3 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h3><h4 id="1-大眼高："><a href="#1-大眼高：" class="headerlink" title="1. 大眼高："></a>1. <strong>大眼高</strong>：</h4><ul><li>如果眼高为1.5V，信号的逻辑高和逻辑低电平有足够的电压差异。在这种情况下，即使信号受到噪声的干扰（例如，0.1V的干扰），逻辑高电平的实际电压可能在1.4V到1.6V之间（1.5V ± 0.1V），而逻辑低电平仍然保持在0V。由于逻辑高和逻辑低之间的电压差异仍然很大，接收器能够轻松区分这两种状态，从而保持信号的准确性。</li></ul><h4 id="2-小眼高："><a href="#2-小眼高：" class="headerlink" title="2. 小眼高："></a>2. <strong>小眼高</strong>：</h4><ul><li>如果眼高较小，比如只有0.3V（逻辑高为0.15V，逻辑低为-0.15V），噪声干扰可能会将逻辑高电平的电压降低到0.1V（0.15V - 0.1V），而逻辑低电平的电压可能保持在-0.15V。这时，接收器在识别信号时可能会出现混淆，因为0.1V可能被误判为逻辑低电平，从而导致错误的信号解码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Write Bit De-skew Algorithm</title>
      <link href="/2024/10/30/DDR/Write-Bit-De-skew-Algorithm/"/>
      <url>/2024/10/30/DDR/Write-Bit-De-skew-Algorithm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写入比特去偏移（Write Bit De-skew）算法的工作原理和步骤。<a><span id="more"></span></a></p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a><a>目标</a></h3><ul><li>确保在写入路径中的每个数据位都能够正确对齐，特别是在0到1的转换时，确保数据传输的可靠性和准确性。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a><a>算法步骤</a></h3><h4 id="1-初始写入操作"><a href="#1-初始写入操作" class="headerlink" title="1. 初始写入操作"></a>1. <strong>初始写入操作</strong></h4><ul><li>算法首先执行一系列写入操作，以确保数据正确写入指定的地址，包括DTAR0（x0000）、DTAR1（x0008）和DTAR2（x0010）。这些地址是用于后续的数据对齐和错误检测的基础。</li></ul><h4 id="2-执行顺序"><a href="#2-执行顺序" class="headerlink" title="2. 执行顺序"></a>2. <strong>执行顺序</strong></h4><ul><li>写入比特去偏移必须在写入均衡（write leveling）和写入均衡调整（write leveling adjustment，若适用）之后进行。通常建议在执行读取比特去偏移（read bit deskew）或读取比特去偏移和读取眼中心化（read eye centering）之后执行写入比特去偏移。这并不是强制要求，尤其是在已知读取操作正常的情况下。</li></ul><h4 id="3-检测数据眼的左边缘"><a href="#3-检测数据眼的左边缘" class="headerlink" title="3. 检测数据眼的左边缘"></a>3. <strong>检测数据眼的左边缘</strong></h4><ul><li>算法首先尝试检测数据眼（data eye）的左边缘，即至少有一个写入数据位发生故障的位置。数据眼是描述数据传输中有效信号的时序窗口。DQS和DQS#信号在这一位置的最新的0到1的转换会被检测到。</li></ul><h4 id="4-逐位右移检测"><a href="#4-逐位右移检测" class="headerlink" title="4. 逐位右移检测"></a>4. <strong>逐位右移检测</strong></h4><ul><li>每个数据位将被逐个右移，直到检测到相应位的读取故障。比较失败的次数由寄存器“DTCR.DTRPT”定义。当达到这一失败次数时，表明该数据位的时序可能需要调整。</li></ul><h4 id="5-数据掩码对齐"><a href="#5-数据掩码对齐" class="headerlink" title="5. 数据掩码对齐"></a>5. <strong>数据掩码对齐</strong></h4><ul><li>在完成每个写入数据位的去偏移之后，算法可以选择定位数据掩码（data mask）相对于数据位的位置，并随后进行掩码的去偏移。这有助于确保掩码信号与数据信号的同步。</li></ul><h4 id="6-定位数据眼的右边缘"><a href="#6-定位数据眼的右边缘" class="headerlink" title="6. 定位数据眼的右边缘"></a>6. <strong>定位数据眼的右边缘</strong></h4><ul><li>在去偏移掩码之后，算法还可以选择进一步定位数据眼的右边缘。当右边缘被检测到后，算法会计算数据眼的中心位置，并将DQS&#x2F;DQS#信号定位在数据眼的中心。这是为了确保数据的稳定性和正确性，使得信号在其最佳时机内被读取。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h3><blockquote><p>总的来说，这段文字描述了写入比特去偏移算法的目的和步骤，通过精确的时序调整和检测，确保数据在DDR内存中的写入操作是可靠的。通过对数据位和掩码的同步管理，算法能够优化数据传输的完整性，减少错误发生的可能性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture - DDL Calibration Search Algorithm</title>
      <link href="/2024/10/28/DDR/PUB%20Architecture-DDL%20Calibration%20Search%20Algorithm/"/>
      <url>/2024/10/28/DDR/PUB%20Architecture-DDL%20Calibration%20Search%20Algorithm/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>pub手册4.3.3， 介绍了本地校准延迟线（LCDL）校准的搜索算法，包括如何根据DDR时钟周期进行校准。</p></blockquote><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><h4 id="1-LCDL校准："><a href="#1-LCDL校准：" class="headerlink" title="1. LCDL校准："></a>1. <strong>LCDL校准</strong>：</h4><ul><li>每个LCDL需要为SDRAM时钟周期进行校准。这是通过测量所需的延迟线步数来实现，以产生与DDR时钟周期相等的延迟。</li><li>每个LCDL都是独立校准的，校准过程中信号会通过延迟单元以测量SDRAM时钟周期。</li></ul><h4 id="2-校准算法："><a href="#2-校准算法：" class="headerlink" title="2. 校准算法："></a>2. <strong>校准算法</strong>：</h4><ul><li>DDL校准算法使用<strong>二进制搜索</strong>或<strong>线性搜索</strong>来找到与时钟周期匹配的延迟值。</li><li>通过<code>PGCR8.DCALTYPE</code>寄存器选择搜索类型，默认类型为二进制搜索。</li></ul><h4 id="3-起始值："><a href="#3-起始值：" class="headerlink" title="3. 起始值："></a>3. <strong>起始值</strong>：</h4><ul><li>两种搜索类型的起始值可以通过<code>PGCR8.DCALSVAL</code>寄存器选择。</li><li>对于未使用的延迟单元，由于高频率时不需要，可能会导致在重新校准时出现问题。<code>PGCR8.DCALSVAL</code>寄存器允许用户配置DDL校准搜索算法以缓解这个老化问题。</li><li>用户可以在高频率时设置一个较小的起始值，默认起始值为256。</li></ul><p>4. </p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> PUB </tag>
            
            <tag> DDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Byte DDL Control</title>
      <link href="/2024/10/28/DDR/Data%20Byte%20DDL%20Control/"/>
      <url>/2024/10/28/DDR/Data%20Byte%20DDL%20Control/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><p><img src="https://s2.loli.net/2024/10/28/NPYoG7idgV2nbcx.png" alt="image-20241028233711104"></p><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a><strong>主要概念</strong></h3><h4 id="1-LCDL的类型"><a href="#1-LCDL的类型" class="headerlink" title="1. LCDL的类型"></a>1. LCDL的类型</h4><ul><li>每个字节通道有6种类型的LCDL：<ul><li><strong>WL LCDL</strong>（写入均衡LCDL）：用于平衡写入信号。</li><li><strong>WDQ LCDL</strong>（写数据LCDL）：用于控制写入数据。</li><li><strong>GDQS LCDL</strong>（读DQS门LCDL）：用于读取DQS信号的门控。</li><li><strong>RDQS LCDL</strong>（读DQS LCDL）：用于读取DQS信号。</li><li><strong>RDQS# LCDL</strong>（读DQS# LCDL）：DQS的反向信号。</li><li><strong>GSQDS LCDL</strong>（读DQS门状态LCDL）：用于监测DQS门的状态。</li></ul></li><li>每种LCDL都有相应的控制逻辑，具体的控制逻辑在后文提到。</li></ul><h4 id="2-x4支持："><a href="#2-x4支持：" class="headerlink" title="2. x4支持："></a>2. <strong>x4支持</strong>：</h4><ul><li>对于x4模式，每个字节通道有两个LCDL控制逻辑实例，以独立控制两个半字节（nibble）。</li></ul><h4 id="3-MDL控制逻辑："><a href="#3-MDL控制逻辑：" class="headerlink" title="3. MDL控制逻辑："></a>3. <strong>MDL控制逻辑</strong>：</h4><ul><li>每个字节通道还包括一个MDL控制逻辑实例，用于控制主延迟线（MDL）。</li></ul><h4 id="4-BDL控制逻辑："><a href="#4-BDL控制逻辑：" class="headerlink" title="4. BDL控制逻辑："></a>4. <strong>BDL控制逻辑</strong>：</h4><ul><li>每个字节还包括多个BDL控制逻辑实例，用于独立控制每个字节通道的BDL。</li><li>写路径BDL<ul><li>包括8个写数据（WDQ）BDL、1个（或2个，适用于x4）写数据掩码（WDM）BDL、1个（或2个，适用于x4）写数据时钟（WDQS）BDL、1个（或2个，适用于x4）输出使能（OE）BDL。</li></ul></li><li>读路径BDL<ul><li>包括8个读数据（RDQ）BDL、1个（或2个，适用于x4）读数据掩码（RDM）BDL、1个（或2个，适用于x4）读数据时钟（RDQS）BDL、1个（或2个，适用于x4）读数据时钟#（RDQS#）BDL、1个（或2个，适用于x4）功耗下降接收器（PDR）BDL和1个（或2个，适用于x4）终端使能（TE）BDL。</li></ul></li></ul><h4 id="5-DDL控制的校准和VT补偿："><a href="#5-DDL控制的校准和VT补偿：" class="headerlink" title="5. DDL控制的校准和VT补偿："></a>5. <strong>DDL控制的校准和VT补偿</strong>：</h4><ul><li>字节通道的DDL控制具有将DDL校准和VT补偿串行进行的选项，而不是并行进行。</li><li>这种选项允许将DDL校准和VT补偿逻辑实例化一次，而不是在每个LCDL控制块中重复该逻辑。</li><li>但串行校准和VT补偿的缺点是操作时间会增加。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>这段文字的主要内容是介绍了每个字节通道中的LCDL和BDL的控制逻辑、如何进行独立控制以及在x4模式下的扩展。此外，它还提到DDL控制的校准和VT补偿可以选择串行或并行执行，这对于设计的复杂性和操作时间都有影响。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC DLL Control</title>
      <link href="/2024/10/28/DDR/AC%20DLL%20Control/"/>
      <url>/2024/10/28/DDR/AC%20DLL%20Control/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol><li><strong>LCDL（本地校准延迟线）</strong>：<ul><li>地址&#x2F;命令通道中只有一个LCDL（称为AC LCDL），其作用是为LPDDR3&#x2F;2地址提供90度的相位偏移。这个LCDL由通用的LCDL控制逻辑来管理。</li></ul></li><li><strong>MDL（主延迟线）控制逻辑</strong>：<ul><li>另外还包含了MDL控制逻辑，用于控制主延迟线（MDL），这部分的逻辑也将在后续章节详细描述。</li></ul></li><li><strong>BDL（可调延迟线）控制逻辑</strong>：<ul><li>地址&#x2F;命令通道中有多个BDL控制逻辑实例，分别独立控制所有地址&#x2F;命令通道的BDL。这部分的详细逻辑也会在后续章节中说明。</li></ul></li><li><strong>DDL校准逻辑</strong>：<ul><li>地址&#x2F;命令通道的DDL校准逻辑嵌套在LCDL控制逻辑中。如果设计编译时启用了CA VT补偿（即未定义<code>DWC_NO_CA_VT_COMP</code>宏），则会在DDL控制级别实例化VT补偿逻辑。</li></ul></li><li><strong>序列执行</strong>：<ul><li>DDL校准和VT补偿在地址&#x2F;命令通道中总是串行进行，因为这个通道只有一个LCDL。</li></ul></li></ol><h3 id="VT补偿"><a href="#VT补偿" class="headerlink" title="VT补偿"></a>VT补偿</h3><ul><li><strong>VT补偿</strong>是用于抵消由于温度变化、工艺变化等引起的电压阈值（VT）变化的逻辑。</li><li>默认情况下，地址&#x2F;命令通道的所有DDL寄存器都经过VT补偿。如果禁用这一特性，特别是在命令&#x2F;地址训练禁用的情况下，可以减少PUB（物理接口块）的面积。</li></ul><h3 id="宏定义的影响"><a href="#宏定义的影响" class="headerlink" title="宏定义的影响"></a>宏定义的影响</h3><ul><li><code>DWC_NO_CA_VT_COMP</code><ul><li>如果这个宏被设置，AC DDL寄存器将不进行VT补偿。此时，AC DDL寄存器的行为如下：<ul><li>AC BDL寄存器将返回其初始值（无论是复位、训练或写入的值），即使VT发生变化。</li><li>AC LCDL寄存器也将返回其初始值（无论是校准、训练或写入的值），与VT变化无关。</li><li><code>ACMDLR.IPRD</code>字段返回其初始的校准值，无论VT如何变化。</li><li><code>ACMDLR.TPRD</code>被编译掉，因此返回的值为0。</li></ul></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段文字的核心在于描述地址&#x2F;命令通道中延迟线的控制和校准机制，以及如何通过宏定义选择是否启用VT补偿。这对于确保信号的准确传输和提高系统的可靠性至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BDL和LCDL的使用</title>
      <link href="/2024/10/27/DDR/BDL%E5%92%8CLCDL%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/27/DDR/BDL%E5%92%8CLCDL%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p> phy手册中关于BDL和LCDL寄存器相关域的描述<a><span id="more"></span></a></p></blockquote><h3 id="BDL和LCDL字段的结构"><a href="#BDL和LCDL字段的结构" class="headerlink" title="BDL和LCDL字段的结构"></a>BDL和LCDL字段的结构</h3><p><a>1. <strong>BDL字段</strong>：</a></p><ul><li><p><strong>细粒度延迟字段（低4位）</strong>：通常用于调整微小的延迟，每个位代表一个细粒度的延迟步骤。</p></li><li><p><strong>粗粒度延迟字段（高2位）</strong>：用于调整较大的延迟，每个位代表一个较大的延迟步骤。</p></li><li><p><strong>示例</strong></p><ul><li><p><strong>寄存器值</strong>：假设我们将BDL的控制寄存器设置为 <code>0x2F</code>。其二进制表示为：<code>0x2F</code> &#x3D; <code>00101111</code>（二进制表示）</p></li><li><p><strong>位分解</strong>：</p><ul><li><p><strong>高两位</strong>：<code>10</code>（表示粗粒度延迟为<code>2</code>）</p></li><li><p><strong>低四位</strong>：<code>1111</code>（表示细粒度延迟为<code>15</code>）</p></li></ul></li><li><p><strong>各字段的意义</strong></p><ul><li><p><strong>粗粒度延迟</strong>：</p><ul><li><code>10</code>（粗粒度延迟为 <code>2</code>，表示大约有 <code>2</code> 个 CK 周期的延迟）。</li></ul></li><li><p><strong>细粒度延迟</strong>：</p><ul><li><code>1111</code>（细粒度延迟为 <code>15</code>，意味着延迟为 <code>15/16</code> 个 CK 周期）。</li></ul></li></ul></li><li><p><strong>总结</strong></p><ul><li><p>BDL控制寄存器设置为 <code>0x2F</code></p><ul><li><p>粗粒度延迟为 <code>2</code>，即增加大约 <code>2</code> 个 CK 周期的延迟。</p></li><li><p>细粒度延迟为 <code>15</code>，即几乎最大的小延迟。</p></li><li><p>总延迟 &#x3D; 粗粒度延迟 + 细粒度延迟</p><ul><li>粗粒度延迟：<code>0 CK周期</code></li><li>细粒度延迟：<code>1/16 CK周期</code></li></ul></li></ul></li></ul></li></ul></li></ul><p><a>2. <strong>LCDL字段</strong>：</a></p><ul><li><strong>细粒度延迟字段（低4位）</strong>：同样用于微小的延迟调整。</li><li><strong>粗粒度延迟字段（高5位）</strong>：用于设置较大的延迟，允许更多的调节范围。</li><li><strong>示例</strong><ul><li>示例同上，就是粗的延时字段更达了，可以延时更久的时间了。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLL Testing</title>
      <link href="/2024/10/27/DDR/DLL%20Testing/"/>
      <url>/2024/10/27/DDR/DLL%20Testing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>phy手册6.3， DDL Testing的个人解释。<a><span id="more"></span></a></p></blockquote><h3 id="DDL（可调延迟线）测试概述"><a href="#DDL（可调延迟线）测试概述" class="headerlink" title="DDL（可调延迟线）测试概述"></a><a>DDL（可调延迟线）测试概述</a></h3><blockquote><p> 在DDR4多PHY PHY模块中，嵌入了多种可调延迟线（DDL），其基本逻辑功能是缓冲器。测试这些DDL以确保其正常工作和产生正确的延迟值是非常重要的。以下是对DDL测试过程的详细解释。</p></blockquote><p><img src="https://s2.loli.net/2024/10/27/ke8wuvEixZGp5Mf.png" alt="image-20241027225357426"></p><h4 id="1-DDL的基本功能"><a href="#1-DDL的基本功能" class="headerlink" title="1. DDL的基本功能"></a>1. DDL的基本功能</h4><ul><li><strong>可调延迟线（DDL）</strong>：<ul><li>DDL是一种可调节的延迟线，允许在信号传输路径中引入特定的延迟，以补偿时序上的偏差。不同类型的DDL（如LCDL、BDL和NDL）被用于不同的应用场景。</li></ul></li><li><strong>内部逻辑扫描测试</strong>：<ul><li>内部逻辑扫描测试通过将信号从DDL的输入传递到输出，验证DDL能够正确传递逻辑0和1。但是，该测试无法验证每个DDL设置是否产生唯一的延迟值，或者这些延迟值是否组合成特定的延迟特性。</li></ul></li></ul><h4 id="2-DDL的类型与用途"><a href="#2-DDL的类型与用途" class="headerlink" title="2. DDL的类型与用途"></a>2. DDL的类型与用途</h4><ul><li><p><strong>LCDL（Local Calibrated Delay Line）</strong>：</p><ul><li><p><strong>用途</strong>：用于DQ&#x2F;DQS信号的偏移调整。</p></li><li><p><strong>特点</strong>：可调节的延迟线，允许在数据传输中引入可变的延迟，以便精确对齐数据和时钟信号。</p></li></ul></li><li><p><strong>BDL（Buffer Delay Line）</strong>：</p><ul><li><p><strong>用途</strong>：用于DATX8和DATX4X2块中的读写比特去偏移（deskew）。</p></li><li><p><strong>特点</strong>：相较于LCDL，BDL的最大延迟较短，主要用于较小的延迟调整。</p></li></ul></li><li><p><strong>NDL（Fixed Delay Line）</strong>：</p><ul><li><p><strong>用途</strong>：用于匹配LCDL的零延迟。</p></li><li><p><strong>特点</strong>：具有固定的延迟值，不可调节，主要用于为LCDL提供基准延迟。</p></li></ul></li><li><p><strong>总结</strong>：</p><ul><li><p><strong>可调性</strong>：LCDL和BDL是可调的，而NDL是固定的。</p></li><li><p><strong>延迟范围</strong>：LCDL提供较大的延迟调节范围，BDL则提供相对较短的延迟。</p></li><li><p><strong>应用场景</strong>：LCDL主要用于数据对齐，BDL用于读写比特的去偏移，NDL用于提供固定延迟。</p></li><li><p><strong>LCDL与BDL</strong>：</p><ul><li>LCDL（本地校准延迟线）用于DQ&#x2F;DQS偏移，而BDL（短延迟线）用于DATX8和DATX4X2块中的读写比特去偏移。NDL（固定延迟线）用于匹配LCDL的零延迟。</li></ul></li><li><p><strong>可观察性</strong>：</p><ul><li>某些DDL（例如DATX8和DATX4X2中的写比特去偏移DDL）是可观察的，可以通过发送特定的数据模式并直接编程DDL延迟值来检测输出延迟的变化。然而，不是所有DDL都会影响设备的主要输出，某些DDL只影响内部节点。</li></ul></li></ul></li></ul><h4 id="3-DDL的测试挑战"><a href="#3-DDL的测试挑战" class="headerlink" title="3. DDL的测试挑战"></a>3. DDL的测试挑战</h4><ul><li><strong>测量限制</strong>：<ul><li>DDL的最小延迟步长非常小，超出了大多数自动测试设备（ATE）的测量能力。这意味着只能在较大的步长上进行特性测试，这不是理想的解决方案。</li></ul></li><li><strong>直接访问</strong>：<ul><li>通过直接访问DDL的延迟值寄存器，尽管可以进行一些初步测试，但这并不能完全解决所有DDL的测试需求。</li></ul></li></ul><h4 id="4-DDL环振荡器测试模式"><a href="#4-DDL环振荡器测试模式" class="headerlink" title="4. DDL环振荡器测试模式"></a>4. DDL环振荡器测试模式</h4><blockquote><p> 为了更全面地测试DDL，所有PHY块和PUB中都集成了DDL环振荡器测试模式。</p></blockquote><ul><li><strong>环振荡器的构建</strong>：<ul><li>在环振荡器测试模式中，NDL、BDL和LCDL被连接在一起，形成一个单一的环形振荡器。这是通过将一个延迟线的数字测试输出（DTO）连接到另一个延迟线的数字测试输入（DTI）来实现的。</li></ul></li><li><strong>振荡器输出与分频</strong>：<ul><li>环振荡器的输出通过一个可编程的分频器进行分频，产生的输出信号作为延迟线测试输出。每个DATX8、PHYDATX4X2、PHYAC和PHYACX48模块都有自己的环，允许并行测试整个接口。</li></ul></li><li><strong>自动测量功能</strong>：<ul><li>PUB中有额外的逻辑，可以自动测量延迟线测试输出的周期。测量的周期可以从寄存器中读取，并以相对于PUB控制器时钟（ctl_clk）周期的代码表示。</li></ul></li></ul><h4 id="5-测试过程示例"><a href="#5-测试过程示例" class="headerlink" title="5. 测试过程示例"></a>5. 测试过程示例</h4><blockquote><p>假设我们希望测试一个LCDL的性能：</p></blockquote><ol><li><strong>初始化：</strong><ul><li>确保PLL锁定并触发延迟线校准。</li></ul></li><li><strong>进入环振荡器模式：</strong><ul><li>启用DDL环振荡器测试模式，将所有相关DDL连接成一个环。</li></ul></li><li><strong>编程延迟线：</strong><ul><li>通过设置DDL的延迟值，调整环中每个DDL的延迟。</li></ul></li><li><strong>观察输出：</strong><ul><li>通过环的输出观察振荡信号的频率变化，记录输出的周期。</li></ul></li><li><strong>分析结果：</strong><ul><li>通过对比输出周期与期望值，评估每个DDL的延迟性能，确保它们在预期范围内工作。</li></ul></li></ol><blockquote><p> 通过这种方法，工程师可以获得DDL的线性度和范围，确保整个DDR4接口的可靠性和性能。</p></blockquote><h3 id="DDL的组成"><a href="#DDL的组成" class="headerlink" title="DDL的组成"></a><a>DDL的组成</a></h3><p><strong>粗延迟元素（Coarse Delay Elements）：</strong></p><ul><li>这些元素提供较大的延迟步长。它们的数量因不同类型的DDL而异：<ul><li><strong>BDL</strong>（Buffer Delay Line）：包含4个粗延迟元素。<ul><li>下四位（[3:0]）对应于细粒度延迟位。</li><li>上两位（[5:4]）对应于粗粒度延迟位。</li></ul></li><li><strong>LCDL</strong>（Local Calibrated Delay Line）：包含32个粗延迟元素。<ul><li>下四位（[3:0]）同样对应于细粒度延迟位。</li><li>上五位（[8:4]）对应于粗粒度延迟位。</li></ul></li></ul></li></ul><p><strong>细延迟元素（Fine Delay Element）：</strong></p><ul><li>这是一个可调的细微延迟元素，可以提供更精确的延迟调整。在BDL和LCDL中，细延迟元素的数量是相同的：<ul><li><strong>都包含16个细微步长</strong>。</li></ul></li></ul><h3 id="如何设置DDL延迟"><a href="#如何设置DDL延迟" class="headerlink" title="如何设置DDL延迟"></a><a>如何设置DDL延迟</a></h3><ul><li>在设置某个DDL延迟时，可以通过选择一定数量的粗延迟元素和细延迟元素的组合来实现。</li><li>例如，如果需要某个特定的延迟：<ul><li>可以选择2个粗延迟元素（BDL）或4个粗延迟元素（LCDL），然后可能再加上1到16个细微延迟步长。</li></ul></li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><a>举个例子</a></h3><blockquote><p>假设你需要设置一个特定的延迟为200个时钟周期（tCK）：</p></blockquote><ul><li><strong>在BDL中</strong>：<ul><li>选择2个粗延迟元素（每个元素提供50个时钟周期的延迟），总共提供100个时钟周期的延迟。</li><li>然后可以使用细延迟元素，选择6个细微步长（每个细微步长提供约16.67个时钟周期的延迟），总共提供100个时钟周期的延迟。</li><li>最终组合为100 + 100 &#x3D; 200个时钟周期。</li></ul></li><li><strong>在LCDL中</strong>：<ul><li>选择3个粗延迟元素（每个元素提供50个时钟周期的延迟），总共提供150个时钟周期的延迟。</li><li>再使用3个细微步长（每个细微步长提供约16.67个时钟周期的延迟），总共提供50个时钟周期的延迟。</li><li>最终组合为150 + 50 &#x3D; 200个时钟周期。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h3><blockquote><p>这种设计允许在较大范围内快速设置和微调延迟，使得在不同的操作条件下能够实现精确的时序控制。不同类型的DDL通过不同数量的粗细延迟元素组合来提供所需的延迟特性。</p></blockquote><h3 id="可调延迟线（DDL）测试的两种观察方法"><a href="#可调延迟线（DDL）测试的两种观察方法" class="headerlink" title="可调延迟线（DDL）测试的两种观察方法"></a><a>可调延迟线（DDL）测试的两种观察方法</a></h3><blockquote><p> 主要是通过环形振荡器的输出信号来进行测试。这两种方法在测试的有效性和效率上有所不同。</p></blockquote><h3 id="1-环形振荡器输出"><a href="#1-环形振荡器输出" class="headerlink" title="1. 环形振荡器输出"></a>1. 环形振荡器输出</h3><ul><li><strong>环形振荡器</strong>是通过连接多个延迟线构成的一个电路，能产生稳定的时钟信号。</li><li>这个时钟信号会在经过可编程分频器后送入PUB（物理单元控制器）。</li></ul><h3 id="2-测试观察方法"><a href="#2-测试观察方法" class="headerlink" title="2. 测试观察方法"></a>2. 测试观察方法</h3><h4 id="方法一：自动计算频率"><a href="#方法一：自动计算频率" class="headerlink" title="方法一：自动计算频率"></a>方法一：自动计算频率</h4><ul><li>PUB可以计算出环形振荡器输出的时钟频率，并通过取样功能得出这个频率值。</li><li>由于控制器时钟（ctl_clk）可能在较慢的速度下运行，能够通过设置适当的时钟分频比来保证测试的准确性和减少测试时间。</li><li><strong>优点</strong>：这种方法允许所有PHY块（包括AC&#x2F;ACX48和每个DATX8&#x2F;DATX4X2）并行测试，提高了测试效率。</li></ul><h4 id="方法二：数字测试输出"><a href="#方法二：数字测试输出" class="headerlink" title="方法二：数字测试输出"></a>方法二：数字测试输出</h4><ul><li>将分频后的时钟信号直接输出到数字测试输出（dto[0]），使用户能够直接观察时钟波形。</li><li><strong>优点</strong>：这种方法在设备调试和特性测试时比较有用，因为用户可以直接看到波形。</li><li><strong>缺点</strong>：对于生产测试来说，这种方法不是最优的，因为只能一次查看一个PHY块，效率较低。</li></ul><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><blockquote><p>假设在生产测试过程中，设计团队需要测试多个PHY块的延迟线：</p></blockquote><ul><li><p>使用方法一</p><ul><li>将所有PHY块连接到PUB。PUB自动计算每个块的环形振荡器频率，并输出结果。这个过程是并行进行的，可以快速完成多个测试。</li></ul></li><li><p>使用方法二</p><ul><li>如果选择直接观察分频后的时钟信号，测试人员需要逐个连接每个PHY块，并观察其时钟波形。这意味着在测试过程中，必须一一检查，耗时较长。</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>这段描述强调了测试DDL的两种方法的优缺点。在生产测试中，自动计算频率的方法能够提高效率，而直接观察时钟波形则适合调试和特性测试场景。选择合适的方法可以有效地优化测试过程。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture-Delay Line Calibration and Control</title>
      <link href="/2024/10/27/DDR/PUB%20Architecture-Delay%20Line%20Calibration%20and%20Control/"/>
      <url>/2024/10/27/DDR/PUB%20Architecture-Delay%20Line%20Calibration%20and%20Control/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pub手册4.2.2，LCDL主要用于测量时钟周期，并通过调整延迟设置使时钟信号的延迟与实际时钟周期匹配<a><span id="more"></span></a></p></blockquote><blockquote><p>延迟线（Delay Line）用于引入一个可调的延迟，用来对信号的时序进行精确控制。在 DDR 控制器中，延迟线的精确性非常关键，因为它直接影响信号的同步性，尤其是在处理高速时钟信号时。</p></blockquote><h3 id="1-延迟线（Delay-Line）校准概述"><a href="#1-延迟线（Delay-Line）校准概述" class="headerlink" title="1. 延迟线（Delay Line）校准概述"></a><a>1. <strong>延迟线（Delay Line）校准概述</strong></a></h3><ol><li><strong>延迟线校准触发</strong><ul><li>在 <strong>PLL 锁定</strong> 后，延迟线的校准可以通过 <strong>PIR 寄存器</strong> 来触发。</li><li>该校准是确保时钟信号与 DDR 时钟同步的关键步骤，必须在高频初始化任务之前完成。</li></ul></li><li><strong>延迟线校准的绕过</strong><ul><li><strong>绕过校准</strong>：通过 <strong>PIR 寄存器</strong> 中的 <strong>DCALPSE 位</strong>，可以跳过延迟线校准。</li><li><strong>注意</strong>：绕过后需要确保在后续的操作中手动触发校准，否则内存访问等操作可能会失败。</li></ul></li><li><strong>延迟线独立校准（<code>重点</code>）</strong><ul><li>每个 <strong>LCDL（Local Calibrated Delay Line）</strong> 都是一个独立的延迟单元，负责调整某个信号路径中的延迟。由于每个 LCDL 可能应用于不同的功能（例如，数据路径、命令路径等），它们的电路特性、负载和工作环境可能会有所不同。因此，每个 LCDL 都需要<strong>独立进行校准</strong>，以确保它们各自的延迟精度。</li><li>校准的过程中，会通过测量每个 LCDL 中的延迟步骤数量，来确保它的输出延迟与目标时钟（DDR 时钟）的周期完全一致。**”延迟步骤”** 指的是延迟线内部的可调延迟单位（<code>cell</code>），通常是时钟周期的一个子集。通过校准，我们可以确定<strong>需要多少个延迟步骤</strong>，才能使得该延迟线的延迟时间与 DDR 时钟的周期相匹配。<ul><li>例如，如果 DDR 时钟的周期是 1ns，延迟线可能有多个可调节的延迟步骤（如每个步骤为 0.1ns），校准后可以知道需要 10 步来获得 1ns 的延迟。</li></ul></li></ul></li><li><strong>延迟线校准时机</strong><ul><li>通常在 <strong>PHY 初始化</strong> 阶段进行，作为整个系统初始化的一部分，确保时钟信号同步。</li><li>用户也可以通过 <strong>PIR 寄存器的 DCAL 位</strong>，随时手动触发延迟线的校准。</li></ul></li><li><strong>延迟线校准的重要性</strong><ul><li>延迟线校准确保系统在电压、温度变化时，延迟线仍然能保持稳定的时延，避免时序错误。</li></ul></li><li><strong>校准控制</strong><ul><li>延迟线的校准操作可以被 <strong>用户</strong> 控制，通过设置 <strong>PIR 寄存器</strong> 的相关位（如 <strong>DCAL</strong>）触发或绕过校准。</li><li>在校准过程中，<strong>MDL（主延迟线）</strong> 会定期进行周期测量，并通过公式计算出补偿后的延迟值。</li></ul></li></ol><h3 id="2-LCDL校准的基本结构与原理"><a href="#2-LCDL校准的基本结构与原理" class="headerlink" title="2. LCDL校准的基本结构与原理"></a><a>2. <strong>LCDL校准的基本结构与原理</strong></a></h3><ul><li><strong>LCDL校准链路图</strong>：描述了LCDL与PHY内部的其他模块之间的连接，主要涉及到在LCDL与LCDL状态机之间进行周期测量。该过程由更高层的校准逻辑触发，通常是一个状态机，执行LCDL的周期测量。</li></ul><p><img src="https://s2.loli.net/2024/11/17/DSV21OZYKk4isuJ.png" alt="image-20241117150811502"></p><ul><li><strong>校准流</strong>：LCDL校准状态机（FSM，Finite State Machine）会启动LCDL的测量，并采样每个延迟设置下的测量结果，直到延迟值与时钟周期匹配。</li></ul><h3 id="3-校准过程详细步骤"><a href="#3-校准过程详细步骤" class="headerlink" title="3. 校准过程详细步骤"></a><a>3. <strong>校准过程详细步骤</strong></a></h3><p><img src="https://s2.loli.net/2024/11/17/6x4UNAPwG1Qj7O8.png" alt="image-20241027223625640"></p><p><strong>步骤1：复位与初始设置</strong></p><ul><li>在配置复位期间（例如，当<code>cfg_rst_n</code>信号被置为有效时），LCDL状态机会处于空闲状态，直到复位解除。</li><li>复位解除后，状态机继续保持在空闲状态，直到从主校准状态机收到校准触发信号。此时，LCDL状态机会开始执行校准操作。</li><li>在空闲状态，延迟选择的初始值设置为LCDL最大值的一半。LCDL状态机采用二分查找算法来确定最合适的延迟设置。</li></ul><p><strong>步骤2：时钟复位</strong></p><ul><li>在开始进行周期测量之前，先启用校准时钟到LCDL，但不启用实际的测量过程。这一步是为了重置LCDL内部的测量触发器（flip-flops）。</li><li>校准时钟会在一定的时间内启用，这个时间由<code>PTR2.tCALON</code>定义，校准时钟启用一段时间后会被关闭。然后进入等待状态，等待一定的时间<code>PTR2.tCALH</code>，之后才能进入下一步。</li></ul><p><strong>步骤3：启用测量逻辑</strong></p><ul><li>在时钟复位后，启用校准测量逻辑。通过使能<code>cal_en</code>信号来启动测量过程。<code>PTR2.tCALS</code>定义了启用信号的设定时间，确保信号能够稳定后再开始时钟启用。</li></ul><p><strong>步骤4：等待测量完成</strong></p><ul><li>状态机（FSM）会监视<code>cal_en_out</code>信号，直到它被置为有效。这个信号的上升沿意味着校准时钟已经通过LCDL的延迟单元，并注册了校准启用信号<code>cal_en</code>，从而表明测量操作已经完成。</li><li><code>cal_en_out</code>信号会在使用前与PHY控制域时钟同步。</li></ul><p><strong>步骤5：评估测量结果</strong></p><ul><li>测量完成后，状态机会根据测量结果判断延迟是否需要增加或减少。如果测量结果为1，则说明延迟超过了一个时钟周期，需要减少延迟。如果测量结果为0，则说明延迟小于一个时钟周期，需要增加延迟。</li></ul><p><strong>步骤6：继续二分查找或线性搜索</strong></p><ul><li><strong>二分查找</strong>：当延迟选择值的变化达到最大值（即已加或减去1的延迟值）时，搜索完成。</li><li><strong>线性搜索</strong>：当检测到<code>cal_out</code>信号的上升沿，或者已测试过最小或最大延迟选择值时，搜索完成。</li><li>如果搜索没有完成，状态机会返回步骤2，重新调整延迟值并再次进行测量，直到找到合适的延迟设置。</li></ul><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://s2.loli.net/2024/10/27/p6yrVPGxXdoBQWq.png" alt="image-20241027223726826"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> PUB </tag>
            
            <tag> DDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PUB Architecture-DDR BIST</title>
      <link href="/2024/10/27/DDR/PUB%20Architecture-DDR%20BIST/"/>
      <url>/2024/10/27/DDR/PUB%20Architecture-DDR%20BIST/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pub手册4.6，<strong>BIST (Built-In Self-Test)</strong> 模块是一种可编程的自检引擎，它为应用程序提供了一种测试 DDR PHY 和 I&#x2F;O 的方法，主要用于高速生产测试。BIST 模块通过 <strong>回路回送</strong>（loopback）方式来验证 PHY 的发送路径和接收路径的功能。除此之外，还可以选择测试外部内存的功能。<a><span id="more"></span></a></p></blockquote><h2 id="BIST-模块的功能"><a href="#BIST-模块的功能" class="headerlink" title="BIST 模块的功能"></a><a>BIST 模块的功能</a></h2><ol><li><strong>PHY 测试</strong>：<br>BIST 通过将数据从 PHY 的发送路径通过回路回送到接收路径，来测试 PHY 的发送和接收功能。通过此方式，不需要外部存储器即可完成测试。</li><li><strong>I&#x2F;O 测试</strong>：<br>BIST 还可以测试 I&#x2F;O 的功能，确保数据能够正确地通过 I&#x2F;O 接口传输。</li><li><strong>外部内存测试</strong>（可选）：<br>如果需要，BIST 还提供了测试外部内存的功能。此时，BIST 会发送常规的写读事务到外部 DRAM，并比较从 DRAM 读取的数据和写入的数据是否一致。</li></ol><h4 id="BIST-模块的工作原理"><a href="#BIST-模块的工作原理" class="headerlink" title="BIST 模块的工作原理"></a>BIST 模块的工作原理</h4><ul><li><strong>回路回送模式</strong>（Loopback Mode）：<br>在回路回送模式下，BIST 将数据从 PHY 的发送路径通过 I&#x2F;O 返回到接收路径。这样，数据就可以在 PHY 内部进行循环回送，进行自检。这种模式不需要外部内存，因此适用于不需要依赖外部存储器的测试场景。</li><li><strong>DRAM 模式</strong>（DRAM Mode）：<br>在 DRAM 模式下，BIST 会向 DRAM 发送正常的写读事务，并将读取的数据与预期数据进行比较。该模式适用于测试外部 DRAM 存储器。</li></ul><h4 id="BIST-模块的结构（Block-Diagram）"><a href="#BIST-模块的结构（Block-Diagram）" class="headerlink" title="BIST 模块的结构（Block Diagram）"></a><strong>BIST 模块的结构（Block Diagram）</strong></h4><ul><li><p>BIST 模块的框图（提供详细图示）展示了各个功能模块之间的连接方式。它通常包括以下几个主要组件：</p><ul><li><strong>传输路径（Transmit Path）</strong>：用于将数据从 PHY 的发送端发送出去。</li><li><strong>接收路径（Receive Path）</strong>：用于接收回送的数据并进行比较。</li><li><strong>外部内存接口</strong>：如果使用 DRAM 测试模式，则通过外部内存接口与 DRAM 进行通信。</li><li><strong>测试模式选择器</strong>：允许选择回路回送模式或 DRAM 模式。</li><li><strong>控制寄存器</strong>：通过这些寄存器，可以控制 BIST 模块的启停，配置回送模式、DRAM 模式、错误检测等。</li></ul></li></ul><p>通过该图示，用户可以理解如何在不同测试模式下配置 BIST 模块，并进行 PHY 和 I&#x2F;O 的功能验证。</p><p><img src="https://s2.loli.net/2024/10/27/YetQxkAZNB3UpMy.png" alt="image-20241027222629770"></p><h3 id="BIST（内建自测试）的操作模式"><a href="#BIST（内建自测试）的操作模式" class="headerlink" title="BIST（内建自测试）的操作模式"></a><a>BIST（内建自测试）的操作模式</a></h3><blockquote><p> BIST（Built-In Self-Test）是一种用于测试和验证集成电路功能的技术。根据所述信息，BIST有两种操作模式：环回模式（Loopback Mode）和DRAM模式（DRAM Mode）。以下是对这两种模式的详细解释。</p></blockquote><h4 id="1-环回模式（Loopback-Mode）"><a href="#1-环回模式（Loopback-Mode）" class="headerlink" title="1. 环回模式（Loopback Mode）"></a>1. <strong>环回模式（Loopback Mode）</strong></h4><p>环回模式是用来测试 PHY（物理层）和 I&#x2F;O 接口的。其原理是将写入的数据直接送回接收路径，这样就不需要外部存储器（例如 DRAM）来进行测试。具体来说：</p><ul><li><strong>DATXn 写路径和接收路径的环回：</strong> 在环回模式下，<strong>DATXn</strong>（数据线组）的写入数据将直接通过 I&#x2F;O 传输到接收路径上。也就是说，BIST 发送数据之后，数据直接回到发送端，而不经过外部存储器，这样可以用来验证 PHY 数据通道是否正常。</li><li><strong>AC 输出路径的环回：</strong> 另外，<strong>AC 输出路径</strong>也会在 I&#x2F;O 处被环回到专用的 AC 环回逻辑。AC 是指命令和地址通道（Address&#x2F;Command），它用于传输内存的读写地址和控制信号。这部分的环回确保地址和命令通道也能正确工作。</li></ul><p>这种模式的好处是无需连接外部 DRAM，测试过程可以在没有外部存储器的情况下进行，适合用于检查 PHY 层和 I&#x2F;O 接口的基本功能。</p><ul><li><strong>最小的 WL&#x2F;RL：</strong> 环回模式下支持的最小 WL（写延迟）和 RL（读延迟）为 6。WL&#x2F;RL 是内存操作的延时设置，通常与内存的时序参数有关。BIST 测试时，环回模式对延迟有最低要求。</li></ul><h4 id="2-DRAM模式（DRAM-Mode）"><a href="#2-DRAM模式（DRAM-Mode）" class="headerlink" title="2. DRAM模式（DRAM Mode）"></a>2. <strong>DRAM模式（DRAM Mode）</strong></h4><p>在 DRAM 模式下，BIST 会像正常的内存访问一样进行读写操作，写入数据到 DRAM 中，并从 DRAM 中读取数据来进行对比。这个模式实际上测试的是内存的数据完整性以及内存与 PHY 接口之间的配合。具体来说：</p><ul><li><strong>写读事务：</strong> 在 DRAM 模式下，BIST 会执行正常的<strong>写读事务</strong>（Write&#x2F;Read Transactions）。即，它将数据写入 DRAM 并从 DRAM 中读取数据来进行对比，确保内存和 PHY 层能够正常交互。</li><li><strong>地址和命令通道的环回：</strong> 即使是在 DRAM 模式下，<strong>地址&#x2F;命令通道</strong>（Address&#x2F;Command Channel）依然会在 I&#x2F;O 处进行环回。这意味着，BIST 不会向外部发送命令和地址信号，而是会将这些信号发送回自身，以确保地址&#x2F;命令通道的功能正确。</li><li><strong>外部存储器测试：</strong> 在 DRAM 模式下，可以将其用作测试外部内存（例如，外部的 DRAM 存储芯片），通过发送写读事务并进行数据比较，验证 DRAM 和 PHY 层的通信是否正确。</li></ul><h3 id="BIST-运行的触发与配置"><a href="#BIST-运行的触发与配置" class="headerlink" title="BIST 运行的触发与配置"></a><a>BIST 运行的触发与配置</a></h3><h4 id="1-触发-BIST-运行："><a href="#1-触发-BIST-运行：" class="headerlink" title="1. 触发 BIST 运行："></a>1. <strong>触发 BIST 运行</strong>：</h4><ul><li>通过写入 BIST 运行寄存器（<code>BISTRR</code>）并选择 RUN 操作来触发 BIST 运行。</li></ul><h4 id="2-运行配置选项"><a href="#2-运行配置选项" class="headerlink" title="2. 运行配置选项"></a>2. <strong>运行配置选项</strong></h4><ul><li>无限运行<ul><li>BIST 可以配置为无限期运行，直到接收到 STOP 命令为止。</li></ul></li><li>停止条件<ul><li>可以配置为在检测到失败时停止。</li><li>也可以设置为在发出一定数量的测试模式后自动停止。</li><li>或在达到预设的最大地址值时自动停止。</li></ul></li></ul><h4 id="3-BIST-模式选择"><a href="#3-BIST-模式选择" class="headerlink" title="3. BIST 模式选择"></a>3. <strong>BIST 模式选择</strong></h4><ul><li>可选择的测试模式包括：<ul><li>行走1（Walking 1s）</li><li>行走0（Walking 0s）</li><li>伪随机（Pseudo-random）</li><li>用户定义（User defined）</li></ul></li></ul><h3 id="数据字节BIST运行过程"><a href="#数据字节BIST运行过程" class="headerlink" title="数据字节BIST运行过程"></a><a>数据字节BIST运行过程</a></h3><h4 id="1-写入操作"><a href="#1-写入操作" class="headerlink" title="1. 写入操作"></a>1. <strong>写入操作</strong></h4><ul><li>数据字节BIST从<code>BISTARn</code>寄存器中设置的地址开始，执行一系列写入（WR）操作，直到发送的字数达到<code>BISTWCR.BWCNT</code>。</li></ul><h4 id="2-地址递增"><a href="#2-地址递增" class="headerlink" title="2. 地址递增"></a>2. <strong>地址递增</strong></h4><ul><li>地址根据<code>BISTAR1.BAINC</code>递增，同时自动处理<code>bank</code>的关闭或打开以及行激活。</li></ul><h4 id="3-回环模式"><a href="#3-回环模式" class="headerlink" title="3. 回环模式"></a>3. <strong>回环模式</strong></h4><ul><li>在回环模式下，一旦发送的字数等于<code>BWCNT</code>, BIST操作结束，回环数据与写入数据进行比较，记录任何失败。</li></ul><h4 id="4-DRAM-模式"><a href="#4-DRAM-模式" class="headerlink" title="4. DRAM 模式"></a>4. <strong>DRAM 模式</strong></h4><ul><li>BIST现在会执行一系列读取（RD）操作，从DRAM中读取之前写入的数据，并与写入的数据进行比较，记录任何失败。</li></ul><h3 id="无限模式"><a href="#无限模式" class="headerlink" title="无限模式"></a><a>无限模式</a></h3><ul><li>在无限模式下（<code>BISTRR.BINF== 0x1</code>），写入-读取序列将无限进行，直到满足某一停止条件：<ul><li>用户发出 BIST STOP（<code>BISTRR.BINST == STOP</code>）。</li><li>比较失败的次数达到预设限制（<code>BISTRR.NFAIL</code>），如果 <code>BISTRR.SONF == 0x1</code>。</li><li>在 RD 操作中，地址达到预设的最大值（<code>BISTRR.BSOMA == 0x1</code>），允许 BIST 通过完整的内存数组。</li></ul></li></ul><h3 id="错误状态与计数"><a href="#错误状态与计数" class="headerlink" title="错误状态与计数"></a><a>错误状态与计数</a></h3><h4 id="1-错误计数器："><a href="#1-错误计数器：" class="headerlink" title="1. 错误计数器："></a>1. <strong>错误计数器</strong>：</h4><ul><li><p>位错误计数器</p><ul><li>每个 DRAM 引脚有一个位错误计数器，例如，DATX8 上有9个计数器（8个数据位和1个数据掩码位），地址&#x2F;命令通道最多可有34个计数器。</li><li>位错误计数器设计较小，以限制设计尺寸，每个计数器为2位宽，因此可以记录每个引脚上的最多3个错误。</li></ul></li><li><p>字错误计数器</p><ul><li>计数整个字的错误，如果数据字节通道或地址&#x2F;命令通道的任何位发生错误，则相应的字错误计数器会增加。</li><li>字错误计数器为16位宽，可以计数最多64K个错误。</li></ul></li></ul><h4 id="2-数据掩码："><a href="#2-数据掩码：" class="headerlink" title="2. 数据掩码："></a>2. <strong>数据掩码</strong>：</h4><ul><li>提供数据掩码功能，以便在某个位上记录更多错误，通常在诊断阶段使用。</li></ul><h3 id="BIST状态与重置"><a href="#BIST状态与重置" class="headerlink" title="BIST状态与重置"></a><a>BIST状态与重置</a></h3><h4 id="1-完成状态："><a href="#1-完成状态：" class="headerlink" title="1. 完成状态："></a>1. <strong>完成状态</strong>：</h4><ul><li>一旦 BIST 模式执行完毕（停止或执行最后的测试模式），完成状态位（<code>BDONE</code>）将被设置在 BIST 状态通用寄存器（<code>BISTGSR</code>）中，这是测试模式执行结束的唯一有效指示。</li></ul><h4 id="2-轮询状态："><a href="#2-轮询状态：" class="headerlink" title="2. 轮询状态："></a>2. <strong>轮询状态</strong>：</h4><ul><li>用户必须轮询此位，确保它被设置后才能读取其他状态寄存器。</li></ul><h4 id="3-BIST-重置指令："><a href="#3-BIST-重置指令：" class="headerlink" title="3. BIST 重置指令："></a>3. <strong>BIST 重置指令</strong>：</h4><ul><li>提供 BIST 重置指令，通过<code>BISTRR</code>寄存器，重置某些 BIST 状态寄存器位为默认值。</li></ul><h4 id="4-系统重置："><a href="#4-系统重置：" class="headerlink" title="4. 系统重置："></a>4. <strong>系统重置</strong>：</h4><ul><li>注意，所有状态寄存器在系统重置时也会被重置为默认值。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a>总结</a></h3><blockquote><p>BIST的环回模式和DRAM模式提供了两种不同的测试方法：</p></blockquote><ul><li><strong>环回模式</strong>：用于在没有外部内存的情况下测试PHY的内部逻辑，通过环回来验证数据传输的完整性。</li><li><strong>DRAM模式</strong>：用于实际测试外部DRAM的读写操作，通过发送和接收数据来验证内存的功能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> PUB </tag>
            
            <tag> BIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Gate Training</title>
      <link href="/2024/10/27/DDR/Basic%20Gate%20Training/"/>
      <url>/2024/10/27/DDR/Basic%20Gate%20Training/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>基础门控训练(Basic Gate Training)是一种确保DDR内存系统能够在不同延迟条件下准确读取数据的机制。其目标是通过调节DQS门控信号的时序来找到一个最佳的位置，以避免由于时延不一致引起的数据错误。以下是该过程的详细步骤和说明。</p></blockquote><h3 id="训练过程的主要步骤"><a href="#训练过程的主要步骤" class="headerlink" title="训练过程的主要步骤"></a>训练过程的主要步骤</h3><p><a><strong>1. 初始设置：</strong></a></p><ul><li>从最小延迟设置开始，DQS门控的初始位置为左侧（延迟最少）。</li><li>训练分为两个阶段：首先确定左侧（最少延迟）的位置，然后确定右侧（最多延迟）的位置。</li></ul><p><a><strong>2. 确定左侧有效位置：</strong></a></p><ul><li>从左侧开始，以1&#x2F;8个DDR时钟周期的增量向右移动门控，直到读取事务成功。</li><li>记录下当前成功的右边界位置，以及上一个失败的左边界位置。</li><li>在这两个边界之间进行进一步搜索，使用二分搜索算法加速过程，找到左侧有效位置（门控关闭位置）。</li></ul><p><a><strong>3. 确定右侧有效位置：</strong></a></p><ul><li>一旦找到左侧有效位置，接下来从右侧（延迟更多的一端）开始，将门控位置向右移动1&#x2F;4个DDR时钟周期，避免由于抖动引起的读取不稳定区域。</li><li>接着，继续向右移动，以1&#x2F;8个DDR时钟周期的增量，直到读取事务失败。</li><li>记录当前的右边界位置，使用与之前相同的二分搜索算法来确定右侧有效位置（门控开启位置）。</li></ul><p><a><strong>4. 读取验证与稳定性检查：</strong></a></p><ul><li>为了避免错误的读取结果，门控位置会在多个读取中进行验证。如果在某个位置上有一次读取失败，则认为该位置不正确。</li><li>可以通过设置DTCR.DTRPTN控制每个门控位置评估的额外读取次数。</li><li>通过DTCR.DTCMPD控制是否在门控位置评估过程中比较读取数据与期望数据。</li></ul><p><a><strong>5. 时钟周期计算：</strong></a></p><ul><li>DDR时钟周期是从DQS门控时钟周期（DXnGSR0.GDQSPRD）得出的，延迟计算基于此周期值。</li></ul><p><a><strong>6. 重置训练：</strong></a></p><ul><li>当基础门控训练被触发时，所有当前的门控训练结果都会被丢弃，算法会从头开始训练。</li></ul><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><blockquote><p>假设有一个DDR内存系统，DQS门控的时钟周期tCK为1ns。整个训练过程可以描述如下：</p></blockquote><h4 id="初始设置："><a href="#初始设置：" class="headerlink" title="初始设置："></a>初始设置：</h4><blockquote><p>DQS门控初始位置设置为0ns。</p></blockquote><h5 id="寻找左侧有效位置："><a href="#寻找左侧有效位置：" class="headerlink" title="寻找左侧有效位置："></a>寻找左侧有效位置：</h5><ul><li>从0ns开始，以1&#x2F;8个DDR时钟周期（0.125ns）向右移动：<ul><li>位置0ns：成功读取（记录为当前右边界）。</li><li>位置0.125ns：成功读取（记录为当前右边界）。</li><li>位置0.25ns：成功读取（记录为当前右边界）。</li><li>位置0.375ns：失败读取（记录为当前左边界）。</li></ul></li><li>通过二分搜索，确认左侧有效位置可能在0.25ns附近，确定该位置为0.25ns。</li></ul><h5 id="寻找右侧有效位置："><a href="#寻找右侧有效位置：" class="headerlink" title="寻找右侧有效位置："></a>寻找右侧有效位置：</h5><ul><li>从0.375ns开始，向右移动1&#x2F;4个DDR时钟周期（0.25ns）：<ul><li>新位置为0.625ns，继续读取，成功读取。</li><li>移动到0.75ns，成功读取。</li><li>移动到0.875ns，成功读取。</li><li>移动到1ns，失败读取（当前右边界为0.875ns）。</li></ul></li><li>再次使用二分搜索，找到右侧有效位置为0.875ns。</li></ul><h5 id="确定最终门控位置："><a href="#确定最终门控位置：" class="headerlink" title="确定最终门控位置："></a>确定最终门控位置：</h5><ul><li>最终的门控位置取左侧和右侧有效位置的中位数，即(0.25ns + 0.875ns) &#x2F; 2 &#x3D; 0.5625ns。</li></ul><h5 id="验证门控位置："><a href="#验证门控位置：" class="headerlink" title="验证门控位置："></a>验证门控位置：</h5><ul><li>在位置0.5625ns进行多次读取验证，如果所有读取均成功，则该门控位置被确认有效。</li></ul><blockquote><p>通过这一系列步骤，基础门控训练确保了DQS信号的门控位置能够在不同的电路条件下保持准确性，提高了DDR内存系统的可靠性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
            <tag> Data Training </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQS Gate Training</title>
      <link href="/2024/10/27/DDR/DQS%20Gate%20Training/"/>
      <url>/2024/10/27/DDR/DQS%20Gate%20Training/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><blockquote><p>DQS Gate Training是DDR内存系统中一种关键的训练机制，旨在通过抑制噪声和准确捕获读取数据来优化数据传输。由于在读取路径中的延迟（例如电路板的走线长度）常常不精确，因此需要对门控（Gate）进行训练，以确保它与读取数据精确对齐。</p></blockquote><h4 id="主要组成部分"><a href="#主要组成部分" class="headerlink" title="主要组成部分"></a>主要组成部分</h4><blockquote><p><strong>DQS门控：</strong></p><ul><li>DQS（数据选通信号）用于同步读数据。门控信号控制在何时允许数据被读取和采样，以抑制噪声影响。</li></ul></blockquote><blockquote><p><strong>训练机制:</strong></p><ul><li>DDR4 PHY解决方案提供了一种内置的DQS门控训练单元，可以在初始化过程中或通过软件&#x2F;内存控制器触发（使用PIR寄存器）。</li><li>提供了两种训练机制：基础门控训练（Basic Gate Training）和读取定级（Read-Leveling）</li></ul></blockquote><h4 id="基础门控训练（Basic-Gate-Training）"><a href="#基础门控训练（Basic-Gate-Training）" class="headerlink" title="基础门控训练（Basic Gate Training）"></a>基础门控训练（Basic Gate Training）</h4><ul><li><p>执行过程：</p><ul><li>执行一系列读取事务，通过在可能的门控位置上扫描DQS门，以发现一个合适的门控位置，使读取操作成功。</li><li>由于可能的位置数量非常大（最多可达到9个tCK周期的延迟线tap），因此使用二分搜索算法加速搜索过程。</li></ul></li><li><p>具体步骤：</p><ul><li>启动训练，系统将尝试不同的门控延迟位置。</li><li>对于每个延迟位置，进行读取事务并监测读取成功与否。</li><li>通过二分搜索算法有效地缩小可能的延迟范围，找到最佳的门控位置。</li></ul></li></ul><h4 id="读取定级（Read-Leveling）"><a href="#读取定级（Read-Leveling）" class="headerlink" title="读取定级（Read-Leveling）"></a>读取定级（Read-Leveling）</h4><ul><li><p>执行过程：</p><ul><li>采用采样窗口技术来识别读取DQS的上升沿，并确定门控位置。</li><li>读取定级不检查读取数据的正确性，而是关注DQS信号本身的时间对齐。</li></ul></li><li><p>具体步骤：</p><ul><li>对DQS信号进行采样，寻找最佳的时机以确保读取的数据在门控开启时被准确采样。</li><li>在整个过程中，读取数据的准确性并不是重点，主要是确保DQS与读取数据的时间对齐。</li></ul></li><li><p>同步训练</p><ul><li>同时训练所有字节通道：这两个算法都同时训练所有字节通道，确保在每个rank中，所有字节的DQS信号都被有效地门控。</li></ul></li></ul><blockquote><p>逐个训练rank：在共享AC双通道模式下，相关的每个rank也会逐个训练。</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>DQS Gate Training通过精确对齐门控信号和读取数据，提高了DDR内存的信号完整性和性能。通过基础门控训练和读取定级的结合，系统能够有效处理不确定性并优化数据传输过程。基础门控训练负责找到合适的门控位置，而读取定级确保信号的同步，为高效稳定的数据传输奠定基础。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR Traning</title>
      <link href="/2024/10/22/DDR/DDR-Traning/"/>
      <url>/2024/10/22/DDR/DDR-Traning/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="DDR-Training概述"><a href="#DDR-Training概述" class="headerlink" title="DDR Training概述"></a><a>DDR Training概述</a></h3><blockquote><p>DDR使用的是并行接口进行数据传输，这意味着多个数据位（64bits或者是128bits）同时在一组信号线上进行传输。随着总线频率的增加，信号在PCB(印刷电路板)上的传输变得更加复杂，因为PCB走线的长度差异，PVT（工艺，电压，温度）变化等因素会导致信号传播时间（即延迟）的差异。</p></blockquote><blockquote><p>当信号时序没有被正确对齐，或者是信号质量因为上述的原因而下降的时候，DDR控制器在采样点读取的数据可能会出错，导致读写操作异常，这是因为DDR在每个时钟周期的上升沿和下降沿都会进行数据传输，任何微小的时序偏差都可能导致数据被错误地采集。</p></blockquote><blockquote><p>为了解决上述问题，DDR系统就引入了Traning机制。Traning的主要目的是在DDR初始化过程中，动态调整DRAM与PHY之间的数据与地址命令信号线的时序关系，以确保信号在正确的时间被采样。</p></blockquote><h4 id="training的大致流程："><a href="#training的大致流程：" class="headerlink" title="training的大致流程："></a>training的大致流程：</h4><p><img src="https://s2.loli.net/2024/10/22/irSe9UZcqAGflL1.png" alt="image-20241022203829731"></p><h4 id="记住下面几个问题"><a href="#记住下面几个问题" class="headerlink" title="记住下面几个问题"></a>记住下面几个问题</h4><blockquote><ul><li><a style="color: red">Traning的目的是什么</a></li><li><a style="color: red">Traning调节是什么，反馈是什么</a></li><li><a style="color: red">协议规定的是什么</a></li><li><a style="color: red">具体的实现是什么</a></li></ul></blockquote><h4 id="Training的对象"><a href="#Training的对象" class="headerlink" title="Training的对象"></a>Training的对象</h4><p><img src="https://s2.loli.net/2024/10/22/jsCt6QMGeIXEPUf.png" alt="image-20241022204755366"></p><blockquote><p>对象是DDR PHY和DRAM之间的交互信号线</p></blockquote><ul><li>CK：时钟信号</li><li>CS：片选信号，RANK选择</li><li>AC：Address和Command</li><li>DQS：对数据的采样信号</li><li>DQ：数据线</li><li>Alert：用于training过程中，反馈DCS和DCA到达RCD的回应。正式业务场景是不需要的（这个就像是上面流程图的反馈，当然反馈的功能不只是training，有时候这个信号也会作为ecc的反馈）。</li></ul><p><a>整理之后的training流程</a></p><p><img src="https://s2.loli.net/2024/10/22/VeFAOu2iY8zNJfo.png" alt="image-20241022205033448"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法</title>
      <link href="/2024/10/20/Programming/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/10/20/Programming/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>在 Python 中，你不需要显式声明变量类型。变量名可以直接赋值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="string">&quot;lin&quot;</span></span><br><span class="line">c = <span class="number">2.34</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字：整数（int），浮点数（float），复数（complex）</span></span><br><span class="line">a = <span class="number">10</span> <span class="comment"># int</span></span><br><span class="line">b = <span class="number">3.23</span> <span class="comment"># float</span></span><br><span class="line">c = <span class="number">2</span> + <span class="number">3j</span> <span class="comment"># complex</span></span><br><span class="line"><span class="comment"># 字符串：单引号或者是双引号表示</span></span><br><span class="line">s = <span class="string">&quot;zlin&quot;</span></span><br><span class="line"><span class="comment"># 列表： 有序集合，可以包含不同的元素</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="string">&quot;fuour&quot;</span>, <span class="number">3.2</span>]</span><br><span class="line"><span class="comment"># 元组：有序且不可变的集合</span></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;sdf&quot;</span>)</span><br><span class="line"><span class="comment"># 字典：键值对的集合</span></span><br><span class="line"> dic = &#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;zlin&quot;</span>,  <span class="string">&quot;age&quot;</span> : <span class="number">23</span>&#125;</span><br><span class="line"><span class="comment"># 集合：无序且不重复的元素集合</span></span><br><span class="line"><span class="built_in">set</span> = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">#布尔值：True和False</span></span><br><span class="line">is_true = <span class="literal">True</span></span><br><span class="line">is_false = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>读取文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;zlin.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">content = file.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure></li><li>写入文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;zlin.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(<span class="string">&quot;hhh&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><ul><li>是一种简洁的方式来创建列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><ul><li>一种快速简洁的方式来创建字典<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;x: x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure></li></ul><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><ul><li>一种集合的简洁方式来创建集合<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> = &#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言运算符优先级</title>
      <link href="/2024/10/20/Programming/c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2024/10/20/Programming/c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR科普-内存的基本概念</title>
      <link href="/2024/10/20/DDR/DDR%E7%A7%91%E6%99%AE-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/10/20/DDR/DDR%E7%A7%91%E6%99%AE-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h3 id="DIMM"><a href="#DIMM" class="headerlink" title="DIMM"></a>DIMM</h3><blockquote><p>DIMM即Dual In-Line Memory Module，即内存条印刷电路板正反面均有金手指与主板上的内存条槽相接触的结构。内存条也有人叫DIMM条，主板上的内存槽也有人称为DIMM槽。除了有DIMM，还有SIMM（Single In-Line Memory Module)。</p></blockquote><h3 id="SODIMM"><a href="#SODIMM" class="headerlink" title="SODIMM"></a>SODIMM</h3><blockquote><p>对于笔记本电脑，使用普通内存条会使笔记本尺寸过大，而直接使用内存颗粒则不便于扩展与维修，SODIMM应运而生，SODIMM是Small Outline DIMM，即小尺寸的DIMM。</p></blockquote><h3 id="Memory-Channel"><a href="#Memory-Channel" class="headerlink" title="Memory Channel"></a>Memory Channel</h3><blockquote><p>若干个DIMM可以连接到一组总线上，这组总线被称为内存通道（Memory Channel）。</p></blockquote><h3 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h3><blockquote><p>主板上放3条DIMM可以，但从第四条DIMM开始，因为走线距离过长的原因导致信号质量下降，因此，我们可以将两条物理DIMM的内存颗粒放在一块内存印刷电路板上。我们把这种逻辑DIMM称为Rank。为了支持多RANK的内存条，我们需要在物理DIMM接口上定义多个CS_N片选信号以选择相应的Rank。下图蓝色是Rank1的片选信号，黄色是Rank0的片选信号。</p></blockquote><p><img src="https://s2.loli.net/2024/10/20/QoV5wSBktCda4Xb.jpg" alt="img"></p><blockquote><p>因此，一个Rank就是指一组内存颗粒的CS信号被连在一起，并由内存控制器单独的一根CS_N信号控制，共同组成位宽为64bit（不带ECC）或72bit（带ECC）的存储阵列，共同完成一条内存通道下发的指令。注意，支持ECC功能的内存条除了64bit的数据外，还有8bit的校验数据。</p></blockquote><h3 id="RDIMM"><a href="#RDIMM" class="headerlink" title="RDIMM"></a>RDIMM</h3><blockquote><p>RDIMM的第一个字母R实际就是一颗额外的芯片，称为时钟缓存寄存器芯片（Registering Clock Driver)。没有该芯片的内存条一般被称为UDIMM（Unbuffered-DIMM）。这颗寄存器芯片主要用来缓存（buffer）时钟&#x2F;控制&#x2F;命令&#x2F;地址等信号。缓存的主要目的是解决信号质量以及负载过重的问题。RCD（时钟缓存寄存器芯片）</p></blockquote><h3 id="LRDIMM"><a href="#LRDIMM" class="headerlink" title="LRDIMM"></a>LRDIMM</h3><blockquote><p>为了是一根物理DIMM支持更多的Rank，我们将数据信号通过数据缓存（Data Buffer）芯片缓存，而不直接连接DRAM Devices，从而改善数据信号的质量，这种结构称之为LRDIMM。</p></blockquote><p><a><strong>总结一下，DIMM分为如下三种：</strong></a></p><ul><li>UDIMM</li></ul><blockquote><p>没有缓冲的存储模组（UnbufferDualInlineMemoryModule），简称UDIMM，存储模组上的全部信号线路可以和内存控制器的封装引脚直接进行连接。</p></blockquote><ul><li>RDIMM</li></ul><blockquote><p>RDIMM的第一个字母R实际就是一颗额外的芯片，称为时钟缓存寄存器芯片（Registering Clock Driver)。没有该芯片的内存条一般被称为UDIMM（Unbuffered-DIMM）。带寄存器的存储模组（RegisterDualInlineMemoryModule），简称RDIMM，特点是存储模组控制线路和地址线路先连接寄存器后再接入到控制器的封装引脚，而数据信号线路与控制器的封装引脚采用直接连接的方式。这样的设计不仅可以保证接入到内存控制器的信号受到很小的外界干扰，保证信号完整性。</p></blockquote><ul><li>LRDIMM</li></ul><blockquote><p>负载较低型存储模组（LoadReducedDualInlineMemoryModule），简称LRDIMM，模组上的全部信号总线先连接内存缓存器再连接控制器的封装引脚。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
          <category> Memory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get_response</title>
      <link href="/2024/10/20/DV/get-response/"/>
      <url>/2024/10/20/DV/get-response/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> SystemVerilog </category>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> SystemVerilog </tag>
            
            <tag> UVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make_run</title>
      <link href="/2024/10/19/Programming/make-run/"/>
      <url>/2024/10/19/Programming/make-run/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>make_soc</title>
      <link href="/2024/10/19/Programming/make-soc/"/>
      <url>/2024/10/19/Programming/make-soc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>svt_axi_vip</title>
      <link href="/2024/10/19/DV/svt-axi-vip/"/>
      <url>/2024/10/19/DV/svt-axi-vip/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Synopsys AXI VIP的一些使用心得<a><span id="more"></span></a></p></blockquote><ul><li><p>配置一些axi信号的默认值</p><ul><li>read_addr_chan_idle_val</li><li>read_data_chan_idle_val</li><li>write_addr_chan_idle_val</li><li>write_data_chan_idle_val</li><li>write_resp_chan_idle_val</li></ul></li><li><p>配置id的宽度</p><ul><li>id_width</li></ul></li><li><p>配置数据和地址宽度</p><ul><li>addr_width</li><li>data_width</li></ul></li><li><p>bus_inactivity_timeout</p></li><li><p>system_monitor_enable</p></li><li><p>enable_xml_gen</p></li><li><p>当配置成axi4的时候，数据和地址的id我感觉是分开的，需要下面的参数</p><ul><li>wid_for_non_axi3_enable</li></ul></li><li><p>使能其他的信号</p><ul><li><p>arqos_enable</p></li><li><p>awqos_enable</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> Programming </tag>
            
            <tag> UVM </tag>
            
            <tag> VIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svt_ahb_vip</title>
      <link href="/2024/10/19/DV/svt-ahb-vip/"/>
      <url>/2024/10/19/DV/svt-ahb-vip/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> UVM </tag>
            
            <tag> VIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svt_apb_vip</title>
      <link href="/2024/10/19/DV/svt-apb-vip/"/>
      <url>/2024/10/19/DV/svt-apb-vip/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p>]]></content>
      
      
      <categories>
          
          <category> UVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> Programming </tag>
            
            <tag> UVM </tag>
            
            <tag> VIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDR科普-DDR PHY</title>
      <link href="/2024/10/19/DDR/DDR%E7%A7%91%E6%99%AE-DDR%20PHY/"/>
      <url>/2024/10/19/DDR/DDR%E7%A7%91%E6%99%AE-DDR%20PHY/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h1 id="DDR介绍"><a href="#DDR介绍" class="headerlink" title="DDR介绍"></a>DDR介绍</h1><h4 id="DDR子系统是由两个部分组成的，ddr-controller和ddr-phy。ddr-controller主要是负责承担CPU（或者说是外部）和memory系统之间进行数据交互时候的传输效率和调度的。ddr-phy主要是负责数据交换过程中的传输速度了。（如下图）"><a href="#DDR子系统是由两个部分组成的，ddr-controller和ddr-phy。ddr-controller主要是负责承担CPU（或者说是外部）和memory系统之间进行数据交互时候的传输效率和调度的。ddr-phy主要是负责数据交换过程中的传输速度了。（如下图）" class="headerlink" title="DDR子系统是由两个部分组成的，ddr controller和ddr phy。ddr controller主要是负责承担CPU（或者说是外部）和memory系统之间进行数据交互时候的传输效率和调度的。ddr phy主要是负责数据交换过程中的传输速度了。（如下图）"></a>DDR子系统是由两个部分组成的，ddr controller和ddr phy。ddr controller主要是负责承担CPU（或者说是外部）和memory系统之间进行数据交互时候的传输效率和调度的。ddr phy主要是负责数据交换过程中的传输速度了。（如下图）</h4><p><img src="https://s2.loli.net/2024/10/19/5WCbYzpnBrKU3M8.png" alt="img"></p><p>ddr phy主要是由两个部分来组成的，一个pub（soft ip）和另外一个phy（hard ip）。</p><p><img src="https://s2.loli.net/2024/10/19/N4Bph3x1SVvuyFr.png" alt="image-20241019182354234"></p><p>其中pub的结构如下图所示：</p><p><img src="https://s2.loli.net/2024/10/19/tqeWV5swdzvXAG2.png" alt="image-20241019182423919"></p><p>pub具有一下特点：</p><ul><li>不支持SDRAM的DLL off模式</li><li>数据通路的位宽以8bit的增量递增</li><li>支持最多4个rank</li><li>支持单数据通道或者双数据通道的配置</li><li>能够完成PHY的初始化，tranning以及控制逻辑</li><li>支持自动化的DQS Gate Tranning</li><li>支持Delay line和VT补偿</li><li>支持自动化的Write Leveing</li><li>支持自动化的Write，Read的data bit deskew</li><li>支持自动化的DQ&#x2F;DQS eye tranning</li><li>支持apb或者其他的通用接口配置寄存器</li><li>支持DFI接口</li></ul><h2 id="PUB模块实现初始化流程"><a href="#PUB模块实现初始化流程" class="headerlink" title="PUB模块实现初始化流程"></a>PUB模块实现初始化流程</h2><h3 id="DDR系统初始化"><a href="#DDR系统初始化" class="headerlink" title="DDR系统初始化"></a>DDR系统初始化</h3><p><img src="https://s2.loli.net/2024/10/19/M53dul89eLDIJyn.png" alt="image-20241019182857357"></p><p><img src="https://s2.loli.net/2024/10/19/kZ5zbw3nlfeBqR4.png" alt="image-20241019182913841"></p><p><img src="https://s2.loli.net/2024/10/19/eoq6BtyOYgSrh1j.png"><img src="https://s2.loli.net/2024/10/19/sD9fcjVyJOFwlvZ.png" alt="image-20241019182938780"><img src="https://s2.loli.net/2024/10/19/TWYxRvhF1EjzPVB.png"><img src="https://s2.loli.net/2024/10/19/bGQc4DjLaWzyqT6.png"><img src="https://s2.loli.net/2024/10/19/qXKekYH1EI4LW5r.png" alt="image-20241019183010016"><img src="https://s2.loli.net/2024/10/19/2hwVvX7fxRQDcFT.png" alt="image-20241019183016978"></p>]]></content>
      
      
      <categories>
          
          <category> DDR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile基础</title>
      <link href="/2024/10/19/Programming/Makefile/"/>
      <url>/2024/10/19/Programming/Makefile/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a><br>这是关于Makefile的基本用法</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="目标：依赖"><a href="#目标：依赖" class="headerlink" title="目标：依赖"></a>目标：依赖</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先检查tb.sv和dut.sv是不是存在，以及是否有修改。如果依赖有修改或者是目标不存在得时候，就执行下面得命令</span></span><br><span class="line"><span class="section">simv:tb.sv dut.sv</span></span><br><span class="line">vcs -full64 -sverilog tb.sv </span><br></pre></td></tr></table></figure><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:sim</span></span><br><span class="line"><span class="section">sim:simv</span></span><br><span class="line">    ./simv </span><br></pre></td></tr></table></figure><h3 id="ONESHELL"><a href="#ONESHELL" class="headerlink" title=".ONESHELL:"></a>.ONESHELL:</h3><ul><li>所有的指令就会在一个shell中执行了</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.ONESHELL:</span></span><br><span class="line"><span class="comment">#正常些指令</span></span><br></pre></td></tr></table></figure><h3 id="语句的回显问题"><a href="#语句的回显问题" class="headerlink" title="语句的回显问题"></a>语句的回显问题</h3><ul><li>可以在语句前面用”<strong>@</strong>“就行了，但是不想每个前面都打的话，就用.SILENT</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.SILENT: main all    # 后面是目标</span></span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="ifeq"><a href="#ifeq" class="headerlink" title="ifeq"></a>ifeq</h3><ul><li>判断一个变量是不是已经定义了</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OS = Linux</span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OS = Linux</span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifdef</span> Mac</span><br><span class="line">    OS= MacOS</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifdef</span> Mac</span><br><span class="line">    OS= MacOS</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    OS = Linux</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h3><ul><li>判断一个变量是不是没有定义</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version = 3.0</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(version)</span>,1.0)            <span class="comment"># ifeq后一定要一个空格</span></span><br><span class="line">    msg := 版本太旧了，请更新版本</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(version)</span>, 3.0)</span><br><span class="line">    msg := 版本太新了，也不行</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    msg := 版本可以用</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外的写法</span></span><br><span class="line">msg = Other</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;<span class="variable">$(OS)</span>&quot;</span> <span class="string">&quot;Windows_NT&quot;</span></span><br><span class="line">    msg = This is a Windows Platform</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> &#x27;<span class="variable">$(OS)</span>&#x27; &#x27;Windows_NT&#x27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> &#x27;<span class="variable">$(OS)</span>&#x27; <span class="string">&quot;Windows_NT&quot;</span></span><br></pre></td></tr></table></figure><h3 id="ifneq"><a href="#ifneq" class="headerlink" title="ifneq"></a>ifneq</h3><ul><li>判断两个值是不是不相等</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和上面的一样用法</span><br></pre></td></tr></table></figure><h2 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h2><h3 id="是二次展开，-是立即展开"><a href="#是二次展开，-是立即展开" class="headerlink" title="=是二次展开， :=是立即展开"></a><kbd>=</kbd>是二次展开， <kbd>:=</kbd>是立即展开</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只需要修改文件开头就行了，&quot;:=&quot;表示变量决定于它在makefile中的位置（顺序执行的），而&quot;=&quot;是makefile最后的位置</span></span><br><span class="line">tbfile := tb.sv env_pkg.sv test_pkg.sv</span><br><span class="line">rtlfile := dut.v a.v b.v</span><br><span class="line"><span class="section">simv: <span class="variable">$(tbfile)</span> <span class="variable">$(rtlfile)</span></span></span><br><span class="line">    vcs -full64 -sverilog <span class="variable">$(tbfile)</span> <span class="variable">$(rtlfile)</span></span><br></pre></td></tr></table></figure><h3 id="取消变量的定义"><a href="#取消变量的定义" class="headerlink" title="取消变量的定义"></a>取消变量的定义</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">undefine</span> &lt;变量名&gt;</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(USERNAME)</span></span><br></pre></td></tr></table></figure><h3 id="shell运行赋值"><a href="#shell运行赋值" class="headerlink" title="shell运行赋值"></a>shell运行赋值</h3><ul><li>使用<kbd>!=</kbd>，运行一个shell命令，返回值赋值给一个变量</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files != ls </span><br></pre></td></tr></table></figure><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files += linzhiwen.cpp</span><br></pre></td></tr></table></figure><h3 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h3><ul><li>条件赋值的**<kbd>?=</kbd>**,变量如果已经赋值了，那么就保持原来的值，如果没有就把右边的赋值给左边</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1 = 100</span><br><span class="line">var1 ?= 200</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">@echo <span class="variable">$(var1)</span> </span><br></pre></td></tr></table></figure><h3 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h3><ul><li>语法：$(var:a&#x3D;b)，意思是将变量var的值中每一项结尾的a替换为b</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var = main.cpp a.cpp b.cpp</span><br><span class="line">objs := $(var:.cpp=.v) </span><br><span class="line">objes := $(var:%.cpp=%.v)</span><br></pre></td></tr></table></figure><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><ul><li>makefile中的所有的变量都可以通过终端传递，实现覆盖</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make GUI=xxx</span><br></pre></td></tr></table></figure><h2 id="字符替换函数"><a href="#字符替换函数" class="headerlink" title="字符替换函数"></a>字符替换函数</h2><h3 id="subst"><a href="#subst" class="headerlink" title="subst"></a>subst</h3><ul><li>文本替换函数，返回替换后的文本</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> target,replacement,text)</span></span><br><span class="line">        <span class="comment">#--- 用relacement替换text中的target</span></span><br><span class="line">        <span class="comment">#--- target 需要替换的内容</span></span><br><span class="line">        <span class="comment">#--- replacement 替换为的内容</span></span><br><span class="line">        <span class="comment">#--- text 需要处理的内容，可以是任意字符串</span></span><br><span class="line"></span><br><span class="line">objs = main.o hello.o</span><br><span class="line">srcs = <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$(objs)</span>)</span></span><br><span class="line">headers = <span class="variable">$(<span class="built_in">subst</span> .cpp,.h,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(srcs)</span></span><br><span class="line">    @echo <span class="variable">$(headers)</span></span><br></pre></td></tr></table></figure><h3 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h3><ul><li>模式替换， 返回替换后的文本</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br><span class="line">        <span class="comment">#--- pattern 需要替换的模式</span></span><br><span class="line">        <span class="comment">#--- replacement 需要替换为</span></span><br><span class="line">        <span class="comment">#--- text 待处理内容，各项内容需要用空格隔开</span></span><br><span class="line">objs = main.ohello.o</span><br><span class="line">srcs = <span class="variable">$(<span class="built_in">subst</span> %.o,%.cpp,<span class="variable">$(objs)</span>)</span></span><br><span class="line">headers = <span class="variable">$(<span class="built_in">subst</span> %.cpp,%.h,<span class="variable">$(srcs)</span>)</span>  </span><br></pre></td></tr></table></figure><h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><ul><li>去除字符串头部和尾部的空格，中间如果连续有多个空格，则用一个空格替换，返回去除空格后的文本</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> string)</span></span><br><span class="line">        <span class="comment">#--- string 需要去除空格的字符串</span></span><br><span class="line">files = aa hello.cpp      main.cpp     test.cpp</span><br><span class="line">files := <span class="variable">$(<span class="built_in">subst</span> aa,        ,<span class="variable">$(files)</span>)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h3><ul><li>查找字符串，如果找到了，则返回对应的字符串，如果没找到，则反回空串</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> find,string)</span></span><br><span class="line">        <span class="comment">#--- find 需要查找的字符串</span></span><br><span class="line">        <span class="comment">#--- string 用来查找的内容</span></span><br><span class="line">files = hello.cpp main.cpp test.cpp</span><br><span class="line">find = <span class="variable">$(<span class="built_in">findstring</span> hel,<span class="variable">$(files)</span>)</span></span><br><span class="line">find = <span class="variable">$(<span class="built_in">findstring</span> HEL,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul><li>从文本中筛选出符合模式的内容并返回</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern…,text)</span></span><br><span class="line">        <span class="comment">#--- pattern 模式，可以有多个，用空格隔开</span></span><br><span class="line">        <span class="comment">#--- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理</span></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">filter</span> %.o %.h,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h3><ul><li>与filter相反，过滤掉符合模式的，返回剩下的内容</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern…,text)</span></span><br><span class="line">        <span class="comment">#--- pattern 模式，可以有多个，用空格隔开</span></span><br><span class="line">        <span class="comment">#--- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">filter</span>-out %.o %.cpp,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li>将文本内的各项按字典顺序排列，并且移除重复项</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> list)</span></span><br><span class="line">       <span class="comment"># --- list 需要排序内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">sort</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="word"><a href="#word" class="headerlink" title="word"></a>word</h3><ul><li>用于返回文本中第n个单词</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> n,text)</span></span><br><span class="line">        <span class="comment"># --- n 第n个单词，从1开始，如果n大于总单词数，则返回空串</span></span><br><span class="line">        <span class="comment"># --- text 待处理文本</span></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">word</span> 3,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h3><ul><li>用于返回文本指定范围内的单词列表</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> start,end,text)</span></span><br><span class="line">        <span class="comment">#--- start 起始位置，如果大于单词总数，则返回空串</span></span><br><span class="line">        <span class="comment">#--- end 结束位置，如果大于单词总数，则返回起始位置之后全部，如果start &gt; end，什么都不返回</span></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wordlist</span> 3,6,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="words"><a href="#words" class="headerlink" title="words"></a>words</h3><ul><li>返回文本中单词数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(words text)</span></span><br><span class="line">       <span class="comment"># --- text 需要处理的文本</span></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">nums = <span class="variable">$(words <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h3><ul><li>返回第一个单词</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> text)</span></span><br></pre></td></tr></table></figure><h3 id="lastword"><a href="#lastword" class="headerlink" title="lastword"></a>lastword</h3><ul><li>返回最后一个单词</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">lastword</span> text)</span></span><br></pre></td></tr></table></figure><h2 id="文件名处理函数"><a href="#文件名处理函数" class="headerlink" title="文件名处理函数"></a>文件名处理函数</h2><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><ul><li>返回文件目录</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> files)</span></span><br><span class="line">        <span class="comment">#--- files 需要返回目录的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp</span><br><span class="line"></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h3><ul><li>返回除了目录部分的文件名</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> files)</span></span><br><span class="line">        <span class="comment">#--- files 需要返回文件列表，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h3><ul><li>返回文件后缀名，如果没有后缀返回空</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> files)</span></span><br><span class="line">        <span class="comment">#--- files 需要返回后缀的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">suffix</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><ul><li>返回除了文件名字后缀的部分</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> files)</span></span><br><span class="line">       <span class="comment"># --- files 需要返回的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">basename</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h3><ul><li>给文件名字添加后缀</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> <span class="built_in">suffix</span>,files)</span></span><br><span class="line">        <span class="comment">#--- suffix 需要添加的后缀</span></span><br><span class="line">        <span class="comment">#--- files 需要添加后缀的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">addsuffix</span> .exe,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h3><ul><li>给文件名字添加前缀</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> prefix,files)</span></span><br><span class="line">        <span class="comment">#--- prefix 需要添加的前缀</span></span><br><span class="line">        <span class="comment">#--- files 需要添加前缀的文件名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">addprefix</span> make/,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><ul><li>将两个列表中的内容一对一连接，如果两个列表内容数量不相等，则多出来的部分原样返回</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> list1,list2)</span></span><br><span class="line">        <span class="comment">#--- list1 第一个列表</span></span><br><span class="line">        <span class="comment">#--- list2 需要连接的第二个列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = hello main test</span><br><span class="line">f2 = .cpp .hpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">join</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><ul><li>返回符合通配符号的文件列表</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span></span><br><span class="line">        <span class="comment">#--- pattern 通配符</span></span><br><span class="line"></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> *)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> src/*.cpp)</span></span><br></pre></td></tr></table></figure><h3 id="realpath"><a href="#realpath" class="headerlink" title="realpath"></a>realpath</h3><ul><li>返回文件的绝对路径</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">realpath</span> files)</span></span><br><span class="line">       <span class="comment"># --- files 需要返回绝对路径的文件，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">f3 = <span class="variable">$(<span class="built_in">wildcard</span> src/*)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">realpath</span> <span class="variable">$(f3)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h3><ul><li>返回绝对路径，用法同realpath，如果一个文件名不存在，realpath不会返回内容，abspath则会返回一个当前文件夹一下的绝对路径</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">abspath</span> files)</span></span><br></pre></td></tr></table></figure><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul><li>条件判断，如果条件展开不是空串，则反回真的部分，否则返回假的部分</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> condition,then-part[,else-part])</span></span><br><span class="line">        <span class="comment">#--- condition 条件部分</span></span><br><span class="line">        <span class="comment">#--- then-part 条件为真时执行的部分</span></span><br><span class="line">        <span class="comment">#--- else-part 条件为假时执行的部分，如果省略则为假时返回空串</span></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(files)</span>,有文件,没有文件)</span></span><br></pre></td></tr></table></figure><h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><ul><li>返回条件中第一个不为空的部分</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">or</span> condition1[,condition2[,condition3…]])</span></span><br><span class="line"></span><br><span class="line">f1 = </span><br><span class="line">f2 = </span><br><span class="line">f3 = hello.cpp</span><br><span class="line">f4 = main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">or</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>,<span class="variable">$(f3)</span>,<span class="variable">$(f4)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><ul><li>如果条件中有一个为空串，则返回空，如果全都不为空，则返回最后一个条件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">and</span> condition1[,condition2[,condition3…]])</span></span><br><span class="line"></span><br><span class="line">f1 = 12</span><br><span class="line">f2 = 34</span><br><span class="line">f3 = hello.cpp</span><br><span class="line">f4 = main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">and</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>,<span class="variable">$(f3)</span>,<span class="variable">$(f4)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="intcomp"><a href="#intcomp" class="headerlink" title="intcomp"></a>intcomp</h3><ul><li>比较两个整数大小，并返回对应操作结果（GNU make 4.4以上版本）</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(intcmp lhs,rhs[,lt-part[,eq-part[,gt-part]]])</span> </span><br><span class="line">        <span class="comment">#--- lhs 第一个数</span></span><br><span class="line">        <span class="comment">#--- rhs 第二个数</span></span><br><span class="line">        <span class="comment">#--- lt-part  lhs &lt; rhs时执行</span></span><br><span class="line">        <span class="comment">#--- eq-part  lhs = rhs时执行</span></span><br><span class="line">        <span class="comment">#--- gt-part  lhs &gt; rhs时执行</span></span><br><span class="line">        <span class="comment">#--- 如果只提供前两个参数，则lhs == rhs时返回数值，否则返回空串 </span></span><br><span class="line">        <span class="comment">#    参数为lhs,rhs,lt-part时，当lhs &lt; rhs时返回lt-part结果，否则返回空</span></span><br><span class="line">        <span class="comment">#    参数为lhs,rhs,lt-part,eq-part，lhs &lt; rhs返回lt-part结果，否则都返回eq-part结果</span></span><br><span class="line">        <span class="comment">#    参数全时，lhs &lt; rhs返回lt-part，lhs == rhs返回eq-part, lhs &gt; rhs返回gt-part</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@echo <span class="variable">$(intcmp 2,2,-1,0,1)</span></span><br></pre></td></tr></table></figure><h2 id="makefile常用函数"><a href="#makefile常用函数" class="headerlink" title="makefile常用函数"></a>makefile常用函数</h2><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><ul><li>读写文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">file</span> op filename[,text])</span></span><br><span class="line">        <span class="comment">#--- op 操作</span></span><br><span class="line">        <span class="comment">#        &gt; 覆盖</span></span><br><span class="line">        <span class="comment">#        &gt;&gt; 追加</span></span><br><span class="line">        <span class="comment">#        &lt; 读</span></span><br><span class="line">        <span class="comment">#--- filename 需要操作的文件名</span></span><br><span class="line">        <span class="comment">#--- text 写入的文本内容，读取是不需要这个参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">write = <span class="variable">$(<span class="built_in">file</span> &gt; makewrite.txt,<span class="variable">$(files)</span>)</span></span><br><span class="line">read = <span class="variable">$(<span class="built_in">file</span> &lt; makewrite.txt)</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul><li>对一列用空格隔开的字符序列中每一项进行处理，并返回处理后的列表</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> each,list,process)</span></span><br><span class="line">        <span class="comment">#--- each list中的每一项</span></span><br><span class="line">        <span class="comment">#--- list 需要处理的字符串序列，用空格隔开</span></span><br><span class="line">        <span class="comment">#--- process 需要对每一项进行的处理</span></span><br><span class="line"></span><br><span class="line">list = 1 2 3 4 5</span><br><span class="line">result = <span class="variable">$(<span class="built_in">foreach</span> each,<span class="variable">$(list)</span>,$(<span class="built_in">addprefix</span> cpp,$(<span class="built_in">addsuffix</span> .cpp,<span class="variable">$(each)</span>)</span>))</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ul><li>将一些复杂的表达式写成一个变量，用call可以像调用函数一样进行调用。类似于编程语言中的自定义函数。在函数中可以用$(n)来访问第n个参数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> funcname,param1,param2,…)</span></span><br><span class="line">       <span class="comment"># --- funcname 自定义函数（变量名）</span></span><br><span class="line">       <span class="comment"># --- 参数至少一个，可以有多个，用逗号隔开</span></span><br><span class="line"></span><br><span class="line">dirof =  <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">realpath</span> $(1)</span>)) <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">realpath</span> $(2)</span>))</span><br><span class="line">result = <span class="variable">$(<span class="built_in">call</span> dirof,main.cpp,src/hello.cpp)</span></span><br></pre></td></tr></table></figure><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><ul><li>对于不是立即展开的变量，可以查看变量的原始定义；对于立即展开的变量，直接返回变量值</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">value</span> variable)</span></span><br><span class="line"></span><br><span class="line">var = value function test</span><br><span class="line">var2 = <span class="variable">$(var)</span></span><br><span class="line">var3 := <span class="variable">$(var)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">value</span> var2)</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">value</span> var3)</span></span><br></pre></td></tr></table></figure><h3 id="origin"><a href="#origin" class="headerlink" title="origin"></a>origin</h3><ul><li>查看一个变量定义的来源</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> variable)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var2 = origin function </span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> var1)</span>    <span class="comment"># undefined 未定义</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> CC)</span>        <span class="comment"># default 默认变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> JAVA_HOME)</span> <span class="comment"># environment 环境变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> var2)</span>    <span class="comment"># file 在Makefile文件中定义的变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> @)</span>        <span class="comment"># automatic 自动变量</span></span><br></pre></td></tr></table></figure><h3 id="flavor"><a href="#flavor" class="headerlink" title="flavor"></a>flavor</h3><ul><li>查看一个变量的赋值方式</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">flavor</span> variable)</span></span><br><span class="line"></span><br><span class="line">var2 = flavor function</span><br><span class="line">var3 := flavor funciton</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var1)</span>    <span class="comment"># undefined 未定义</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var2)</span>    <span class="comment"># recursive 递归展开赋值</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var3)</span>    <span class="comment"># simple 简单赋值</span></span><br></pre></td></tr></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><ul><li>可以将一段文本生成Makefile的内容</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">eval</span> text)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> eval_target = </span><br><span class="line"><span class="section">eval:</span></span><br><span class="line">    @echo Target Eval Test</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">eval</span> <span class="variable">$(eval_target)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul><li>用来执行shell的命令的</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">files = <span class="variable">$(<span class="built_in">shell</span> ls *.cpp)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> echo This is from <span class="built_in">shell</span> function)</span></span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>将一个字符串序列中的项拆开放入多个变量中，并对各个变量进行操作（GNU make 4.4以上版本）</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(let var1 [var2 ...],[list],proc)</span></span><br><span class="line">       <span class="comment"># --- var 变量，可以有多个，用空格隔开</span></span><br><span class="line">       <span class="comment"># --- list 待处理字符串，各项之间空格隔开</span></span><br><span class="line">       <span class="comment"># --- proc 对变量进行的操作，结果为let的返回值</span></span><br><span class="line">            将list中的值依次一项一项放到var中，如果var的个数多于list项数，那多出来的var是空串。如果</span><br><span class="line">            var的个数小于list项数，则先依次把前而的项放入var中，剩下的list所有项都放入最后一个var中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list = a b c d</span><br><span class="line">letfirst = <span class="variable">$(let first second rest,<span class="variable">$(list)</span>,<span class="variable">$(first)</span>)</span></span><br><span class="line">letrest = <span class="variable">$(let first second rest,<span class="variable">$(list)</span>,<span class="variable">$(rest)</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合call可以对所有项进行递归处理</span></span><br><span class="line">reverse = <span class="variable">$(let first rest,$(1)</span>,<span class="variable">$(<span class="built_in">if</span> <span class="variable">$(rest)</span>,$(<span class="built_in">call</span> reverse,<span class="variable">$(rest)</span>)</span> )<span class="variable">$(first)</span>)</span><br><span class="line"><span class="section">all: ; @echo $(call reverse,d c b a)</span></span><br></pre></td></tr></table></figure><h2 id="信息提示函数"><a href="#信息提示函数" class="headerlink" title="信息提示函数"></a>信息提示函数</h2><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><ul><li>用来提示错误信息并终止make执行</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> text)</span></span><br><span class="line">        <span class="comment">#--- text 提示信息</span></span><br><span class="line"></span><br><span class="line">EXIT_STATUS = -1</span><br><span class="line"><span class="keyword">ifneq</span> (0, <span class="variable">$(EXIT_STATUS)</span>)</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> An <span class="built_in">error</span> occured! make stopped!)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h3><ul><li>提示警告信息，make不会终止</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> text)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (0, <span class="variable">$(EXIT_STATUS)</span>)</span><br><span class="line">    <span class="variable">$(<span class="built_in">warning</span> This is a <span class="built_in">warning</span> message)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><ul><li>输出一些信息</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(info text…)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(info 编译开始.......)</span></span><br><span class="line"><span class="variable">$(info 编译结束)</span></span><br></pre></td></tr></table></figure><h2 id="多个makefile文件"><a href="#多个makefile文件" class="headerlink" title="多个makefile文件"></a>多个makefile文件</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul><li>可以读入其他makefile文件的内容，效果就如同在include的位置用对应的文件内容替换一样。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> mkf1 mkf2 <span class="comment"># 可以引入多个文件，用空格隔开</span></span><br><span class="line"><span class="keyword">include</span> *.mk    <span class="comment"># 可以用通配符，表示引入所有以.mk结尾的文件</span></span><br></pre></td></tr></table></figure><ul><li>如果找不到对应文件，则会报错，如果要忽略错误，可以在<code>include</code>前加<code>-</code></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> mkf1 mkf2</span><br></pre></td></tr></table></figure><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><ul><li>可以通过export指令向子项目传递变量</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> var  <span class="comment"># 传递var</span></span><br><span class="line"><span class="keyword">export</span>         <span class="comment"># 传递所有变量</span></span><br><span class="line"><span class="keyword">unexport</span>    <span class="comment"># 取消传递</span></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="-C"></a>-C</h3><ul><li>去到另一个文件夹里面执行make命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(MAKE)</span> -C dir_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2024/10/19/Programming/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/10/19/Programming/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h1 id="检测服务器端口"><a href="#检测服务器端口" class="headerlink" title="检测服务器端口"></a>检测服务器端口</h1><h3 id="本地服务端查看的"><a href="#本地服务端查看的" class="headerlink" title="本地服务端查看的"></a>本地服务端查看的</h3><ul><li><p>netstat -tunlp</p></li><li><p>ss -tunlp</p></li><li><p>lsof</p></li></ul><h3 id="远程登陆查看的"><a href="#远程登陆查看的" class="headerlink" title="远程登陆查看的"></a>远程登陆查看的</h3><ul><li>telnet</li><li>nmap</li><li>nc</li></ul><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><ul><li>管道命令</li><li>以行为单位</li><li>参数<ul><li>-n：仅仅显示脚本处理之后的结果</li><li>-e：使用指定脚本文件处理输入的文本文件</li><li>-f：直接将sed的动作写到一个文件内，-f filename</li><li>-r：支持拓展正则表达式</li><li>-i：直接修改读取的文件内容，不输出到终端</li><li>-v：显示版本信息</li></ul></li><li>删除第1-2行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed &#x27;1,2d&#x27;</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     4          do \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">     6          done</span><br></pre></td></tr></table></figure><ul><li>删除第2行到文件末尾</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl makefile | sed &#x27;2,$d&#x27;</span><br></pre></td></tr></table></figure><ul><li>在第二行后面加上字符，如果是<kbd>2i</kbd>的话就是在第二行的上面，不是下面了，如果是后面加上多行的话，就是另外一个引号先不给，然后给\，后面再给另外一边的引号就结束了</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed &#x27;2a linzhiwen&#x27; </span><br><span class="line">     1  all:</span><br><span class="line">     2          @read -p &quot;Input element :&quot; var; \</span><br><span class="line">linzhiwen</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     4          do \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">     6          done</span><br></pre></td></tr></table></figure><ul><li>将2到5行替换成linzhiwen, 就是change</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed &#x27;2,5c linzhiwen&#x27; </span><br><span class="line">     1  all:</span><br><span class="line">linzhiwen</span><br><span class="line">     6          done</span><br></pre></td></tr></table></figure><ul><li>只显示处理的结果-n，打印信息p，print，不加-n的区别就是重复显示，-n就是只显示处理的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed -n &#x27;2,5p&#x27;</span><br><span class="line">     2          @read -p &quot;Input element :&quot; var; \</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     4          do \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">-bash-4.2$ nl makefile | sed  &#x27;2,5p&#x27;</span><br><span class="line">     1  all:</span><br><span class="line">     2          @read -p &quot;Input element :&quot; var; \</span><br><span class="line">     2          @read -p &quot;Input element :&quot; var; \</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br><span class="line">     4          do \</span><br><span class="line">     4          do \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">     5            echo &quot;$$i&quot;; \</span><br><span class="line">     6          done</span><br></pre></td></tr></table></figure><ul><li>搜索匹配的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ nl makefile | sed  -n &#x27;/for/p&#x27;</span><br><span class="line">     3          for i in $$&#123;var&#125;; \</span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><blockquote><p>文本分析工具， awk ‘{pattern+action}’ &lt;filename&gt;</p></blockquote><ul><li>-F 来指定分隔符的，没有指定的情况下默认的是空格，或者是tab</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ cat /etc/passwd | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">sync</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">ftp</span><br><span class="line">nobody</span><br><span class="line">ods</span><br></pre></td></tr></table></figure><ul><li>$0是所有的域，$1是第一个</li><li>想要多个输出的话，中间中逗号分开，空格是没有用的，要给的话中间要给双引号，” “这样的是可以的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ cat /etc/passwd | awk -F : &#x27;&#123;print $1,$7&#125;&#x27;</span><br><span class="line">root /bin/bash</span><br><span class="line">bin /sbin/nologin</span><br><span class="line">daemon /sbin/nologin</span><br><span class="line">adm /sbin/nologin</span><br><span class="line">lp /sbin/nologin</span><br><span class="line">sync /bin/sync</span><br></pre></td></tr></table></figure><ul><li>加上开头和结尾，都要加上双引号的，这个结尾我没有加是错的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ cat /etc/passwd | awk -F : &#x27;BEGIN &#123;print &quot;nameshell&quot;&#125; &#123;print $1,$7&#125; END&#123;print hhhh&#125;&#x27;</span><br><span class="line">nameshell</span><br><span class="line">root /bin/bash</span><br><span class="line">bin /sbin/nologin</span><br><span class="line">daemon /sbin/nologin</span><br><span class="line">adm /sbin/nologin</span><br><span class="line">lp /sbin/nologin</span><br></pre></td></tr></table></figure><ul><li>匹配字符串，在输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ cat /etc/passwd | awk -F : &#x27; BEGIN &#123;print &quot;nameshell&quot;&#125; /^root/ &#123;print $1,$7&#125; END&#123;print &quot;hhhh&quot;&#125;&#x27;</span><br><span class="line">nameshell</span><br><span class="line">root /bin/bash</span><br><span class="line">hhhh</span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><ul><li><p>精确匹配 -w（就是匹配word）</p></li><li><p>–color&#x3D;auto，给匹配到的加上颜色</p></li><li><p>取反 -v，就是不匹配</p></li><li><p>grep -c统计行数</p></li><li><p>-l显示匹配的文件，就是在多个文件里面搜索</p></li><li><p>-i 是不区分大小的，没有这个参数默认是区分大小写的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell基础</title>
      <link href="/2024/10/19/Programming/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/19/Programming/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a><span id="more"></span></a></p><h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><h3 id="取出变量值"><a href="#取出变量值" class="headerlink" title="取出变量值"></a>取出变量值</h3><ul><li><p>单引号：所见即所得</p></li><li><p>双引号：输出引号里面的所有内容，识别特殊字符，弱引用</p></li><li><p>无引号：连续的符号可以不加引号，有空格有歧义，最好使用双引号</p></li><li><p>反引号：<kbd><code>ls</code></kbd>引用命令执行的结果，就等于$()用法</p></li><li><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3></li><li><p><a>$</a> : 获取shell脚本的文件名，以及脚本路径</p></li><li><p><a>$n</a> : 获取shell脚本的第n个参数，n在1-9之间，就可以写$1这样的，如果大于了10，就需要用$(10)，参数之间用空格隔开</p></li><li><p><a>$#</a> : 获取执行shell脚本后面的参数总个数</p></li><li><p><a>$*</a> : 获取shell脚本所有参数，不加引号等同于$@的作用，加上了引号就是把接受的参数作为单个字符串了 “$1  $2”</p></li><li><p><a>$@</a> : 不加引号，效果同上，加上了引号， 效果是分开每个参数，”$1”, “$2”， 空格保留</p></li></ul><h3 id="特殊状态变量"><a href="#特殊状态变量" class="headerlink" title="特殊状态变量"></a>特殊状态变量</h3><ul><li>$? ： 上一次命令执行是不是正常执行的，0正确，非0就是失败了</li><li>$$ ： 当前shell脚本的进程号</li><li>$! ： 上一次后台进程的PID</li><li>$_ ： 上次命令的最后一个参数</li></ul><h3 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h3><ul><li><h4 id="echo-：-输出内容到指定的"><a href="#echo-：-输出内容到指定的" class="headerlink" title="echo ： 输出内容到指定的"></a><a>echo</a> ： 输出内容到指定的</h4><ul><li>-n : 不换行输出内容</li><li>-e ： 解释转移字符</li><li>\n : 换行</li><li>\r ：回车</li><li>\t : tab</li><li>\b : 退格</li><li>\v ： 纵向制表符</li></ul></li><li><h4 id="eval-：-执行多个命令"><a href="#eval-：-执行多个命令" class="headerlink" title="eval ： 执行多个命令"></a><a>eval</a> ： 执行多个命令</h4></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval ls; cd xxx</span><br></pre></td></tr></table></figure><ul><li><h4 id="exec：-不创建子shell，执行该命令，完成命令之后自己就exit了"><a href="#exec：-不创建子shell，执行该命令，完成命令之后自己就exit了" class="headerlink" title="exec： 不创建子shell，执行该命令，完成命令之后自己就exit了"></a><a>exec</a>： 不创建子shell，执行该命令，完成命令之后自己就exit了</h4></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec date</span><br></pre></td></tr></table></figure><ul><li><h4 id="export"><a href="#export" class="headerlink" title="export"></a><a>export</a></h4></li><li><h4 id="read"><a href="#read" class="headerlink" title="read"></a><a>read</a></h4></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;Input :&quot; var</span><br></pre></td></tr></table></figure><ul><li><h4 id="shift"><a href="#shift" class="headerlink" title="shift"></a><a>shift</a></h4></li></ul><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a><a>if</a></h3><blockquote><p>语法: 如果一行里面写了多个语句，就要写分号；了，如果是一行就写了一句话了，就不用写分号了</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if command</span><br><span class="line">then </span><br><span class="line">  command</span><br><span class="line">if</span><br></pre></td></tr></table></figure><ul><li>bash的if语句会直接运行if后面的命令，如果该命令执行正确（状态码位0），处于then的命令就会被执行，否则就不会被执行，或者执行其他的逻辑语句，最后到fi结束逻辑控制</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ pwd ]</span><br><span class="line">then </span><br><span class="line">echo &quot;hhh&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if-then-else"></a><a>if-then-else</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -ge 2 ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;you need input a number more than 1&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;sorry&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="嵌套if"><a href="#嵌套if" class="headerlink" title="嵌套if"></a><a>嵌套if</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $1 -ge 2 ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;you need input a number more than 1&quot;</span><br><span class="line">else</span><br><span class="line">  if [ $1 -le 2 ]</span><br><span class="line">     echo &quot;sorry&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="elif语句"><a href="#elif语句" class="headerlink" title="elif语句"></a><a>elif语句</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $1 -le 20 ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;you need input a number more than 1&quot;</span><br><span class="line">elif [ $1 -ge  30 ]</span><br><span class="line">  then</span><br><span class="line">        echo &quot;hhhh&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a><a>test</a></h3><ul><li><p>test命令最短的定义可能是评估一个表达式；如果条件为真，则返回一个0。如果表达式不为真，则返回一个大于0的数值，也可以将其称为假值。检查最后所执行命令的状态的最简便的方法就是<kbd>$？</kbd></p></li><li><p>检测文件类型的option： test [option] filename，</p><ul><li><p>-e ： 该filename是不是存在</p></li><li><p>-f ： 该filename是不是文件</p></li><li><p>-d ： 该filename是不是目录</p></li><li><p>-b ： 该filename是不是要给block device</p></li><li><p>-c ： 该filename是不是一个character device</p></li><li><p>-s ： 该filename是不是一个socket</p></li><li><p>-p ： 该filename是不是一个FIFO（pipe）文件</p></li><li><p>-L ： 该filename是不是要给连结档</p></li></ul></li><li><p>文件权限的option ： test [option] filename</p><ul><li>-r 检测文件是不是有可读属性</li><li>-w 检测文件是不是有可写属性</li><li>-x 检测文件是不是有可执行属性</li><li>-u 检测文件是不是有SUID属性</li><li>-g 检测文件是不是有SGID属性</li><li>-k 检测文件是不是有Sticky bit属性</li><li>-s 检测文件是不是非空白文件</li></ul></li><li><p>两个文件之变的比较 ： test filename1 [option] filename2</p><ul><li>-nt （newer than）判断filename1是不是比filename2新</li><li>-ot （older than）判断filename1是不是比filename2旧</li><li>-ef 判断filename1与filename2是不是一个文件，可以用在判断hard link上面，是不是指向了同一个文件</li></ul></li><li><p>判断两个整数 ： test num1 [option] num2</p><ul><li>-eq : equal 判断两个数值相等的吗</li><li>-ne ： not equal 判断两个数值不相等的吗</li><li>-gt ： greater than 判断n1 大于 n2吗</li><li>-lt : less than 判断n1 小于 n2 吗</li><li>-ge ： greater than or equal 判断n1 大于等于 n2吗</li><li>-le ： less than or equal 判断n1 小于等于 n2吗</li></ul></li><li><p>判断字符串</p><ul><li><p>-z : 判断是不是空的，是用的就是true，不是空个，就是false</p></li><li><p>-n ： 判断是不是不是空的，不是空个就是true，是空的就是false</p></li><li><p>&#x3D; ： string1 是不是等于string2</p></li><li><p>!&#x3D; ： string1 是不是不等于string2</p></li></ul></li><li><p>&amp;&amp; 与 || （和c语言中的是一样的）</p></li><li><p>数学表达式： bash支持<strong>双小括号</strong>写入高级的数学表达式</p></li></ul><p><img src="https://s2.loli.net/2024/10/19/yfeJ1AmC9bQkFvL.png" alt="image-20240317154916014"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=199</span><br><span class="line">if (( &quot;$var&quot; &gt; $1 ));then</span><br><span class="line">  echo &quot;$var is greater than $1&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="双中括号"><a href="#双中括号" class="headerlink" title="双中括号[[]]"></a>双中括号[[]]</h3><ul><li>双中括号提供了针对字符串的高级特性，模式匹配，正则表达式的匹配</li><li>&#x3D;&#x3D; ： 就是c语言里面的，是不是相等意思</li></ul><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><ul><li>就是和c语言里面是一样的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case &quot;$1&quot; in</span><br><span class="line">1)</span><br><span class="line">  echo &quot;\$1 is 1&quot;</span><br><span class="line">;;</span><br><span class="line">2)</span><br><span class="line">  echo &quot;\$2 is 2&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a>for命令</h3><ul><li>和c语言的一样,但是里面可能需要转义符号和双引号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..100&#125;;do</span><br><span class="line"> echo &quot;$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>for遍历文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">for word in $(cat lin.sh)</span><br><span class="line">do</span><br><span class="line">echo &quot;$word&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>c语言风格的for循环</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( a=1,b=2;a&lt;=10;a++,b++ ))</span><br><span class="line">do </span><br><span class="line">        echo &quot;$a &amp;&amp; $b&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while [ $1 -gt $2 ];do</span><br><span class="line"> echo &quot;$1 is greater than $2&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>执行多个命令的时候，每条命令都是单独一行的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">while echo &quot;$1&quot; </span><br><span class="line"> [ $1 -gt $2 ] </span><br><span class="line">do</span><br><span class="line"> echo &quot;$1 is greater than $2&quot;</span><br><span class="line">sleep 23</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h3><ul><li>和while的用法是一样的，就是意思是相反的</li></ul><h3 id="IFS分隔符"><a href="#IFS分隔符" class="headerlink" title="IFS分隔符"></a>IFS分隔符</h3><ul><li>用来指定分隔符的，没有指定的话，好像是空格，可以指定的分割符有：空格，制表符，换行符，逗号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">oldifs=$IFS</span><br><span class="line">IFS=,</span><br><span class="line">names=&quot;lin,zhi,wen&quot;</span><br><span class="line">for i in $names;</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line">IFS=$oldifs</span><br></pre></td></tr></table></figure><h3 id="打断循环"><a href="#打断循环" class="headerlink" title="打断循环"></a>打断循环</h3><ul><li>break<ul><li>break 2，就是跳出两层循环，其他的和c语言是一样的</li></ul></li><li>continue： 和c是一样的</li></ul><h3 id="循环输出的重新定向"><a href="#循环输出的重新定向" class="headerlink" title="循环输出的重新定向"></a>循环输出的重新定向</h3><ul><li>在shell脚本里面，循环输出后的结果，可以进行重定向</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">oldifs=$IFS</span><br><span class="line">IFS=,</span><br><span class="line">names=&quot;lin,zhi,wen&quot;</span><br><span class="line">for i in $names;</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done &gt; tudou.txt</span><br><span class="line">IFS=$oldifs</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h3><ul><li>当你需要一段重复的代码的时候，就可以把这段代码定义成函数了，可以重复的调用，下面是两种常用的定义函数的方式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标准的函数的定义，func_name后面可以不给括号，建议标准的写法吧</span></span><br><span class="line">function func_name() &#123;</span><br><span class="line">command</span><br><span class="line">return 状态码</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">简化的函数的定义</span></span><br><span class="line">func_name() &#123;</span><br><span class="line">command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lin_func_use() &#123;</span><br><span class="line">        echo &quot;$1&quot;</span><br><span class="line">&#125;</span><br><span class="line">if [ $# -gt 1 ];then</span><br><span class="line">  lin_func_use &quot;$1&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li>函数名需要唯一，负责会覆盖函数的定义的，就是和c语言一样的</li><li>在函数里面使用<kbd>return</kbd>命令来定制特殊的退出状态码，也可以保存到变量里面</li><li>函数里面的变量是属于局部变量的，写在脚本里面的变量是全局变量（除了函数体内部的）</li><li>可以在函数体里面生命上<kbd>local</kbd>，声明为局部的，虽然我认为没有什么用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">name=&quot;linzhiwen&quot;</span><br><span class="line">lin_func_use() &#123;</span><br><span class="line">        local name=&quot;lin&quot;</span><br><span class="line">        echo &quot;$name&quot;</span><br><span class="line">        return 2;</span><br><span class="line">&#125;</span><br><span class="line">if [ $# -gt 1 ];then</span><br><span class="line">  lin_func_use &quot;$1&quot;</span><br><span class="line">fi</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog基础</title>
      <link href="/2024/10/19/Programming/SystemVerilog%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/19/Programming/SystemVerilog%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 SystemVerilog 中，理解基本的数据类型、数组和队列的操作是构建有效仿真模型的基础。 <a><span id="more"></span></a></p></blockquote><h2 id="内建数据类型"><a href="#内建数据类型" class="headerlink" title="内建数据类型"></a><a>内建数据类型</a></h2><p>SystemVerilog 支持多种数据类型，分为两类：四状态和双状态。</p><h4 id="四状态数据类型"><a href="#四状态数据类型" class="headerlink" title="四状态数据类型"></a>四状态数据类型</h4><ul><li><strong>reg</strong>：用于存储值的变量，可以是 1-bit 或多个 bit 的宽度，支持四个状态（<code>0</code>, <code>1</code>, <code>X</code>, <code>Z</code>）。</li><li><strong>wire</strong>：用于连接模块之间的信号，也支持四个状态。</li><li><strong>logic</strong>：与 <code>reg</code> 类似</li><li><strong>integer</strong>：32 位有符号整数，默认值为 <code>x</code>。</li><li><strong>time</strong>：表示时间的变量，默认值为 <code>X</code>。</li></ul><h4 id="双状态数据类型"><a href="#双状态数据类型" class="headerlink" title="双状态数据类型"></a>双状态数据类型</h4><ul><li><strong>bit</strong>：只有两种状态（<code>0</code> 或 <code>1</code>），通常用于表示布尔值。</li><li><strong>int</strong>、<strong>byte</strong>、<strong>shortint</strong>、<strong>longint</strong>：无符号整数类型，范围根据位宽不同而不同。</li><li><strong>real</strong>：浮点数类型，默认值为 <code>0</code>。</li></ul><h4 id="有符号数与无符号数"><a href="#有符号数与无符号数" class="headerlink" title="有符号数与无符号数"></a>有符号数与无符号数</h4><p>可以使用 <code>unsigned</code> 来声明无符号数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bit signed [7:0] signed_val;</span><br><span class="line">byte unsigned unsigned_val;</span><br></pre></td></tr></table></figure><h2 id="isunknown-操作符"><a href="#isunknown-操作符" class="headerlink" title="$isunknown 操作符"></a><a><code>$isunknown</code> 操作符</a></h2><p><code>$isunknown</code> 是一个非常有用的操作符，它检查表达式中是否有 <code>X</code> 或 <code>Z</code> 状态。如果表达式的某个位含有 <code>X</code> 或 <code>Z</code>，返回 <code>1</code>，否则返回 <code>0</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($isunknown(signal)) begin</span><br><span class="line">    // 如果 signal 中含有 X 或 Z，执行相应操作</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a><a>数组操作</a></h2><h4 id="数组初始化与操作"><a href="#数组初始化与操作" class="headerlink" title="数组初始化与操作"></a>数组初始化与操作</h4><p>在 SystemVerilog 中，数组的初始化、比较、复制和循环是常见的操作，可以使用 <code>for</code> 或 <code>foreach</code> 来遍历数组。</p><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><p>动态数组可以使用 <code>new[]</code> 来分配空间，或者复制现有数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int arr1[];</span><br><span class="line">arr1 = new[10]; // 分配 10 个元素的空间</span><br><span class="line"></span><br><span class="line">int arr2[];</span><br><span class="line">arr2 = new[5]; // 分配 5 个元素的空间</span><br><span class="line"></span><br><span class="line">arr2 = arr1; // 复制数组</span><br></pre></td></tr></table></figure><h5 id="释放数组"><a href="#释放数组" class="headerlink" title="释放数组"></a>释放数组</h5><p>使用 <code>.delete()</code> 来释放动态数组的空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1.delete();</span><br></pre></td></tr></table></figure><h5 id="数组宽度"><a href="#数组宽度" class="headerlink" title="数组宽度"></a>数组宽度</h5><p>使用 <code>$size</code> 来返回数组的大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int arr[10];</span><br><span class="line">int size = $size(arr); // 返回 10</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a><a>队列</a></h2><p>队列是一个非常灵活的数据结构，支持动态变化的元素。以下是常用的队列操作：</p><ul><li><strong>声明队列</strong>：<code>q[$]</code>，<code>$</code> 表示队列的最大或最小索引。</li><li><strong>插入元素</strong>：使用 <code>insert(idx, value)</code> 在指定位置插入元素（并非所有仿真器支持插入操作）。</li><li><strong>删除元素</strong>：使用 <code>delete(idx)</code> 删除指定位置的元素。</li><li><strong>前端插入</strong>：使用 <code>push_front(value)</code> 在队列前面插入元素，等价于 <code>q = &#123;value, q&#125;</code>。</li><li><strong>后端插入</strong>：使用 <code>push_back(value)</code> 在队列末尾插入元素，等价于 <code>q = &#123;q, value&#125;</code>。</li><li><strong>从队列移除元素</strong>：使用 <code>pop_front</code> 或 <code>pop_back</code>，分别从队列的前端或后端移除元素。</li></ul><p>队列的遍历也可以使用 <code>for</code> 或 <code>foreach</code>。</p><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a><a>数组常用方法</a></h2><p>数组类型提供了一些非常实用的方法，帮助进行数据处理：</p><ul><li><code>arr.sum</code>, 返回数组所有元素和</li><li><code>arr.product</code>, 返回数组所有元素积</li><li><code>arr.and</code>, 返回数组所有元素的与</li><li><code>arr.or</code>, 返回数组所有元素的或</li><li><code>arr.xor</code>, 返回数组所有元素的异或</li><li><code>arr.min()</code>, 返回数组中的最小值队列(<strong>注意：返回的是队列，而不是标量</strong>)</li><li><code>arr.max()</code>, 返回数组中的最大值队列(<strong>注意：返回的是队列，而不是标量</strong>)</li><li><code>arr.unique()</code>, 返回数组中具有唯一值的队列</li><li><code>arr.find with (condition)</code>, 返回满足条件元素的队列</li><li><code>arr.find_index with (condition)</code>, 返回满足条件元素下标的队列</li><li><code>arr.find_first with (condition)</code>, 返回满足条件第一个元素的队列</li><li><code>arr.find_first_index with (condition)</code>, 返回满足条件第一个元素下标的队列</li><li><code>arr.find_last with (condition)</code>, 返回满足条件第最后一个元素的队列</li><li><code>arr.find_last_index with (condition)</code>, 返回满足条件最后一个元素下标的队列</li><li><code>arr.reverse()</code>, 数组反向</li><li><code>arr.sort()</code>, 数组从小到大排序</li><li><code>arr.rsort()</code>, 数组从大到小排序</li><li><code>arr.shuffle()</code>, 数组打乱顺序</li><li>其中<code>reverse</code>和<code>shuffle</code>方法不能带with条件语句，它们的作用范围是整个数组</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><a>字符串</a></h3><p>在 SystemVerilog 中，字符串操作非常直观，支持常见的字符串处理功能：</p><ul><li><code>s.getc(N)</code>：返回字符串中第 N 位的字符。</li><li><code>s.tolower()</code>：将字符串转换为小写字母。</li><li><code>s.toupper()</code>：将字符串转换为大写字母。</li><li><code>s.putc(N, C)</code>：将字符 C 写入字符串的第 N 位。</li><li><code>s.substr(start, end)</code>：提取从 <code>start</code> 到 <code>end</code> 的子字符串。</li><li><code>s.len()</code>：返回字符串的长度。</li></ul><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>SystemVerilog 提供了 <code>$psprintf()</code> 方法来格式化字符串，可以直接传递给其他函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string formatted_str = $psprintf(&quot;The value of x is %0d&quot;, x);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC </tag>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
